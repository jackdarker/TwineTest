"use strict";
/* classes to affect...: 
    - the state of a character like     'tired'
    - stats of a character like healthMax
    - 
 */
///////////////////////////////////////////////////////////////
 class StatsDictionary extends Inventory {  //Todo a collection of Stats is similiar to Inventory?
    constructor(externlist) {
        super(externlist);
        window.storage.registerConstructor(StatsDictionary);
    }
    toJSON() {return window.storage.Generic_toJSON("StatsDictionary", this); };
    static fromJSON(value) {
        var _x = window.storage.Generic_fromJSON(StatsDictionary, value.data);
        return(_x);
    }
    //
    get(id) {
        return(this.getItem(id));
    }
    modifyHidden(id,hidden) {
        var _data = this.get(id).data;
        _data.hidden=hidden;
    }
    // adds a modifier to a Stat or replaces it
    addModifier(toId, modData) {
        var _stat = this.get(toId);
        var _oldMods = _stat.data.modifier;
        var _x=-1;
        for(var i=0;i<_oldMods.length;i++){
            if(_oldMods[i].id===modData.id) _x=i;
        }
        if(_x>=0) _oldMods.splice(_x,1);
        _oldMods.push(modData);
        window.gm.pushLog(_stat.Calc().msg);
    }
    removeModifier(toId,modData) {
        var _stat = this.get(toId);
        var _oldMods = _stat.data.modifier;
        var _x=-1;
        for(var i=0;i<_oldMods.length;i++){
            if(_oldMods[i].id===modData.id) _x=i;
        }
        if(_x>=0) _oldMods.splice(_x,1);
        window.gm.pushLog(_stat.Calc().msg);
    }
    //override
    postItemChange(id,operation,msg) {
        window.gm.pushLog('Stats: '+operation+' '+id+' '+msg+'</br>');
    }
    //override; only use to create new stats !
    addItem(stat) {
        var _i = this.findItemSlot(stat.name);
        if(_i<0) {
            stat._parent=window.gm.util.refToParent(this);
            this.list.push({'id': stat.name,'count': 1, item:stat});
        }
    }
    //override
    removeItem(id) {
        var _i = this.findItemSlot(id);
        if(_i<0) return; //just skip if not found
        var _stat = this.get(id);
        this.list.splice(_i,1);
        _stat.calc();   //trigger update of dependent stat
    }
    increment( id, value) {
        var attr = this.get(id);
        attr.data.base += value;
        window.gm.pushLog(attr.Calc(this,id).msg);
    }
}
//class for an Attribute
class Stat {
    static dataPrototype() {    
        return({id: '', base: 0,value: 0, limits: [],modifier:[], modifys:[], hidden:0});
        //limit = {id: min: max:}   limit to apply to value and base
        //modifier {id: calc:}      Stat that modifys value, calc is function(context,data)=> newvalue
        //modifys {id:}         point to the Stats that have modifiers from this stat or is used as limit
        //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
    // Attention !!
    //_parent will be added dynamical
    get parent() {return this._parent();}
    //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};

    constructor() {
        this.data = Stat.dataPrototype();
    }
    get name() {return(this.data.id);}
    get id() {return(this.data.id);}
    get base() {return(this.data.base);}
    get value() {return(this.data.value);}
    get hidden() {return(this.data.hidden);}
    //this is called to update value of the stat and will trigger calculation of dependend stats 
    Calc( ) {
        var attr = this.data;
        var min = -99999;
        var max = 99999;
        var msg = '';
        //get limits
        for(var k=0;k<attr.limits.length;k++) {
            if (attr.limits[k].min!=='') min= Math.max(this.parent.get(attr.limits[k].min).value,min); //this might behave odly if any min>max
            if (attr.limits[k].max!=='') max= Math.min(this.parent.get(attr.limits[k].max).value,max); 
        }
        //recalculate modifiers
        var _old =  attr.value;
        attr.base = attr.value = Math.max(min,Math.min(max,attr.base));  
        for(var i=0;i<attr.modifier.length;i++) {
            attr.value += attr.modifier[i].bonus;
        }
        var _new = Math.max(min,Math.min(max,attr.value));
        attr.value = _new;
        msg+=this.formatMsgStatChange(attr,_new,_old);//todo no log hidden
        this.updateModifier();
        //trigger recalculation of dependend Stats
        for(var m=0;m<attr.modifys.length;m++) {
            msg+=this.parent.get(attr.modifys[m].id).Calc().msg;
        }
        return({OK:true,msg:msg});
    }
    formatMsgStatChange(attr,_new,_old) {
        if((_new-_old)>0) { 
            return('<statup>'+attr.id+" regenerated by "+(_new-_old).toFixed(1).toString()+"</statup></br>");
        } else if((_new-_old)<0) {
            return('<statdown>'+attr.id+" decreased by "+(_new-_old).toFixed(1).toString()+"</statdown></br>");
        }
        return("");
    };
    updateModifier() {};
}


/////////////////////////////////////////////////////////////////////////
class Effects extends Inventory {  //Todo a collection of Stats is similiar to Inventory?
    constructor(externlist) {
        super(externlist);
        window.storage.registerConstructor(Effects);
    }
    toJSON() {return window.storage.Generic_toJSON("Effects", this); };
    static fromJSON(value) {
        var _x = window.storage.Generic_fromJSON(Effects, value.data);
        return(_x);
    }
    get(id){
        return(this.getItem(id));
    }
    //findItemslot uses id, this one finds all effects(-slot) of one type
    findEffect(name) {
        var _items = [] ;
        for (var i = 0; i < this.count(); i++) {
            if(this.list[i].name===name) _items.push(i);
        }
        return(_items);
    }
    //override
    removeItem(id) {
        var _i = this.findItemSlot(id);
        if(_i<0) return; //just skip if not found
        var _eff = this.get(id);
        this.list.splice(_i,1);
        _eff.onRemove(this,this.list[_i]);
        this.postItemChange(id,"removed","");
    }
    addItem(id,effect) {
        var _i = this.findItemSlot(id);
        var res;
        //if effect with same id is already present, merge them
        if(_i>-1) {
            var _old = this.get(effect.id);
            res = _old.merge(effect);
            //res =window.gm.EffectLib[this.list[_i].name].merge(this,this.list[_i],effect,effect.dataPrototype());
            if(res!=null) {
                if(res===true) {}
                else res(this); //should be a function
                this.postItemChange(id,"merged","");
                return;
            }  
        }
        //or if there are similiar effects try to merge with them
        var _k = this.findEffect(effect.name);
        for(var i=0;i<_k.length;i++) {
            var _old = this.list[_k];
            res = _old.merge(effect);
            //res =window.gm.EffectLib[this.list[_k].name].merge(this,this.list[_i],effect,effect.dataPrototype());
            if(res!=null) {
                if(res===true) {}
                else res(this); //should be a function
                this.postItemChange(id,"merged","");
                break;
            }  
        }
        //else add it to list
        this.list.push({'id': id,'count': 1, item:effect});
        effect._parent = window.gm.util.refToParent(this);
        effect.onApply();
        this.postItemChange(id,"added","");
    }
    replace(id, neweffect) {
        var _i = this.findItemSlot(id);
        if(_i<0) return; //Todo do nothing
        var _old = this.get(id);
        _old.onRemove();
        //window.gm.EffectLib[this.list[_i].name].onRemove(this,this.list[_i]);
        neweffect._parent = window.gm.util.refToParent(this);
        this.list[_i].item = neweffect;
        neweffect.onApply(this,neweffect);
    }
    updateTime() {
        var now =window.gm.getTime();
        for(var i=0;i<this.list.length;i++){
            var _eff = this.list[i].item;
            var foo = _eff.onTimeChange(now);   
            if(foo) foo(this);
        }
    }
    //override
    postItemChange(id,operation,msg) {
        window.gm.pushLog('Effects: '+operation+' '+id+' '+msg+'</br>');
    }
}

//
class Effect {  
    constructor() {
        this.data = Effect.dataPrototype();
        this.data.time = window.gm.getTime();
    }
    static dataPrototype() {
        return({id:'xxx', name: Effect.name, time: 0, duration:0,hidden:0});
        //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
    // Attention !!
    //_parent will be added dynamical
    get parent() {return this._parent();}
    get id() {return(this.data.id);}
    get name() {return(this.data.name);}
    get time() {return(this.data.time);}
    get duration() {return(this.data.duration);}
    get hidden() {return(this.data.hidden);}
    get shortDesc() {return('');}
        //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};
    
    //is called when a effect is applied to check if the new effect can be combined with an exisitng one
    //return null if no merge occured
    //return true if the neweffect was merged into existing one; no other effects are then checked for mergeability
    //or return function that has to be executed: (function(Effects){ Effects.replace(data.id,NotTired);}));
    merge(neweffect) {
        return(null);
    }
    onTimeChange(time) {
        return(null);
    }
    onApply(){}
    onRemove(){}
}
//combat effect use turn-count instead of realtime as duration
class CombatEffect extends Effect {
    constructor() {
        super(); 
    }
    get shortDesc() {return('missing description');}
    //duration in turns !
    static onCombatEnd(context,data) {}
    //called before targets turn
    static onTurnStart(context,data) {}
    //at end of targets turn
    static onTurnEnd(context,data) {}
}





