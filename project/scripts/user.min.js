"use strict";
/* bundles some operations related to combat */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effects = exports.StatsDictionary = exports.Outfit = exports.Crowbar = exports.Pullover = exports.TankShirt = exports.Jeans = exports.Leggings = exports.Equipment = exports.Character = void 0;

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

window.gm = window.gm || {};

window.gm.initCombat = function (id) {
  //setup enemy for encounter
  var s = window.story.state;
  s.enemy.name = id;
  s.combat.activeTurn = false;
  s.combat.combatState = 'battling';
};

window.gm.hideCombatOption = function () {
  document.querySelector("#combatmenu").remove();
};

window.gm.printCombatOption = function () {
  //creates a list of possible moves
  var elmt = "<form id='combatmenu'>";
  elmt += "<a0 id='RunAway' onclick='(function($event){window.gm.triggerCombat($event.id);})(this);'>Try to flee</a></br>";
  elmt += "<a0 id='Attack' onclick='(function($event){window.gm.triggerCombat($event.id);})(this);'>Attack</a></br>"; //elmt +="<a0 id='Guard' onclick='(function($event){window.gm.execCombatCmd($event.id);"+next+"})(this);'>Guard</a></br>";
  //elmt +="<a0 id='showItems' onclick='(function($event){window.gm.execCombatCmd($event.id);"+next+"})(this);'>Item</a></br>";

  elmt += "</form>";
  return elmt;
};

window.gm.printCombatScreen = function () {
  //prints scene-bg and enemy to canvas 
  var canvas = document.getElementById("exampleCanvas");
  var ctx = canvas.getContext("2d");
  var img = new Image();
  img.src = "assets/bg_park.png"; //todo the loading o image takes a while and it will not refreh automatically

  ctx.drawImage(img, 0, 0);
  img = new Image();
  img.src = "assets/bird.gif"; //todo the loading o image takes a while and it will not refreh automatically

  ctx.drawImage(img, 0, 0);
};

window.gm.triggerCombat = function (id) {
  //called by combatmenu-buttons
  window.gm.hideCombatOption();
  var msg = window.gm.execCombatCmd(id);
  window.gm.printOutput(msg + window.gm.printPassageLink("Next", "EncounterStartTurn"));
  window.gm.printCombatHud();
};

window.gm.calcEnemyCombat = function () {
  //calculates which combat-cmd the enemy should execute
  var rnd = _.random(1, 100);

  var enemy = window.story.state.enemy;
  var msg = '';

  if (rnd > 30) {
    msg += enemy.name + " try to attack you.</br>";
    msg += window.gm.execCombatCmd('Attack');
  } else {
    msg += enemy.name + " takes a defensive stance.</br>";
    msg += window.gm.execCombatCmd('Guard');
  }

  return msg + "</br>";
};

window.gm.execCombatCmd = function (id) {
  //executes a combat-cmd
  var enemy = window.gm.enemy;
  var player = window.gm.player;
  var s = window.story.state;

  var rnd = _.random(1, 100);

  var msg = '';
  var result = {};

  if (s.combat.activeTurn) {
    if (id === 'Attack') {
      result = window.gm.calcAttack(s.combat.activeTurn);
      msg += result.msg;
    }
  } else {
    if (id === 'Attack') {
      result = window.gm.calcAttack(s.combat.activeTurn);
      msg += result.msg;
    } else if (id === 'RunAway') {
      if (rnd > 40) {
        msg += "You escaped the fight.";
        s.vars.combatState = 'fleeing'; //just setting the flag, you have to take care of handling!
      } else {
        msg += "Your attempts to escape failed.";
      }
    }
  }

  s.combat.activeTurn = !s.combat.activeTurn; //toggle whos turn

  return msg + "</br>";
};

window.gm.calcAttack = function (enemysTurn) {
  //calculates damage of attack
  var attacker = enemysTurn ? window.gm.enemy : window.gm.player;
  var defender = enemysTurn ? window.gm.player : window.gm.enemy;
  var s = window.story.state;
  var OK = false;
  var msg = '';
  var crit = false,
      hit = false,
      block = false;
  var def = defender.Stats.get('pDefense').value;
  var att = attacker.Stats.get('pAttack').value; //GURPS-Lite ? this would means all skills are limited to 20!
  //atacker rolls 3d6; if < Attackskill you hit; if 3or4 you have critical hit; else you missed completely

  var rnd = window.gm.roll(3, 6);

  if (rnd == 3 || rnd == 4) {
    crit = hit = true;
    msg += attacker.name + ' landed a critical hit.</br>';
  } else if (rnd <= att) {
    hit = true;
  } else {
    msg += attacker.name + ' missed his target.</br>';
  } //defender rolls 3d6 (no roll on critical hit); if < Defense, the hit was avoided


  rnd = window.gm.roll(3, 6);

  if (crit == false) {
    if (rnd == 3 || rnd == 4) {
      hit = false;
      msg += defender.name + ' avoided beeing hit.</br>';
    } else if (rnd <= def) {
      block = true;
      msg += defender.name + ' was hit but shrugged of the damage.</br>';
    }
  } //attacker rolls dies according to weapon; damage is the result reduced by DR


  if (hit == true && block == false) {
    rnd = Math.max(0, rnd = window.gm.roll(1, 6) + 1 - 0); //todo

    defender.Stats.increment('health', -1 * rnd);
    msg += attacker.name + ' dealt ' + rnd + ' damage to ' + defender.name + '.</br>';
  }

  return {
    OK: hit && !block,
    msg: msg
  };
};

window.gm.printCombatHud = function () {
  //prints the Stats and Effects of the Player&Enemy
  renderToSelector("#playerstats", "playerstats");
  renderToSelector("#enemystats", "enemystats");
};

"use strict"; //import {LighterDad} from './Items.js'; //why is this not working
//constant declarations
//this is a lookuptable for items


function getVersion() {
  return "0,0,0,";
}

function createItemLookups() {
  window.gm.ItemsLib = {}; //window.gm.ItemsLib = { 

  window.gm.ItemsLib['LighterDad'] = new LighterDad(); // { name: 'Lighter from Dad', desc: 'I got this lighter from my real dad.', usable:defaultCanUse, use:defaultOnUse },

  window.gm.ItemsLib['LaptopPS'] = new LaptopPS(); //{name: 'Laptop-PS', desc:'Power converter for laptop.', usable: function(){return ({OK: false, msg:'not usable on its own'})},use: defaultNoUse};

  window.gm.ItemsLib['CanOfCoffee'] = new CanOfCoffee(); // {name: 'Can of coffee', desc: 'Cold coffee in a can. Tasty? Not really!', usable:canConsumeCoffee, use:onUseCoffee };

  window.gm.ItemsLib['SimpleFood'] = new SimpleFood(); //{name: 'food ration', desc: 'You can eat this.', usable:defaultCanUse, use:defaultOnUse };
  //.. and Wardrobe

  window.gm.ItemsLib['Leggings'] = new Leggings(); //{ name: 'Sport-Leggings', desc: 'Spandex-leggings for sport.', tags: ['cloth'], slotUse: ['Legs'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Tank-shirt'] = new TankShirt(); //{name: 'White Tank-shirt', desc:'White Tank-shirt.',tags: ['cloth'],slotUse: ['Torso','Arms'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Jeans'] = new Jeans(); // {name: 'Bluejeans', desc: 'Thight fitting blue jeans.',tags: ['cloth'], slotUse: ['Legs'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip  };

  window.gm.ItemsLib['Pullover'] = new Pullover(); //{name: 'Pullover', desc: 'A warm pulloer.', tags: ['cloth'],slotUse: ['Torso','Arms'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };
  //special wardrobe-item combination

  window.gm.ItemsLib['Crowbar'] = new Crowbar(); //{name: 'Crowbar', desc: 'A durable crowbar.', tags: ['tool', 'weapon'], slotUse: ['RHand'],usable:defaultCanUse, use:defaultOnUse,canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Shovel'] = {
    name: 'Shovel',
    desc: 'A shovel for the dirty work.',
    tags: ['tool', 'weapon'],
    slotUse: ['RHand', 'LHand'],
    usable: defaultCanUse,
    use: defaultOnUse,
    canEquip: defaultCanUse,
    canUnequip: defaultCanUnequip
  };
  window.gm.ItemsLib['Handcuffs'] = {
    name: 'Handcuffs',
    desc: 'You cannot use your hand.',
    tags: ['restrain'],
    slotUse: ['RHand', 'LHand'],
    usable: defaultCanUse,
    use: defaultOnUse,
    canEquip: defaultCanUse,
    canUnequip: defaultNoUnequip
  }; //};
  //lookup table 

  window.gm.StatsLib = {
    'strength': stStrength,
    //'perception':stPerception,
    'endurance': stEndurance,
    //'charisma':stCharisma,
    //'intelligence':stIntelligence,
    'agility': stAgility,
    //'luck':stLuck,
    'pAttack': stPAttack,
    'pDefense': stPDefense,
    'health': stHealth,
    //{name: 'Health', desc: 'How healthy you are.',onChange: defaultOnChange,onApply:defaultOnApply, onRemove:defaultOnRemove},
    'healthMax': stHealth,
    'energy': stEnergy,
    'energyMax': stEnergy //{name: 'Energy', desc: 'How much energy you have.',onChange: defaultOnChange,onApply:defaultOnApply, onRemove:defaultOnRemove}

  }; //lookup table 

  window.gm.EffectLib = {
    'NotTired': effNotTired,
    'Tired': effTired,
    //{name: 'Tired', desc: 'You feel tired',onTimeChange: defaultTimeChange,onApply:defaultOnApply, onRemove:defaultOnRemove},
    'Energized': effEnergized //{name: 'Energized', desc: 'You feel energized',onTimeChange: defaultTimeChange,onApply:defaultOnApply, onRemove:defaultOnRemove}

  };
  window.gm.EnemyLib = {
    'Mole': {
      name: 'Mole',
      pic: 'assets/mole.jpg'
    },
    'Mechanic': {
      name: 'Mechanic-Guy',
      pic: 'assets/mechanic.jpg'
    }
  }; //mapping from passage-locations to background images

  window.gm.ScenePic = {
    'Garden': {
      pic: 'assets/bg_park.png'
    },
    'Park': {
      pic: 'assets/bg_park.png'
    }
  };
}

"use strict"; //var window = window || {};  //to supress lint-errors
//import * as con from "const.js";
//import {Inventory} from './inventory.js'; //already included??


window.gm = window.gm || {}; //game related operations

window.gm.getSaveVersion = function () {
  var version = [0, 1, 0];
  return version;
};

window.gm.initGame = function (forceReset) {
  createItemLookups(); //this does not work because hidden is called to late

  /*$(window).on('sm.passage.hidden', function(event, eventObject) {
    
    if(eventObject.passage) {// No passage to hide when story starts
        console.log('hiding'+eventObject.passage.name);        
    }
  });*/

  $(window).on('sm.passage.showing', function (event, eventObject) {
    // Current Passage object
    $("tw-passage").fadeIn(500); //fade in if was previously faded out

    console.log('showing ' + eventObject.passage.name);
  }); // Render the passage named HUD into the element todo replace with <%=%>??

  $(document).on('sm.passage.shown', function (ev, eventObject) {
    renderToSelector("#sidebar", "sidebar");
  });
  var s = window.story.state; //s in template is window.story.state from snowman!

  if (!s.vars || forceReset) {
    // storage of variables that doesnt fit player
    s.vars = {
      debug: true,
      //TODO set to false for distribution !   
      version: window.gm.getSaveVersion(),
      log: [],
      passageStack: [],
      time: 700,
      //represented as hours*100 +minutes
      day: 1,
      activePlayer: 'Ratchel',
      //id of the character that the player controls currently
      //queststates
      qLaptop: 0,
      // see passage _Laptop_
      qDogSit: 0,
      // see 
      qExploredCity: 0,
      //see passage into city
      qUnlockPark: 0,
      qUnlockMall: 0,
      qUnlockRedlight: 0,
      qUnlockBeach: 0
    };
  }

  if (!s.enemy || forceReset) {
    //actual/last enemy
    s.enemy = Character.defaultData();
    s.enemy.pic = 'assets/mole.jpg';
    window.gm.enemy = new Character(s.enemy);
  }

  if (!s.combat || forceReset) {
    //see encounter & combat.js
    s.combat = {
      activeTurn: false,
      //true if enemys turn
      combatState: "",
      scenePic: 'assets/bg_park.png'
    };
  }

  if (!s.mom || forceReset) {
    s.mom = {
      location: "Kitchen",
      coffeeStore: 5,
      foodStore: 3,
      foodMaxStore: 4
    };
  }

  if (!s.Cyril || forceReset) {
    //alternative player character
    s.Cyril = Character.defaultData(); //get default struct and add some special data

    s.Cyril.name = 'Cyril', s.Cyril.skillPoints = 0, //no. of free skillpoints on game-start
    //perklevels ,name should match perkId
    s.Cyril.skSporty = 0, s.Cyril.skCook = 0, s.Cyril.skSlacker = 0, s.Cyril.skMoneymaker = 0, s.Cyril.skTechy = 0, window.gm.Cyril = new Character(s.Cyril); //add some basic inventory

    window.gm.Cyril.Wardrobe.addItem('Jeans');
    window.gm.Cyril.Wardrobe.addItem('Tank-shirt');
    window.gm.Cyril.Outfit.addItem('Jeans');
    window.gm.Cyril.Outfit.addItem('Tank-shirt');
    window.gm.Cyril.Stats.increment('strength', 3); //delete window.gm.Cyril;     Todo we could delete the character-object after story-data is initialized but then we cannot use object-methods on it
  }

  if (!s.Ratchel || forceReset) {
    s.Ratchel = Character.defaultData(); //get default struct and add some special data

    s.Ratchel.name = 'Ratchel', s.Ratchel.skillPoints = 2, //no. of free skillpoints on game-start
    //perklevels ,name should match perkId
    s.Ratchel.skSporty = 0, s.Ratchel.skCook = 0, s.Ratchel.skSlacker = 0, s.Ratchel.skMoneymaker = 0, s.Ratchel.skTechy = 0, window.gm.Ratchel = new Character(s.Ratchel); //add some basic inventory

    window.gm.Ratchel.Inv.addItem('LighterDad');
    window.gm.Ratchel.Wardrobe.addItem('Jeans');
    window.gm.Ratchel.Wardrobe.addItem('Leggings');
    window.gm.Ratchel.Wardrobe.addItem('Tank-shirt');
    window.gm.Ratchel.Wardrobe.addItem('Pullover');
    window.gm.Ratchel.Outfit.addItem('Jeans');
    window.gm.Ratchel.Outfit.addItem('Pullover'); //delete window.gm.Ratchel;
  }

  window.gm.switchPlayer(s.Ratchel.name); //start-player
};

window.gm.switchPlayer = function (playername) {
  var s = window.story.state;
  s.player = s[playername];
  window.gm.player = new Character(s.player);
  s.vars.activePlayer = playername;
};

window.gm.rebuildObjects = function () {
  //Reconnect the objects after load!  
  var s = window.story.state;
  window.gm.Ratchel = new Character(s.Ratchel);
  window.gm.Cyril = new Character(s.Cyril);
  window.gm.switchPlayer(s.vars.activePlayer);
}; //returns timestamp sine start of game


window.gm.getTime = function () {
  return window.story.state.vars.time + 2400 * window.story.state.vars.day;
}; //calculates timedifference for hhmm time format


window.gm.getDeltaTime = function (a, b) {
  var m = a % 100;
  var h = (a - m) / 100;
  var m2 = b % 100;
  var h2 = (b - m2) / 100;
  return h * 60 + m - (h2 * 60 + m2);
}; //adds MINUTES to time


window.gm.addTime = function (min) {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  m = m + min;
  var m2 = m % 60;
  var h2 = h + (m - m2) / 60;
  window.story.state.vars.time = h2 * 100 + m2 % 60;

  while (window.story.state.vars.time >= 2400) {
    window.story.state.vars.time -= 2400;
    window.story.state.vars.day += 1;
  }

  window.gm.player.Effects.updateTime();
};

window.gm.getTimeString = function () {
  var c = window.gm.getTimeStruct();
  return (c.hour < 10 ? "0" : "") + c.hour.toString() + ":" + (c.min < 10 ? "0" : "") + c.min.toString() + "(" + c.daytime + ")";
};

window.gm.getTimeStruct = function () {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var daytime = '';

  if (v.time > 500 && v.time < 1000) {
    daytime = 'morning';
  } else if (v.time >= 1000 && v.time < 1400) {
    daytime = 'noon';
  } else if (v.time >= 1400 && v.time < 1800) {
    daytime = 'afternoon';
  } else if (v.time >= 1800 && v.time < 2200) {
    daytime = 'evening';
  } else {
    daytime = 'night';
  }

  return {
    'hour': h,
    'min': m,
    'daytime': daytime
  };
};

window.gm.getDateString = function () {
  var v = window.story.state.vars;
  return v.day.toString().concat(". day");
}; //forward time to until (1025 = 10:25), regenerate player
//warning dont write 0700 because this would be take as octal number


window.gm.sleep = function (until) {
  var v = window.story.state.vars;
  var msg = '';
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var m2 = until % 100;
  var h2 = (until - m) / 100;
  var min = (h2 - h) * 60 + (m2 - m); //if now is 8:00 and until 10:00 we assume you want to sleep 2h and not 2+24h
  //if now is 10:00 and until is 9:00 we assume sleep for 23h

  if (until < v.time) {
    min = 24 * 60 - (h - h2) * 60 + (m - m2);
  }

  msg += "</br>Slept for " + min / 60 + " hours.</br>";
  window.gm.addTime(min);
  var regen = min > 420 ? 999 : min / 60 * 15; //todo scaling of regeneration

  window.gm.player.Stats.increment('health', regen);
  window.gm.player.Stats.increment('energy', regen);
  window.gm.pushLog(msg);
  return msg;
}; //Todo


window.gm.rollExplore = function () {
  var s = window.story.state;
  var places = []; //todo:depending of your actual location you have a chance to find connected locations or end up in a known one

  if (s.player.location == 'Park') places = ['Mall', 'Beach'];
  if (s.player.location == 'Mall') places = ['Park', 'Beach', 'Downtown'];
  if (s.player.location == 'Beach') places = ['Park', 'Mall'];
  if (places.length == 0) places = ['Park']; //fallback if unspeced location

  var r = _.random(1, places.length) - 1; //chances are equal

  window.gm.addTime(20);
  window.story.show(places[r]);
}; //---------------------------------------------------------------------------------
//TODO Deferred Event is incomplete
//maybe you sometimes dont want to trigger an event immediatly, 
//f.e. if you send a email, it might take some time until you get a response-email 
//(you can receive email at anytime on your phone, so we would have to add checks on ALL passages)
//use this function to push a passage to a stack of deffered events; 
//the passage will trigger under the given condition: minimum time, location-tag, at a certain time-window
//the passage will show when a new passage is requested and will be removed from stack
//if this passage is already pushed, only its condition will be updated


window.gm.pushDefferedEvent = function (id) {
  var cond = {
    waitTime: 6,
    locationTags: ['Home', 'City'],
    //Never trigger in Combat
    dayTime: [1100, 600]
  },
      cond2 = {
    waitTime: 60,
    locationTags: ['Letterbox']
  };
  var xcond = [cond, cond1]; //passage is executed if any of the conds is met
}; //when show is called the previous passage is stored if the new has [back]-tag
//if the new has no back-tag, the stack gets cleared


window.gm.pushPassage = function (id) {
  if (!window.story.state.hasOwnProperty("vars")) return; //vars exist only after initGame

  if (window.story.state.vars.passageStack.length > 0 && window.story.state.vars.passageStack[window.story.state.vars.passageStack.length - 1] === id) {//already pushed
  } else {
    window.story.state.vars.passageStack.push(id);
  }
}; //call on [back]-passages to get the previous passage


window.gm.popPassage = function () {
  var pass = window.story.state.vars.passageStack.pop();
  if (!pass) return 'nothing to pop from stack';
  return pass;
}; //overriding show:
//- to enable back-link
//- to intercept with deffered events


var _origStoryShow = window.story.__proto__.show;

window.story.__proto__.show = function (idOrName) {
  var noHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var next = idOrName;

  if (idOrName === '_back') {
    //going back
    next = window.gm.popPassage();
  } else {
    //going forward
    var tagsnext = window.story.passage(next).tags;
    var namenext = window.story.passage(next).name;

    if (tagsnext.indexOf('back') >= 0) {
      //push on stack but only if not re-showing itself
      if (namenext != window.passage.name) window.gm.pushPassage(window.passage.name);
    } else if (window.story.state.hasOwnProperty("vars")) {
      window.story.state.vars.passageStack.splice(0, window.story.state.vars.passageStack.length);
    }
  } //Todo
  //before entering a new passage check if there is a defferedEvent that we should do first
  //if so, push the normal-passage onto stack, show deffered passage
  //after the deffered passage(s) finish, make sure to show the original passage
  //this is a problem?how do I know the deffered passage is done? 


  _origStoryShow.call(window.story, next, noHistory);
}; //---------------------------------------------------------------------------------


"use strict";
/* bundles some utility operations*/


window.gm = window.gm || {};

window.gm.refreshScreen = function () {
  window.story.show(window.passage.name);
};

window.gm.pushLog = function (msg) {
  var log = window.story.state.vars.log;
  log.unshift(msg);

  if (log.length > 10) {
    log.splice(log.length - 1, 1);
  }
};

window.gm.getLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  return msg;
};

window.gm.clearLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  window.story.state.vars.log = [];
  return msg;
};

window.gm.roll = function (n, sides) {
  //rolls n x dies with sides
  var rnd = 0;

  for (var i = 0; i < n; i++) {
    rnd += _.random(1, sides);
  }

  return rnd;
};

window.gm.printOutput = function (text) {
  document.querySelector("section article div output").innerHTML = text;
}; //prints the same kind of link like [[Next]] but can be called from code


window.gm.printPassageLink = function (label, target) {
  return "<a href=\"javascript:void(0)\" data-passage=\"" + target + "\">" + label + "</a></br>";
}; //prints a link that when clicked picksup an item and places it in the inventory, if itemleft is <0, no link appears


window.gm.printPickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var elmt = '';
  var s = window.story.state;
  if (!(itemleft > 0)) return elmt;
  var desc2 = desc + " (" + itemleft + " left)";
  var msg = 'took ' + itemid;
  elmt += "<a0 id='" + itemid + "' onclick='(function($event){window.gm.pickupAndClear(\"" + itemid + "\", \"" + desc + "\"," + itemleft + "," + cbAfterPickup + ")})(this);'>" + desc2 + "</a></br>";
  return elmt;
};

window.gm.pickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  window.gm.player.Inv.addItem(itemid);
  window.gm.pushLog("added " + itemid + " to inventory.</br>");
  if (cbAfterPickup) cbAfterPickup.call();
  window.story.show(window.passage.name);
}; //prints an item with description; used in inventory


window.gm.printItem = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  var _inv = window.gm.player.Inv;

  var _count = _inv.countItem(id);

  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, " (x").concat(_count, ")</a>");

  if (_count > 0 && _inv.usable(id).OK) {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Inv.use(\"").concat(id, "\"); window.gm.refreshScreen();}(this))'>Use</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints an equipment with description; used in wardrobe


window.gm.printEquipment = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, "</a>");

  if (window.gm.player.Outfit.countItem(id) <= 0) {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.addItem(\"").concat(id, "\"); window.gm.refreshScreen();}(this))'>Equip</a>");
  } else {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.removeItem(\"").concat(id, "\"); window.gm.refreshScreen();}(this))'>Unequip</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints a string listing equipped items


window.gm.printEquipmentSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];

  for (var i = 0; i < window.gm.player.Outfit.count(); i++) {
    var id = window.gm.player.Outfit.getItemId(i);

    if (id != '' && ids.indexOf(id) < 0) {
      ids.push(id);
      result += id + ',';
    }
  }

  return result;
}; //prints a string listing equipped items


window.gm.printRelationSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';

  for (var k = 0; k < window.gm.player.Rel.count(); k++) {
    var data = window.gm.player.Rel.get(window.gm.player.Rel.getItemId(k));
    result += '<tr><td>' + data.id + ':</td><td>' + data.value + '</td></tr>';
  }

  result += '</table>';
  return result;
}; //prints a string listing equipped items


window.gm.printEffectSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';

  for (var k = 0; k < window.gm.player.Stats.count(); k++) {
    var data = window.gm.player.Stats.get(window.gm.player.Stats.getItemId(k));
    result += '<tr><td>' + data.id + ':</td><td>' + data.value + '</td></tr>';
  }

  result += '</table>';
  result += '</br>Active Effects:<table>';

  for (var i = 0; i < window.gm.player.Effects.count(); i++) {
    var data = window.gm.player.Effects.getData(i);
    result += '<tr><td>' + data.id + ':</td><td>' + data.name + '</td></tr>';
  }

  result += '</table>';
  return result;
}; //prints a list of todo quest


window.gm.printTodoList = function () {
  var elmt = '<form><ul style=\"list-style-type: none\" >';
  var s = window.story.state;
  var list = ['qDogSit'];
  elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>always: keep the fridge filled</label></li>";

  for (var i = 0; i < list.length; i++) {
    var val = s.vars[list[i]];
    var msg = '';

    if (list[i] === 'qDogSit') {
      //todo we could use <%=> instead
      if (val <= 0) {} else if (val <= 0x100) {
        msg = 'There was this dogsit-ad in the park. Maybe you should call there to earn some money.';
      } else if (val <= 0x200) {
        msg = 'You called dogsit but didnt get a response...';
      } else if (val <= 0x300) {
        msg = 'Get a task from dogsit!';
      }
    }

    if (msg != '') elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>" + msg + "</label></li>";
  }

  elmt += "</ul></form></br>";
  return elmt;
}; //prints a list of perks for unlock


window.gm.printUnlockPerk = function (id, descr) {
  var elmt = '';
  var s = window.story.state;

  if (s.player[id] == 0 && s.player.skillPoints > 0) {
    elmt += ''.concat("<a0 id='" + id + "' onclick='(function ( $event ) { unlockPerk($event.id); })(this);'>" + descr + "</a>");
    elmt += ''.concat("    [[Info|" + id + "]]");
  } else if (s.player[id] > 0) {
    elmt += id + ": " + descr;
  }

  elmt += ''.concat("</br>");
  return elmt;
}; ///show/hides a dialog defined in body


window.gm.toggleDialog = function (id) {
  var _id = id;
  var dialog = document.querySelector(id),
      closebutton = document.getElementById('close-dialog'),
      pagebackground = document.querySelector('body');
  var div;

  if (!dialog.hasAttribute('open')) {
    // show the dialog 
    div = document.createElement('div');
    div.id = 'backdrop';
    document.body.appendChild(div);
    dialog.setAttribute('open', 'open'); // after displaying the dialog, focus the closebutton inside it

    closebutton.focus();
    closebutton.addEventListener('click', function () {
      window.gm.toggleDialog(_id);
    });
  } else {
    dialog.removeAttribute('open');
    div = document.querySelector('#backdrop');
    div.parentNode.removeChild(div); //??lastFocus.focus();
  }
};

"use strict"; //import {Item} from './Inventory.js';

/* class definiton of items & Equipment */


var Item = /*#__PURE__*/function () {
  function Item(name) {
    _classCallCheck(this, Item);

    this.name = name;
    this.desc = '';
  }

  _createClass(Item, [{
    key: "usable",
    value: function usable(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }]);

  return Item;
}();

function defaultCanUse(context) {
  return {
    OK: true,
    msg: 'usable'
  };
}

function defaultNoUse(context) {
  return {
    OK: false,
    msg: ''
  };
}

function defaultOnUse(context) {
  return {
    OK: true,
    msg: 'You used the item.'
  };
}

function defaultCanUnequip(context) {
  return {
    OK: true,
    msg: ''
  };
}

function defaultNoUnequip(context) {
  return {
    OK: false,
    msg: 'You need to find a key first to be able to remove it!'
  };
}

var LighterDad = /*#__PURE__*/function (_Item) {
  _inherits(LighterDad, _Item);

  var _super = _createSuper(LighterDad);

  function LighterDad() {
    var _this;

    _classCallCheck(this, LighterDad);

    _this = _super.call(this, 'Lighter from Dad');
    _this.desc = 'I got this lighter from my real dad.';
    return _this;
  }

  return LighterDad;
}(Item);

;

var LaptopPS = /*#__PURE__*/function (_Item2) {
  _inherits(LaptopPS, _Item2);

  var _super2 = _createSuper(LaptopPS);

  function LaptopPS() {
    var _this2;

    _classCallCheck(this, LaptopPS);

    _this2 = _super2.call(this, 'Laptop-PS');
    _this2.desc = 'Power converter for laptop.';
    return _this2;
  }

  return LaptopPS;
}(Item);

;

var CanOfCoffee = /*#__PURE__*/function (_Item3) {
  _inherits(CanOfCoffee, _Item3);

  var _super3 = _createSuper(CanOfCoffee);

  function CanOfCoffee() {
    var _this3;

    _classCallCheck(this, CanOfCoffee);

    _this3 = _super3.call(this, 'Can of coffee');
    _this3.desc = 'Cold coffee in a can. Tasty? Not really!';
    return _this3;
  }

  _createClass(CanOfCoffee, [{
    key: "usable",
    value: function usable(context) {
      return {
        OK: true,
        msg: 'drinkable'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      if (context instanceof Inventory) {
        context.removeItem('CanOfCoffee');

        if (context.parent instanceof Character) {
          context.parent.addEffect('CanOfCoffee:Energized', window.gm.EffectLib.Energized); //apply over-time-effect instead directly changing stat

          return {
            OK: true,
            msg: context.parent.name + ' gulped down a can of iced coffee.'
          };
        }
      }
    }
  }]);

  return CanOfCoffee;
}(Item);

;

var SimpleFood = /*#__PURE__*/function (_Item4) {
  _inherits(SimpleFood, _Item4);

  var _super4 = _createSuper(SimpleFood);

  function SimpleFood() {
    var _this4;

    _classCallCheck(this, SimpleFood);

    _this4 = _super4.call(this, 'Simple food');
    _this4.desc = 'Something to eat.';
    return _this4;
  }

  _createClass(SimpleFood, [{
    key: "usable",
    value: function usable(context) {
      return {
        OK: true,
        msg: 'eatable'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      if (context instanceof Inventory) {
        context.removeItem('Simple food');

        if (context.parent instanceof Character) {
          context.parent.addEffect('Simple food:Energized', window.gm.EffectLib.Energized);
          return {
            OK: true,
            msg: context.parent.name + ' ate some plan foods.'
          };
        }
      }
    }
  }]);

  return SimpleFood;
}(Item);

"use strict";
/* a class to provide methods to work with PC & NPC
*/


var Character = /*#__PURE__*/function () {
  _createClass(Character, null, [{
    key: "defaultData",
    value: function defaultData() {
      return {
        name: '',
        location: "Home",
        inv: [],
        //inventory data, needs to be mapped to Inventory-Instance
        wardrobe: [],
        //separate wardobe data, needs to be mapped to outfit-Instance
        outfit: [],
        // needs to be mapped to outfit-Instance
        stats: [],
        effects: [],
        rel: [],
        money: 0
      };
    }
  }]);

  function Character(externlist) {
    _classCallCheck(this, Character);

    this._data = externlist ? externlist : Character.defaultData();
    this.Outfit = new Outfit(this, this._data.outfit);
    this.Inv = new Inventory(this, this._data.inv);
    this.Wardrobe = new Inventory(this, this._data.wardrobe);
    this.Stats = new StatsDictionary(this, this._data.stats);
    this.Effects = new Effects(this, this._data.effects);
    this.Rel = new StatsDictionary(this, this._data.rel); //Todo Relation similiar to stats?
    //create basic stats

    stHealth.setup(this.Stats, 50, 60), stEnergy.setup(this.Stats, 30, 100), stPAttack.setup(this.Stats, 4, 100), stPDefense.setup(this.Stats, 4, 100), stAgility.setup(this.Stats, 3, 100), stStrength.setup(this.Stats, 3, 100), stEndurance.setup(this.Stats, 3, 100);
    this.Effects.addItem('Tired', window.gm.EffectLib.NotTired); //depending on sleep Tired will be set to NotTired or Tired
  }

  _createClass(Character, [{
    key: "health",
    value: function health() {
      return {
        value: this.Stats.get('health').value,
        max: this.Stats.get('healthMax').value,
        min: 0
      };
    }
  }, {
    key: "energy",
    value: function energy() {
      return {
        value: this.Stats.get('energy').value,
        max: this.Stats.get('energyMax').value,
        min: 0
      };
    }
  }, {
    key: "addEffect",
    value: function addEffect(id, effect) {
      this.Effects.addItem(id, effect); // CanOfCoffee:Energyzed,Energyzed
    }
    /*gainStat(id,val) {
        var _x = this.Stats.get(id);
        var old = _x.value; 
        var _new = Math.max(_x.min,Math.min(_x.max,old+val));
        _x.value = _new;
        if(_new-old>=0) {
            window.gm.pushLog('<statup>'+id+" regenerated by "+(_new-old).toString()+"</statup></br>");
        } else {
            window.gm.pushLog('<statdown>'+id+" decreased by "+(_new-old).toString()+"</statdown></br>");
        }
    }*/

  }, {
    key: "gainRelation",
    value: function gainRelation(char, val) {
      this.Rel.addItem(char);

      var _x = this.Rel.get(char);

      var old = _x.value;

      var _new = old + val; //Math.max(_x.min,Math.min(_x.max,old+val));


      _x.value = _new;
      var diff = _new - old;

      if (diff > 0) {
        window.gm.pushLog('<statup>Your relation to ' + char + " improved by " + diff.toString() + "</statup></br>");
      } else if (diff < 0) {
        window.gm.pushLog('<statdown>Your relation to ' + char + " worsend by " + diff.toString() + "</statdown></br>");
      } else {
        window.gm.pushLog('Your relation to ' + char + " wasnt affected at all by your behaviour.</br>");
      }
    }
  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
  }]);

  return Character;
}();

exports.Character = Character;
"use strict";

var Inventory = /*#__PURE__*/function () {
  function Inventory(owner, externlist) {
    _classCallCheck(this, Inventory);

    this.parent = owner;
    this.list = externlist ? externlist : [];
  }

  _createClass(Inventory, [{
    key: "postItemChange",
    value: function postItemChange(inv, id, operation, msg) {
      window.gm.pushLog('Inventory: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }, {
    key: "count",
    value: function count() {
      return this.list.length;
    }
  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return 0;
      return this.list[_i].count;
    }
  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) return i;
      }

      return -1;
    }
  }, {
    key: "getItemId",
    value: function getItemId(slot) {
      return this.list[slot].id;
    }
  }, {
    key: "getItem",
    value: function getItem(id) {
      var _item = window.gm.ItemsLib[id];
      if (!_item) throw new Error('unknown item: ' + id);
      return window.gm.ItemsLib[id];
    }
  }, {
    key: "addItem",
    value: function addItem(id) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(id);

      if (_i < 0) this.list.push({
        'id': id,
        'count': count
      });else this.list[_i].count += count;
      this.postItemChange(this, id, "added", "");
    }
  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      this.list[_i].count -= count;
      if (this.list[_i].count < 1) this.list.splice(_i, 1);
      this.postItemChange(this, id, "removed", "");
    } //convience method to check if item is usable

  }, {
    key: "usable",
    value: function usable(id) {
      var _item = this.getItem(id);

      return _item.usable(this);
    } //uses an item by calling item.use

  }, {
    key: "use",
    value: function use(id) {
      var _item = this.getItem(id);

      var result = _item.use(this);

      if (result.OK) {
        this.postItemChange(this, id, "used", result.msg);
      }

      return result;
    }
  }]);

  return Inventory;
}();

"use strict";
/* a player has an outfit describing which Equipment (wardrobe,utilities,..) he has equiped
*/
//this is a lookuptable for the equipmentslots


window.gm.OutfitSlotpLib = {
  Legs: 1,
  Feet: 2,
  Arms: 3,
  Torso: 4,
  LHand: 5,
  RHand: 6,
  UWTop: 7,
  UWGroin: 8,
  UWFeet: 9,
  UWLegs: 10,
  Hat: 11,
  Neck: 12,
  Eys: 13,
  //insert more slots here
  SLOTMAX: 50
};

var Equipment
/*extends Item*/
= /*#__PURE__*/function () {
  function Equipment(name) {
    _classCallCheck(this, Equipment);

    this.name = name;
    this.desc = name;
    this.tags = [];
    this.slotUse = [];
  } //for compatibility with item


  _createClass(Equipment, [{
    key: "usable",
    value: function usable(context) {
      return {
        OK: false,
        msg: 'Useable in wardrobe'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip(context) {
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip(context) {
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }]);

  return Equipment;
}();

exports.Equipment = Equipment;

var Leggings = /*#__PURE__*/function (_Equipment) {
  _inherits(Leggings, _Equipment);

  var _super5 = _createSuper(Leggings);

  function Leggings() {
    var _this5;

    _classCallCheck(this, Leggings);

    _this5 = _super5.call(this, 'Leggings');
    _this5.tags = ['cloth'];
    _this5.slotUse = ['Legs'];
    _this5.desc = 'Spandex-leggings for sport. (agility+)';
    return _this5;
  }

  _createClass(Leggings, [{
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip(context) {
      context.parent.Stats.addModifier('agility', {
        id: 'agility:Leggings',
        bonus: 5
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip(context) {
      context.parent.Stats.removeModifier('agility', {
        id: 'agility:Leggings'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }]);

  return Leggings;
}(Equipment);

exports.Leggings = Leggings;

var Jeans = /*#__PURE__*/function (_Equipment2) {
  _inherits(Jeans, _Equipment2);

  var _super6 = _createSuper(Jeans);

  function Jeans() {
    var _this6;

    _classCallCheck(this, Jeans);

    _this6 = _super6.call(this, 'Jeans');
    _this6.tags = ['cloth'];
    _this6.slotUse = ['Legs'];
    return _this6;
  }

  _createClass(Jeans, [{
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }]);

  return Jeans;
}(Equipment);

exports.Jeans = Jeans;

var TankShirt = /*#__PURE__*/function (_Equipment3) {
  _inherits(TankShirt, _Equipment3);

  var _super7 = _createSuper(TankShirt);

  function TankShirt() {
    var _this7;

    _classCallCheck(this, TankShirt);

    _this7 = _super7.call(this, 'Tank-shirt');
    _this7.tags = ['cloth'];
    _this7.slotUse = ['Torso'];
    return _this7;
  }

  _createClass(TankShirt, [{
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }]);

  return TankShirt;
}(Equipment);

exports.TankShirt = TankShirt;

var Pullover = /*#__PURE__*/function (_Equipment4) {
  _inherits(Pullover, _Equipment4);

  var _super8 = _createSuper(Pullover);

  function Pullover() {
    var _this8;

    _classCallCheck(this, Pullover);

    _this8 = _super8.call(this, 'Pullover');
    _this8.tags = ['cloth'];
    _this8.slotUse = ['Torso', 'Arms'];
    return _this8;
  }

  _createClass(Pullover, [{
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }]);

  return Pullover;
}(Equipment);

exports.Pullover = Pullover;

var Crowbar = /*#__PURE__*/function (_Equipment5) {
  _inherits(Crowbar, _Equipment5);

  var _super9 = _createSuper(Crowbar);

  function Crowbar() {
    var _this9;

    _classCallCheck(this, Crowbar);

    _this9 = _super9.call(this, 'Crowbar');
    _this9.desc = 'A durable crowbar.';
    _this9.tags = ['tool', 'weapon'];
    _this9.slotUse = ['RHand'];
    return _this9;
  }

  _createClass(Crowbar, [{
    key: "usable",
    value: function usable(context) {
      return this.canEquip(context);
    }
  }, {
    key: "use",
    value: function use(context) {
      //context her is inventory not outfit
      if (context.parent.Outfit.findItemSlot(this.name).length > 0) {
        context.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: ''
        }; //todo
      } else {
        context.parent.Outfit.addItem(this.name);
        return {
          OK: true,
          msg: ''
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip(context) {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip(context) {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip(context) {
      context.parent.Stats.addModifier('pAttack', {
        id: 'pAttack:Crowbar',
        bonus: 2
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip(context) {
      context.parent.Stats.removeModifier('pAttack', {
        id: 'pAttack:Crowbar'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }]);

  return Crowbar;
}(Equipment); //a kind of special inventory for worn equipment


exports.Crowbar = Crowbar;

var Outfit = /*#__PURE__*/function () {
  function Outfit(owner, externlist) {
    _classCallCheck(this, Outfit);

    this.parent = owner;
    this.list = externlist ? externlist : []; //create each slot

    for (var i = 0; i < window.gm.OutfitSlotpLib.SLOTMAX; i++) {
      if (this.list.length - 1 < i) {
        this.list.push({
          id: ''
        }); // {id:'Leggings'}
      }
    }
  }

  _createClass(Outfit, [{
    key: "postItemChange",
    value: function postItemChange(inv, id, operation, msg) {
      window.gm.pushLog('Outfit: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }, {
    key: "count",
    value: function count() {
      return this.list.length;
    }
  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      return _i.length;
    } //detect which slots are used by a item

  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      var _idx = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) _idx.push(i);
      }

      return _idx;
    }
  }, {
    key: "getItemId",
    value: function getItemId(slot) {
      return this.list[slot].id;
    }
  }, {
    key: "getItem",
    value: function getItem(id) {
      var _item = window.gm.ItemsLib[id]; //EquipLib[id];

      if (!_item) throw new Error('unknown item: ' + id);
      return _item;
    }
  }, {
    key: "canEquipSlot",
    value: function canEquipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipSlot",
    value: function canUnequipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipItem",
    value: function canUnequipItem(id, force) {
      var _idx = this.findItemSlot(id);

      var _item = this.getItem(id);

      var result = _item.canUnequip(id);

      for (var i = 0; i < _idx.length; i++) {
        var _tmp = this.canUnequipSlot(_idx[i]);

        if (!_tmp.OK) result.msg += _tmp.msg + " ";
        result.OK = result.OK && _tmp.OK;
      }

      return result;
    }
  }, {
    key: "addItem",
    value: function addItem(id, force) {
      var _idx = this.findItemSlot(id);

      if (_idx.length > 0) return; //already equipped

      var _item = this.getItem(id);

      _idx = _item.slotUse.map(function (cv, ix, arr) {
        return window.gm.OutfitSlotpLib[cv];
      });
      var _oldIDs = [];
      var _oldSlots = [];
      var result = {
        OK: true,
        msg: ''
      };

      for (var l = 0; l < _idx.length; l++) {
        //check if the current equip can be unequipped
        var oldId = this.getItemId(_idx[l]);
        if (oldId === '') continue;

        if (_oldIDs.indexOf(oldId) < 0) {
          _oldIDs.push(oldId);

          _oldSlots = _oldSlots.concat(this.getItem(oldId).slotUse.map(function (cv, ix, arr) {
            return window.gm.OutfitSlotpLib[cv];
          }));
        }

        var _tmp = this.canUnequipItem(oldId);

        if (!_tmp.OK) result.msg += _tmp.msg; //todo duplicated msg if item uses multiple slots

        result.OK = result.OK && _tmp.OK; //Todo  check if slot is available fo equip this canEquipSlot(_idx[l])
      }

      if (!result.OK) {
        this.postItemChange(this, id, "equip_fail:", result.msg);
        return;
      }

      for (var i = 0; i < _oldSlots.length; i++) {
        this.__clearSlot(_oldSlots[i]);
      }

      for (var m = 0; m < _oldIDs.length; m++) {
        this.getItem(_oldIDs[m]).onUnequip(this);
      }

      for (var k = 0; k < _idx.length; k++) {
        this.list[_idx[k]].id = id;
      }

      result = _item.onEquip(this);
      this.postItemChange(this, id, "equipped", result.msg);
    } //assumme that it was checked before that unequip is allowed

  }, {
    key: "__clearSlot",
    value: function __clearSlot(slot, force) {
      this.list[slot].id = '';
    }
  }, {
    key: "removeItem",
    value: function removeItem(id, force) {
      var _idx = this.findItemSlot(id);

      if (_idx.length === 0) return; //already unequipped

      var result = this.canUnequipItem(id);

      if (!result.OK) {
        this.postItemChange(this, id, "unequip_fail", result.msg);
        return;
      }

      result = this.getItem(id).onUnequip(this);

      for (var i = 0; i < _idx.length; i++) {
        this.__clearSlot(_idx[i]);
      }

      this.postItemChange(this, id, "removed", result.msg);
    }
  }, {
    key: "isNaked",
    value: function isNaked() {
      if (this.getItemId(window.gm.OutfitSlotpLib.Legs) === '' || this.getItemId(window.gm.OutfitSlotpLib.Torso) === '') {
        return true;
      }

      return false;
    }
  }]);

  return Outfit;
}();

exports.Outfit = Outfit;
"use strict"; //operations for save/reload


window.storage = {
  ok: function ok() {
    try {
      var storage = window["localStorage"],
          x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && ( // everything except Firefox
      e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' || // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  },
  delete: function _delete(slot) {
    window.localStorage.removeItem(slot);
    window.localStorage.removeItem(slot.concat('info'));
  },
  getSaveInfo: function getSaveInfo(slot) {
    var info = null;

    if (window.storage.ok()) {
      info = window.localStorage.getItem(slot.concat('info'));
    }

    if (!info) {
      return '';
    }

    return info;
  },
  compressLocalSave: false,
  loadFile: function loadFile(input) {
    var file = input.files[0];
    var fileReader = new FileReader();

    fileReader.onload = function () {
      window.storage.rebuildFromSave(fileReader.result, compressLocalSave);
      div = document.querySelector('#backdrop'); //todo promise

      div.parentNode.removeChild(div);
    };

    fileReader.onerror = function () {
      alert(fileReader.error);
    };

    fileReader.readAsText(file);
    return true; //todo how to make async
  },
  saveFile: function saveFile() {
    var hash = JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    });
    if (compressLocalSave) hash = LZString.compressToBase64(hash);
    var filename = window.story.name + "_Save.dat";
    var blob = new Blob([hash], {
      type: "text/plain;charset=utf-8"
    });
    saveAs(blob, filename);
  },
  saveBrowser: function saveBrowser(slot) {
    //var hash= window.story.save();    this call somehow messes up html and I had to copy the following from snowman script
    var hash = LZString.compressToBase64(JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    }));
    var info = window.story.state.player.location + ' - ' + new Date().toString();
    window.localStorage.setItem(slot.concat('info'), info);
    window.localStorage.setItem(slot, hash); //document.querySelector("output").textContent = info;  //causes problems because page reset to start-Index.html??

    return info;
  },
  loadBrowser: function loadBrowser(slot) {
    var hash, info;

    if (window.storage.ok()) {
      //not possible to save object {info,hash} ??
      hash = window.localStorage.getItem(slot);
      info = window.storage.getSaveInfo(slot);
      window.storage.rebuildFromSave(hash, true);
    }

    return info;
  },
  rebuildFromSave: function rebuildFromSave(hash, compressed) {
    if (!compressed) hash = LZString.compressToBase64(hash);
    window.story.restore(hash);
    window.gm.rebuildObjects();
    window.gm.refreshScreen();
  }
};
"use strict";
/* classes to affect...: 
    - the state of a character like     'tired'
    - stats of a character like healthMax
    - 
 */
///////////////////////////////////////////////////////////////


var StatsDictionary = /*#__PURE__*/function (_Inventory) {
  _inherits(StatsDictionary, _Inventory);

  var _super10 = _createSuper(StatsDictionary);

  //Todo a collection of Stats is similiar to Inventory?
  function StatsDictionary(owner, externlist) {
    _classCallCheck(this, StatsDictionary);

    return _super10.call(this, owner, externlist);
  }

  _createClass(StatsDictionary, [{
    key: "get",
    value: function get(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) throw new Error('unknown stat: ' + id);
      /*var _item=this.getItem(id);
      _item.Calc(this);*/

      return this.list[_i];
    }
  }, {
    key: "getRaw",
    value: function getRaw(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) throw new Error('unknown stat: ' + id);
      return this.list[_i];
    } // adds a modifier to a Stat or replaces it

  }, {
    key: "addModifier",
    value: function addModifier(toId, modData) {
      var _oldMods = this.getRaw(toId).modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);

      _oldMods.push(modData);

      window.gm.pushLog(Stat.Calc(this, toId).msg);
    }
  }, {
    key: "removeModifier",
    value: function removeModifier(toId, modData) {
      var _oldMods = this.getRaw(toId).modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);
      window.gm.pushLog(Stat.Calc(this, toId).msg);
    } //override

  }, {
    key: "getItem",
    value: function getItem(id) {
      var _item = window.gm.StatsLib[id];
      if (!_item) throw new Error('unknown stat: ' + id);
      return window.gm.StatsLib[id];
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(inv, id, operation, msg) {
      window.gm.pushLog('Stats: ' + operation + ' ' + id + ' ' + msg + '</br>');
    } //override; only use to create new stats !

  }, {
    key: "addItem",
    value: function addItem(id) {
      var _i = this.findItemSlot(id);

      var _n = Stat.dataPrototype();

      _n.id = id;
      if (_i < 0) this.list.push(_n);
    } //override

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      this.list.splice(_i, 1);
    }
  }, {
    key: "increment",
    value: function increment(id, value) {
      var attr = this.getRaw(id);
      attr.base += value;
      window.gm.pushLog(Stat.Calc(this, id).msg);
    }
  }]);

  return StatsDictionary;
}(Inventory); //class for an Attribute


exports.StatsDictionary = StatsDictionary;

var Stat = /*#__PURE__*/function () {
  function Stat() {
    _classCallCheck(this, Stat);
  }

  _createClass(Stat, null, [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: '',
        base: 0,
        value: 0,
        limits: [],
        modifier: [],
        modifys: []
      }; //limit = {id: min: max:}   limit to apply to value and base
      //modifier {id: calc:}      Stat that modifys value, calc is function(context,data)=> newvalue
      //modifys {id:}         point to the Stats that have modifiers from this stat
    } //this is called to update value of the stat and will trigger calculation of dependend stats 

  }, {
    key: "Calc",
    value: function Calc(context, id) {
      var attr = context.getRaw(id);
      var min = -99999;
      var max = 99999;
      var msg = ''; //get limits

      for (var k = 0; k < attr.limits.length; k++) {
        if (attr.limits[k].min !== '') min = Math.max(context.getRaw(attr.limits[k].min).value, min); //this might behave odly if any min>max

        if (attr.limits[k].max !== '') max = Math.min(context.getRaw(attr.limits[k].max).value, max);
      } //recalculate modifiers


      var _old = attr.value;
      attr.base = attr.value = Math.max(min, Math.min(max, attr.base));

      for (var i = 0; i < attr.modifier.length; i++) {
        attr.value += attr.modifier[i].bonus; //window.gm.StatsLib[attr.modifier[i].id].modify(context,attr); 
      }

      var _new = Math.max(min, Math.min(max, attr.value));

      attr.value = _new;

      if (_new - _old > 0) {
        msg += '<statup>' + id + " regenerated by " + (_new - _old).toString() + "</statup></br>";
      } else if (_new - _old < 0) {
        msg += '<statdown>' + id + " decreased by " + (_new - _old).toString() + "</statdown></br>";
      }

      context.getItem(id).updateModifier(context); //trigger recalculation of dependend Stats

      for (var m = 0; m < attr.modifys.length; m++) {
        msg += Stat.Calc(context, attr.modifys[m].id).msg;
      }

      return {
        OK: true,
        msg: msg
      };
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {}
  }]);

  return Stat;
}();

var stHealth = /*#__PURE__*/function () {
  function stHealth() {
    _classCallCheck(this, stHealth);
  }

  _createClass(stHealth, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'healthMax', _n.base = max, _n.value = max;
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      _n = Stat.dataPrototype();
      _n.id = 'health', _n.base = base, _n.value = base, _n.limits = [{
        max: 'healthMax',
        min: ''
      }];
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stHealth.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'health');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {}
  }]);

  return stHealth;
}();

var stEnergy = /*#__PURE__*/function () {
  function stEnergy() {
    _classCallCheck(this, stEnergy);
  }

  _createClass(stEnergy, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'energyMax', _n.base = max, _n.value = max;
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      _n = Stat.dataPrototype();
      _n.id = 'energy', _n.base = base, _n.value = base, _n.limits = [{
        max: 'energyMax',
        min: ''
      }];
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stEnergy.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'energy');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {}
  }]);

  return stEnergy;
}();

var stAgility = /*#__PURE__*/function () {
  function stAgility() {
    _classCallCheck(this, stAgility);
  }

  _createClass(stAgility, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'agility', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'energyMax'
      }];
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stAgility.Calc(context);
    }
    /*static modify(context, data) {
        var bonus =0;
        if(data.id==='healthMax') {
            bonus = context.get('agility').value;
        }
        return (data.value+bonus);
    }*/

  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'agility');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {
      context.addModifier('energyMax', {
        id: 'agility',
        bonus: context.get('agility').value
      });
    }
  }]);

  return stAgility;
}();

var stStrength = /*#__PURE__*/function () {
  function stStrength() {
    _classCallCheck(this, stStrength);
  }

  _createClass(stStrength, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'strength', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pAttack'
      }];
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stStrength.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'strength');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {
      context.addModifier('healthMax', {
        id: 'strength',
        bonus: context.get('strength').value * 4
      });
      context.addModifier('pAttack', {
        id: 'strength',
        bonus: context.get('strength').value % 4
      });
    }
  }]);

  return stStrength;
}();

var stEndurance = /*#__PURE__*/function () {
  function stEndurance() {
    _classCallCheck(this, stEndurance);
  }

  _createClass(stEndurance, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'endurance', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pDefense'
      }];
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stEndurance.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'endurance');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {
      context.addModifier('healthMax', {
        id: 'endurance',
        bonus: context.get('endurance').value * 4
      });
      context.addModifier('pDefense', {
        id: 'strength',
        bonus: context.get('endurance').value % 4
      });
    }
  }]);

  return stEndurance;
}();

var stPAttack = /*#__PURE__*/function () {
  function stPAttack() {
    _classCallCheck(this, stPAttack);
  }

  _createClass(stPAttack, null, [{
    key: "setup",
    //physical attack
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'pAttack', _n.base = base, _n.value = base;
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stPAttack.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'pAttack');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {}
  }]);

  return stPAttack;
}();

var stPDefense = /*#__PURE__*/function () {
  function stPDefense() {
    _classCallCheck(this, stPDefense);
  }

  _createClass(stPDefense, null, [{
    key: "setup",
    //physical defense
    value: function setup(context, base, max) {
      var _n = Stat.dataPrototype();

      _n.id = 'pDefense', _n.base = base, _n.value = base;
      if (context.findItemSlot(_n.id) < 0) context.list.push(_n);
      stPAttack.Calc(context);
    }
  }, {
    key: "Calc",
    value: function Calc(context) {
      Stat.Calc(context, 'pDefense');
    }
  }, {
    key: "updateModifier",
    value: function updateModifier(context) {}
  }]);

  return stPDefense;
}(); /////////////////////////////////////////////////////////////////////////


var Effects = /*#__PURE__*/function (_Inventory2) {
  _inherits(Effects, _Inventory2);

  var _super11 = _createSuper(Effects);

  //Todo a collection of Stats is similiar to Inventory?
  function Effects(owner, externlist) {
    _classCallCheck(this, Effects);

    return _super11.call(this, owner, externlist);
  } //override


  _createClass(Effects, [{
    key: "getItem",
    value: function getItem(id) {
      var _item = window.gm.EffectLib[id];
      if (!_item) throw new Error('unknown effect: ' + id);
      return window.gm.EffectLib[id];
    }
  }, {
    key: "getData",
    value: function getData(slot) {
      return this.list[slot];
    } //findItemslot uses id, this one finds all effects of one type

  }, {
    key: "findEffect",
    value: function findEffect(name) {
      var _items = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].name === name) _items.push(i);
      }

      return _items;
    }
  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      window.gm.EffectLib[this.list[_i].name].onRemove(this, this.list[_i]);

      this.list.splice(_i, 1);
      this.postItemChange(this, id, "removed", "");
    }
  }, {
    key: "addItem",
    value: function addItem(id, effect) {
      var _i = this.findItemSlot(id);

      var res; //if effect with same id is already present, merge them

      if (_i > -1) {
        res = window.gm.EffectLib[this.list[_i].name].merge(this, this.list[_i], effect, effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(this, id, "merged", "");
          return;
        }
      } //or if there are similiar effects try to erge with them


      var _k = this.findEffect(effect.name);

      for (var i = 0; i < _k.length; i++) {
        res = window.gm.EffectLib[this.list[__k].name].merge(this, this.list[_i], effect, effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(this, id, "merged", "");
          break;
        }
      } //else add it to list


      var data = effect.dataPrototype();
      data.id = id;
      this.list.push(data);
      effect.onApply(this, data);
      this.postItemChange(this, id, "added", "");
    }
  }, {
    key: "replace",
    value: function replace(id, neweffect, newdata) {
      var _i = this.findItemSlot(id);

      window.gm.EffectLib[this.list[_i].name].onRemove(this, this.list[_i]);

      newdata.id = id;
      this.list[_i] = newdata;
      neweffect.onApply(this, newdata);
    }
  }, {
    key: "updateTime",
    value: function updateTime() {
      var now = window.gm.getTime();

      for (var i = 0; i < this.list.length; i++) {
        var foo = window.gm.EffectLib[this.list[i].name].onTimeChange(this, this.list[i], now);
        if (foo) foo(this);
      }
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(inv, id, operation, msg) {
      window.gm.pushLog('Effects: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }]);

  return Effects;
}(Inventory); //! because of the save-problem we dont use objects, just static methods


exports.Effects = Effects;

var Effect = /*#__PURE__*/function () {
  function Effect() {
    _classCallCheck(this, Effect);
  }

  _createClass(Effect, null, [{
    key: "dataPrototype",

    /*constructor(parent,name) {
        this.parent = parent;
        this.name = name;
        this.desc = name;
        this.time = window.gm.getTime();
    }*/
    //static get name() { return('Effect');}
    //static get desc() {return(Effect.name);}
    value: function dataPrototype() {
      return {
        id: 'xxx',
        name: Effect.name,
        ts: 0,
        duration: 0
      };
    } //is called when a effect is applied to check if the new effect can be combined with an exisitng one
    //return null if no merge occured
    //return true if the neweffect was merged into existing one; no other effects are then checked for mergeability
    //or return function that has to be executed: (function(Effects){ Effects.replace(data.id,window.gm.EffectLib.NotTired,newdata);}));

  }, {
    key: "merge",
    value: function merge(context, data, neweffect, newdata) {
      return null;
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(context, data, time) {
      return null;
    }
  }, {
    key: "onApply",
    value: function onApply(context, data) {}
  }, {
    key: "onRemove",
    value: function onRemove(context, data) {}
  }]);

  return Effect;
}();

var effEnergized = /*#__PURE__*/function (_Effect) {
  _inherits(effEnergized, _Effect);

  var _super12 = _createSuper(effEnergized);

  function effEnergized() {
    _classCallCheck(this, effEnergized);

    return _super12.apply(this, arguments);
  }

  _createClass(effEnergized, null, [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: 'Energized',
        name: effEnergized.name,
        time: 0,
        duration: 120
      };
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(context, data, time) {
      //+ 10Energy per hour
      var delta = window.gm.getDeltaTime(time, data.time);
      data.time = time;
      data.duration -= delta;
      if (data.duration < 0) delta = delta + data.duration; // if delta is 20 but remaining duration is only 5, delta should be capped to 5

      context.parent.Stats.increment('energy', 10 * delta / 60);

      if (data.duration <= 0) {
        return function (Effects) {
          Effects.removeItem(data.id);
        };
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply(context, data) {
      //+10 energy
      data.duration = 120;
      data.time = window.gm.getTime();
      context.parent.Stats.increment('energy', 10);
    }
  }, {
    key: "merge",
    value: function merge(context, data, neweffect, newdata) {
      if (neweffect.name === data.name) {
        effEnergized.onApply(context, data);
        return true;
      }
    }
  }, {
    key: "name",

    /*constructor(parent) {
         super(parent,'Energized');
     }*/
    get: function get() {
      return 'Energized';
    }
  }, {
    key: "desc",
    get: function get() {
      return effEnergized.name;
    }
  }]);

  return effEnergized;
}(Effect);

var effNotTired = /*#__PURE__*/function (_Effect2) {
  _inherits(effNotTired, _Effect2);

  var _super13 = _createSuper(effNotTired);

  function effNotTired() {
    _classCallCheck(this, effNotTired);

    return _super13.apply(this, arguments);
  }

  _createClass(effNotTired, null, [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: effNotTired.name,
        name: effNotTired.name,
        time: 0,
        duration: 120
      };
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(context, data, time) {
      //Tired after xxh
      data.duration -= window.gm.getDeltaTime(time, data.time);
      data.time = time;

      if (data.duration <= 0) {
        return function (Effects) {
          var newdata = window.gm.EffectLib.Tired.dataPrototype();
          newdata.id = data.id;
          newdata.time = time;
          Effects.replace(data.id, window.gm.EffectLib.Tired, newdata);
        };
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply(context, data) {
      data.duration = 120; // todo 600;

      data.time = window.gm.getTime();
    }
  }, {
    key: "merge",
    value: function merge(context, data, neweffect, newdata) {
      if (neweffect.name === data.name) {
        neweffect.onApply(context, data);
        return true;
      }
    }
  }, {
    key: "name",

    /*constructor(parent) {
        super(parent,'NotTired');
    }*/
    get: function get() {
      return 'NotTired';
    }
  }, {
    key: "desc",
    get: function get() {
      return effNotTired.name;
    }
  }]);

  return effNotTired;
}(Effect);

var effTired = /*#__PURE__*/function (_Effect3) {
  _inherits(effTired, _Effect3);

  var _super14 = _createSuper(effTired);

  function effTired() {
    _classCallCheck(this, effTired);

    return _super14.apply(this, arguments);
  }

  _createClass(effTired, null, [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: effTired.name,
        name: effTired.name,
        time: 0,
        duration: 120
      };
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(context, data, time) {
      //duration not used -> will never expire unless replaced
      var delta = window.gm.getTime() - data.time; //-10 max energy after 12h, but only up to 3 times

      if (delta > 60) context.parent.Stats.addModifier('energyMax', {
        id: 'energyMax:Tired',
        bonus: -10
      });
    }
  }, {
    key: "onApply",
    value: function onApply(context, data) {
      data.time = window.gm.getTime();
    }
  }, {
    key: "onRemove",
    value: function onRemove(context, data) {
      context.parent.Stats.removeModifier('energyMax', {
        id: 'energyMax:Tired'
      });
    }
  }, {
    key: "merge",
    value: function merge(context, data, neweffect, newdata) {
      if (neweffect.name === 'NotTired') {
        return function (Effects) {
          Effects.replace(data.id, window.gm.EffectLib.NotTired, newdata);
        };
      }

      if (neweffect.name === data.name) {
        //just ignore
        return true;
      }
    }
  }, {
    key: "name",

    /*constructor(parent) {
        super(parent,'Tired');
    }*/
    get: function get() {
      return 'Tired';
    }
  }, {
    key: "desc",
    get: function get() {
      return effTired.name;
    }
  }]);

  return effTired;
}(Effect); //////////////////////////////////////////////////////////////

/*export class BaseAttribute {   
    constructor(id,value, multiplier = 0) {
        this._id =id;
        this._baseValue = value;
        this._baseMultiplier = multiplier;
    }    
    get id(){return(this._id);}
    get baseValue(){ return _baseValue;  }   
    get baseMultiplier(){ return _baseMultiplier; }
}
export class RawBonus extends BaseAttribute   {
    constructor(value = 0, multiplier = 0) {
        super(value, multiplier);
    }
 }
 export class Attribute extends BaseAttribute {     
    constructor(id,startingValue){ //baseMultiplier for simple Attribut is 0
        super(id,startingValue);    
        _rawBbonuses = new Map();
        _finalBonuses = new Map();    
        _finalValue = baseValue;
    }        
    addRawBonus(bonus) {
        _rawBonuses.set(bonus.id ,bonus);
    }        
    addFinalBonus(bonus)  {
        _finalBonuses.set(bonus.id ,bonus);
    }       
    removeRawBonus(bonus)    {
        _rawBonuses.delete(bonus.id);
    }      
    removeFinalBonus(bonus)   {
        _finalBonuses.delete(bonus.id);
    }     
    _applyBonuses(Bonuses)   {
        // Adding value from raw
        var BonusValue = 0;
        var BonusMultiplier = 0;          
        for (let bonus of Bonuses.values()) {  
            BonusValue += bonus.baseValue;
            BonusMultiplier += bonus.baseMultiplier;
        }
        _finalValue += BonusValue;
        _finalValue *= (1 + BonusMultiplier);
    }
    applyRawBonuses() {
        // Adding value from raw
        this._applyBonuses(_rawBonuses);
    }    
    applyFinalBonuses() {
        // Adding value from final
        this._applyBonuses(_finalBonuses);
    }      
    calculateValue()    {
        _finalValue = baseValue;      
        applyRawBonuses();      
        applyFinalBonuses();      
        return _finalValue;
    }    
    finalValue() {
        return calculateValue();
    }
}
 export class DependantAttribute extends Attribute   {       
    constructor(id,startingValue) {
        super(id,startingValue);    
        _otherAttributes = [];
    }
    addAttribute(attr) {
        _otherAttributes.set(attr.id ,attr);
    }   
    removeAttribute(attr) {
        _otherAttributes.delete(attr.id);
    }
    //you need to override calculate and do something with the added attributes
}
class HealthMax extends DependantAttribute {
    constructor(startingValue) {
        super('healthMax',startingValue);
    }
}
class Health extends DependantAttribute {
    constructor(startingValue) {
        super('health',startingValue);
        this.addAttribute()
    }
}
export class AttackStrength extends DependantAttribute  {
    constructor(startingValue) {
        super(startingValue);
    }
        
    calculateValue() {
        _finalValue = baseValue;
        var strength = _otherAttributes.get('strength').calculateValue();
        _finalValue += int(strength / 5);   
        applyRawBonuses();    
        applyFinalBonuses();        
        return _finalValue;
    }
}*/