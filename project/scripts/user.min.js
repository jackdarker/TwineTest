"use strict";
/* a class to provide methods to work with PC & NPC
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Character = void 0;

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Character = /*#__PURE__*/function () {
  _createClass(Character, null, [{
    key: "defaultData",
    value: function defaultData() {
      return {
        name: '',
        location: "Home",
        XP: 0,
        level: 1,
        inv: [],
        //inventory data, needs to be mapped to Inventory-Instance
        wardrobe: [],
        //separate wardobe data, needs to be mapped to outfit-Instance
        outfit: [],
        // needs to be mapped to outfit-Instance
        stats: [],
        effects: [],
        rel: []
      };
    }
  }]);

  function Character(externlist) {
    _classCallCheck(this, Character);

    this._data = externlist ? externlist : Character.defaultData();
    this.Outfit = new Outfit(this._data.outfit);
    this.Outfit._parent = window.gm.util.refToParent(this);
    this.Inv = new Inventory(this._data.inv);
    this.Inv._parent = window.gm.util.refToParent(this);
    this.Wardrobe = new Inventory(this._data.wardrobe);
    this.Wardrobe._parent = window.gm.util.refToParent(this);
    this.Stats = new StatsDictionary(this._data.stats);
    this.Stats._parent = window.gm.util.refToParent(this);
    this.Effects = new Effects(this._data.effects);
    this.Effects._parent = window.gm.util.refToParent(this);
    this.Rel = new StatsDictionary(this._data.rel); //Todo Relation similiar to stats?

    this.Rel._parent = window.gm.util.refToParent(this); //create basic stats

    stHealth.setup(this.Stats, 50, 60), stEnergy.setup(this.Stats, 30, 100), stPAttack.setup(this.Stats, 4, 100), stPDefense.setup(this.Stats, 4, 100), stAgility.setup(this.Stats, 10, 100), stIntelligence.setup(this.Stats, 10, 100), stLuck.setup(this.Stats, 10, 100);
    stCharisma.setup(this.Stats, 10, 100), stPerception.setup(this.Stats, 10, 100), stStrength.setup(this.Stats, 10, 100), stEndurance.setup(this.Stats, 10, 100);
    stPerversion.setup(this.Stats, 1, 15), stArousal.setup(this.Stats, 1, 100);
    this.Effects.addItem(effNotTired.name, new effNotTired()); //depending on sleep Tired will be set to NotTired or Tired

    window.storage.registerConstructor(Character);
  }

  _createClass(Character, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Character", this);
    }
  }, {
    key: "addXP",
    value: function addXP(XP) {
      this._data.XP += XP;
    } //upgrade level by 1;this will increase level even if not enough XP !

  }, {
    key: "levelUp",
    value: function levelUp() {
      var reqXP = Character.calcLevelToXP(this._data.level + 1);
      this._data.XP = reqXP;
      this._data.level += 1;
    }
  }, {
    key: "health",
    value: function health() {
      return {
        value: this.Stats.get('health').value,
        max: this.Stats.get('healthMax').value,
        min: 0
      };
    }
  }, {
    key: "energy",
    value: function energy() {
      return {
        value: this.Stats.get('energy').value,
        max: this.Stats.get('energyMax').value,
        min: 0
      };
    }
  }, {
    key: "addEffect",
    value: function addEffect(id, effect) {
      this.Effects.addItem(id, effect);
    } //helper function to change Relation 

  }, {
    key: "gainRelation",
    value: function gainRelation(char, val) {
      var _idx = this.Rel.findItemSlot(char);

      if (_idx < 0) {
        var _rel = stRelation.setup(this.Rel, val, 100, char);
      } else {
        this.Rel.increment(char, val);
      }
    } //combat related

  }, {
    key: "_canAct",
    value: function _canAct() {
      var result = {
        OK: true,
        msg: ''
      };

      if (this.Effects.findItemSlot("effStunned") >= 0) {
        result.OK = false;
        result.msg = this.name + " is stunned and cannot react.";
        return result;
      }

      return result;
    }
  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    },
    set: function set(name) {
      this._data.name = name;
    }
  }, {
    key: "location",
    get: function get() {
      return this._data.location;
    },
    set: function set(name) {
      this._data.location = name;
    }
  }, {
    key: "level",
    get: function get() {
      return this._data.level;
    }
  }, {
    key: "levelPoints",
    get: function get() {
      //for each attribute('strength','perception','endurance','charisma','intelligence','agility','luck','willpower')
      //we start with 10pts at lvl1 and for each lvl receive 2pts
      return this._data.level - 1 * 2 + 7 * 10;
    }
  }, {
    key: "canLevelUp",
    get: function get() {
      return Character.calcXPToLevel(this._data.XP) !== this._data.level;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Character, value.data);

      _x.Effects._relinkItems();

      _x.Stats._relinkItems();

      _x.Inv._relinkItems();

      _x.Outfit._relinkItems();

      _x.Wardrobe._relinkItems();

      _x.Rel._relinkItems();

      return _x;
    }
  }, {
    key: "calcXPToLevel",
    value: function calcXPToLevel(XP) {
      return Math.abs(Math.SQRT2(XP / 100 + 0.25) - 0.5);
    }
  }, {
    key: "calcLevelToXP",
    value: function calcLevelToXP(lvl) {
      return 100 * lvl * (lvl + 1) / 2; //Gauss-Sum
    }
  }]);

  return Character;
}();

exports.Character = Character;
"use strict";
/* bundles some operations related to combat */


window.gm = window.gm || {};
window.gm.combat = window.gm.combat || {};

var CombatSetup = /*#__PURE__*/function () {
  function CombatSetup() {
    _classCallCheck(this, CombatSetup);

    this.EnemyFirst = false;
    this.EnemyFunc = null; //a ctor of Mob

    this.Location = ''; //your actual location-name

    this.scenePic = ''; //bg-image to use

    this.onDefeat = null;
    this.onVictory = null;
    this.onFlee = null;
    this.onSubmit = null;
  }

  _createClass(CombatSetup, [{
    key: "onSubmit",
    value: function onSubmit() {
      return 'You submitted to ' + s.enemy.name + " completely.</br>" + window.gm.printPassageLink('GameOver', 'GameOver');
    } //setup encounter; this calls the Encounter-passage !

  }, {
    key: "initCombat",
    value: function initCombat() {
      var s = window.story.state;
      s.enemy = window.gm.Encounter.EnemyFunc();
      s.combat.location = window.gm.Encounter.location;
      s.combat.scenePic = window.gm.Encounter.scenePic;
      s.combat.playerFleeing = false;
      s.combat.playerSubmitting = false;
      s.enemyFirst = window.gm.Encounter.EnemyFirst;
      s.combat.enemyTurn = false;
      s.combat.newTurn = true;
      s.combat.turnCount = 0;
      s.combat.state = 'battling';
      window.story.show("Encounter");
    }
  }, {
    key: "hideCombatOption",
    value: function hideCombatOption() {
      document.querySelector("#combatmenu").remove();
    } //creates a list of possible moves for player

  }, {
    key: "printCombatOption",
    value: function printCombatOption() {
      var elmt = "<form id='combatmenu'>"; //Todo create list based on abilitys

      var canAct = window.gm.player._canAct();

      if (canAct.OK === true) {
        elmt += "<a0 id='moveFlee'           onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Try to flee</a></br>";
        elmt += "<a0 id='movePhysicalAttack' onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Attack</a></br>";
        elmt += "<a0 id='moveUltraKill' onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>KillYaAll</a></br>";
        elmt += "<a0 id='moveGuard'          onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Guard</a></br>";
        elmt += "<a0 id='moveStun'           onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Stun</a></br>";
        elmt += "<a0 id='moveSubmit'         onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Submit</a></br>"; //Todo Item-use on self or enemy
        //elmt +="<a0 id='showItems' onclick='(function($event){window.gm.execCombatCmd($event.id);"+next+"})(this);'>Item</a></br>";
      } else {
        elmt += canAct.msg + "</br>";
      }

      elmt += "<a0 id='moveNOP'          onclick='(function($event){window.gm.Encounter.triggerCombat($event.id);})(this);'>Do nothing</a></br>";
      elmt += "</form></br>";
      return elmt;
    } //prints the Stats and Effects of the Player&Enemy

  }, {
    key: "printCombatHud",
    value: function printCombatHud() {
      renderToSelector("#playerstats", "playerstats");
      renderToSelector("#enemystats", "enemystats");
    }
  }, {
    key: "printCombatEffects",
    //creates a list of active effects for combat display
    value: function printCombatEffects(char) {
      var list = [];
      var effects = char.Effects.getAllIds();

      for (var i = 0; i < effects.length; i++) {
        var effect = char.Effects.get(effects[i]);

        if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
          list.push(effect.shortDesc);
        }
      }

      return list.reduce(function (sum, current) {
        return sum + current + ', ';
      }, '');
    }
  }, {
    key: "triggerCombat",
    value: function triggerCombat(id) {
      //called by combatmenu-buttons expects a functioname
      this.hideCombatOption();
      var result = window.gm.Encounter.execCombatCmd(window.gm.combat[id]);
      window.gm.printOutput(result.msg + window.gm.printPassageLink("Next", "EncounterStartTurn"));
      this.printCombatHud();
    } //calculates and executes combat-cmd of enemy

  }, {
    key: "calcEnemyCombat",
    value: function calcEnemyCombat() {
      var enemy = window.story.state.enemy;
      var move = enemy.calcCombatMove();
      return move.msg + "</br>";
    } //executes a combat-cmd for player/enemy

  }, {
    key: "execCombatCmd",
    value: function execCombatCmd(move) {
      var s = window.story.state;
      var result = move();
      s.combat.enemyTurn = !s.combat.enemyTurn; //toggle whos turn

      if (!(s.combat.enemyTurn ^ s.combat.enemyFirst)) s.combat.newTurn = false;
      return result;
    }
  }, {
    key: "startRound",
    value: function startRound() {
      var s = window.story.state;
      s.combat.turnCount += 1; //update combateffects

      var list = [window.story.state.enemy, window.gm.player];

      for (var k = 0; k < list.length; k++) {
        var effects = list[k].Effects.getAllIds();

        for (var i = 0; i < effects.length; i++) {
          var effect = list[k].Effects.get(effects[i]);

          if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
            //typeof effect === CombatEffect doesnt work? so we check presencse of attribut
            effect.onTurnStart();
          }
        }
      }
    }
  }, {
    key: "endCombat",
    value: function endCombat() {
      //remove combateffects
      var list = [window.story.state.enemy, window.gm.player];

      for (var k = 0; k < list.length; k++) {
        var effects = list[k].Effects.getAllIds();

        for (var i = 0; i < effects.length; i++) {
          var effect = list[k].Effects.get(effects[i]);

          if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
            effect.onCombatEnd();
          }
        }
      }
    }
  }, {
    key: "battle",
    //returns false if battle should continue
    value: function battle() {
      var s = window.story.state;
      var result = {
        OK: false,
        msg: ''
      }; //check if battle done...

      if (s.combat.playerFleeing === true) {
        result.OK = true;
        result.msg = 'You sucessfully escaped ' + s.enemy.name + "</br>";
        result.msg += window.gm.printPassageLink('Next', window.gm.player.location);
      }

      if (s.combat.playerSubmitting === true) {
        result.OK = true;
        result.msg = this.onSubmit();
      }

      if (s.enemy.health().value <= 0) {
        result.OK = true;
        s.combat.state = 'victory';
        result.msg = 'You defeated ' + s.enemy.name + "</br>";
        result.msg += window.gm.printPassageLink('Next', window.gm.player.location);
      }

      if (window.gm.player.health().value <= 0) {
        result.OK = true;
        s.combat.state = 'defeat';
        result.msg = 'You where defeated by' + s.enemy.name + "</br>";
        result.msg += window.gm.printPassageLink('GameOver', 'GameOver');
      }

      if (result.OK) {
        this.endCombat();
      } else {
        //or continue combat                
        if (s.combat.newTurn === false && !(s.combat.enemyTurn ^ s.combat.enemyFirst)) {
          s.combat.newTurn = true;
          result.msg += 'new turn</br>';
          window.gm.Encounter.startRound();
        }

        if (s.combat.enemyTurn) {
          result.msg += this.calcEnemyCombat();
          result.msg += window.gm.printPassageLink('Next', 'EncounterStartTurn');
        } else {
          result.msg += this.printCombatOption();
        } //todo how to know endRound

      }

      return result;
    }
  }]);

  return CombatSetup;
}(); //calculates if target can evade the attack 

/*requires minimum Poise
Evasion depends on Agility & Endurance:
- mallus for heavy armor & weapon
- mallus for Effects like Prone, Frozen
- bonus for Skills: Flying, Dancer
Stunned/Bound Chars can not evade */
// on evasion returns false and a message


window.gm.combat.calcEvasion = function (attacker, target, attack) {
  var result = {
    OK: true,
    msg: ''
  };
  var rnd = window.gm.roll(1, 100);

  if (target.Effects.findItemSlot(effStunned.name) >= 0) {
    result.OK = true;
    result.msg = target.name + ' is stunned and cannot evade. ';
    attack.crit = true; //when stunned always critical hit

    return result;
  }

  var lvlDiff = target.level - attacker.level;
  var chance = target.Stats.get("agility").value + target.Stats.get("endurance").value;
  chance += lvlDiff * 4;
  window.gm.pushLog("evasion roll:".concat(chance, " vs ").concat(rnd, " "), window.story.state.vars.dbgShowCombatRoll);

  if (chance > rnd) {
    result.OK = false;
    result.msg += 'Using agility, ' + target.name + ' was able to dodge the attack. ';
  }

  return result;
};
/*If evasion-roll fails, their is a chance that parry is rolled:
- consumes some poise
- parry only works for weapon of similiar size: a Zweihänder is to slow to parry a saber, a dagger is to light to deflect a club
- requires minimum weapon-skill (f.e. projectile deflection )
otherwise continue chain
parry-result depends on agility+perception
- bonus for skills
- bonus for some weapons
on critical fail- full damage, poise damage
on fail - full damage
on success no damage is taken (might consume weapon-stability)
if a critical is rolled, 50% of the attackers damage is reflected to him*/


window.gm.combat.calcParry = function (attacker, target, attack) {
  var result = {
    OK: true,
    msg: '',
    foo: null
  };

  var rnd = _.random(1, 100);

  if (target.Effects.findItemSlot(effStunned.name) >= 0) {
    result.OK = true;
    result.msg = target.name + ' is stunned and cannot parry or block. ';
    attack.crit = true; //when stunned always critical hit

    return result;
  }

  var lvlDiff = target.level - attacker.level;
  var chance = target.Stats.get("agility").value + target.Stats.get("perception").value;
  chance += lvlDiff * 4;
  window.gm.pushLog("parry roll:".concat(chance, " vs ").concat(rnd, " "), window.story.state.vars.dbgShowCombatRoll);

  if (chance > rnd && rnd < 10) {
    result.OK = false;

    if (rnd < 10) {
      result.msg = target.name + ' parried the attack and was even able to land a hit.'; //todo how to add textual variation based on used weapon and skill?
      // foo should reflect fraction of attack back to attacker

      result.foo = function (attacker, attack) {
        return function (attacker, attack) {
          attacker.Stats.increment('health', -0.5 * attack.value);
        };
      }(attacker, attack);
    } else {
      result.msg = target.name + ' parried the attack.';
    }
  } else {
    result.OK = true;

    if (rnd > 90) {
      attack.crit = true;
    }
  }

  return result;
};
/*if all else failed you have to absorb the hit:
DR = sum of armor (with individual skill-bonus) + magic armor
attack = weapon damage formula + weakness-bonus
attack increases on critical
hp-dmg = attack -DR but min.1 */


window.gm.combat.calcAbsorb = function (attacker, defender, attack) {
  var result = {
    OK: true,
    msg: '',
    foo: null
  };

  var rnd = _.random(1, 100);

  var def = defender.Stats.get('pDefense').value; //todo weakness bonus

  var dmg = Math.max(1, attack.value * (attack.crit ? 4 : 1) - def);
  window.gm.pushLog("absorb roll:".concat(dmg, " vs ").concat(def, " "), window.story.state.vars.dbgShowCombatRoll);
  result.msg = defender.name + ' got hit by ' + attacker.name + ' and suffered ' + dmg + (attack.crit ? ' critical ' : '') + 'damage. ';
  attack.total = dmg; //foo should add fraction of attack to defender-health

  result.foo = function (defender, attack) {
    return function () {
      defender.Stats.increment('health', -1 * attack.total);
    };
  }(defender, attack);

  return result;
}; // calculates the damage of an attack and applies it


window.gm.combat.calcAttack = function (attacker, defender, attack) {
  var result = window.gm.combat.calcEvasion(attacker, defender, attack);

  if (result.OK === false) {
    return result;
  }

  var _tmp = result.msg;
  result = window.gm.combat.calcParry(attacker, defender, attack); //todo or block

  if (result.foo !== null) result.foo(attacker, attack);

  if (result.OK === false) {
    return result;
  }

  _tmp += result.msg;
  result = window.gm.combat.calcAbsorb(attacker, defender, attack);
  if (result.foo !== null) result.foo(defender, attack);
  _tmp += result.msg;
  result.msg = _tmp;
  return result;
}; /////////////////////////////////////////////////////////////

/*  generic combat moves */
//used to skip turn


window.gm.combat.moveNOP = function () {
  var result = {
    OK: false,
    msg: ''
  };
  return result;
}; //increase defense


window.gm.combat.moveGuard = function () {
  //Todo
  var s = window.story.state;
  var result = {
    OK: true,
    msg: ''
  };

  if (s.combat.enemyTurn) {} else {}

  return result;
}; //stun caused by blunt weapon, shock


window.gm.combat.moveStun = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var result = {
    OK: true,
    msg: ''
  };

  var rnd = _.random(1, 100);

  if (rnd > 4) {
    result.msg += defender.name + " got stunned by " + attacker.name;
    defender.addEffect(effStunned.name, new effStunned());
  } else {
    result.msg += "Attempt to stun " + defender.name + " failed.";
    result.OK = false;
  }

  return result;
};

window.gm.combat.moveFlee = function () {
  //Todo
  var s = window.story.state;
  var result = {
    OK: true,
    msg: ''
  };

  var rnd = _.random(1, 100);

  if (s.combat.enemyTurn) {//todo fleeing enemy?
  } else {
    if (rnd > 40) {
      //Todo fleeing chance calculation
      result.msg += "You escaped the fight.";
      s.combat.playerFleeing = true; //just setting the flag, you have to take care of handling!
    } else {
      result.msg += "Your attempts to escape failed.";
      result.OK = false;
    }
  }

  return result;
};

window.gm.combat.moveSubmit = function () {
  var s = window.story.state;
  var result = {
    OK: true,
    msg: ''
  };

  var rnd = _.random(1, 100);

  if (s.combat.enemyTurn) {//todo enemy?
  } else {
    if (rnd > 0) {
      //Todo fleeing chance calculation
      result.msg += "You submit to your foe.";
      s.combat.playerSubmitting = true; //just setting the flag, you have to take care of handling!
    } else {
      result.msg += "Your attempts to submit failed.";
      result.OK = false;
    }
  }

  return result;
}; //calculates damage of attack


window.gm.combat.movePhysicalAttack = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var def = defender.Stats.get('pDefense').value;
  var att = attacker.Stats.get('pAttack').value;
  var result = window.gm.combat.calcAttack(attacker, defender, {
    value: att,
    total: att
  });
  return {
    OK: result.OK,
    msg: result.msg
  };
}; //OBSOLETE


window.gm.combat.movePhysicalAttack_old = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var msg = '';
  var crit = false,
      hit = false,
      block = false;
  var def = defender.Stats.get('pDefense').value;
  var att = attacker.Stats.get('pAttack').value; //??  Erfolgswahrscheinlichkeit skalieren mit Differenz der Attribute Player-Enemy
  // gleiche Attribute = Wahrscheinlichkeit*100%; Attribut-Diff +2 = *100%*2; Attribut-Diff +4 = *200%
  //GURPS-Lite ? this would means all skills are limited to 20!
  //atacker rolls 3d6; if < Attackskill you hit; if 3or4 you have critical hit; else you missed completely

  var rnd = window.gm.roll(3, 6);

  if (rnd == 3 || rnd == 4) {
    crit = hit = true;
    msg += attacker.name + ' landed a critical hit.</br>';
  } else if (rnd <= att) {
    hit = true;
  } else {
    msg += attacker.name + ' missed his target.</br>';
  } //defender rolls 3d6 (no roll on critical hit); if < Defense, the hit was avoided


  rnd = window.gm.roll(3, 6);

  if (crit == false) {
    if (rnd == 3 || rnd == 4) {
      hit = false;
      msg += defender.name + ' avoided beeing hit.</br>';
    } else if (rnd <= def) {
      block = true;
      msg += defender.name + ' was hit but shrugged of the damage.</br>';
    }
  } //attacker rolls dies according to weapon; damage is the result reduced by DR


  if (hit == true && block == false) {
    rnd = Math.max(0, rnd = window.gm.roll(1, 6) + 1 - 0); //todo

    defender.Stats.increment('health', -1 * rnd);
    msg += attacker.name + ' dealt ' + rnd + ' damage to ' + defender.name + '.</br>';
  }

  return {
    OK: hit && !block,
    msg: msg
  };
};

window.gm.combat.moveUltraKill = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var msg = '';
  var rnd = 30;
  defender.Stats.increment('health', -1 * rnd);
  msg += attacker.name + ' dealt ' + rnd + ' damage to ' + defender.name + '.</br>';
  return {
    OK: true,
    msg: msg
  };
};

"use strict"; //import {LighterDad} from './Items.js'; //why is this not working
//constant declarations
//this is a lookuptable for items
//this will make sure the item-ctor are registered and it can be used as a lookup 


function createItemLookups() {
  /*window.gm.ItemsLib = {};
  window.gm.ItemsLib['Money'] = new Money();
  window.gm.ItemsLib['LighterDad'] = new LighterDad();
  window.gm.ItemsLib['LaptopPS'] = new LaptopPS();
  window.gm.ItemsLib['Battery'] = new Battery();
  window.gm.ItemsLib['Dildo_small'] = new Dildo_small();
  // consumables
  window.gm.ItemsLib['Lube'] = new Lube();
  window.gm.ItemsLib['CanOfCoffee'] = new CanOfCoffee(); 
  window.gm.ItemsLib['SimpleFood'] = new SimpleFood(); 
  //.. and Wardrobe
  window.gm.ItemsLib['Leggings'] = new Leggings();
  window.gm.ItemsLib['Tank-shirt'] = new TankShirt(); 
  window.gm.ItemsLib['Jeans'] = new Jeans();
  window.gm.ItemsLib['Pullover'] = new Pullover();
  //special wardrobe-item combination
  window.gm.ItemsLib['Crowbar']  = new Crowbar();
  window.gm.ItemsLib['Shovel']  = new Shovel();//{name: 'Shovel', desc: 'A shovel for the dirty work.', tags: ['tool', 'weapon'], slotUse: ['RHand','LHand'],usable:defaultCanUse, use:defaultOnUse, canEquip:defaultCanUse, canUnequip:defaultCanUnequip };
  window.gm.ItemsLib['Handcuffs'] = new HandCuffs();//{name: 'Handcuffs', desc: 'You cannot use your hand.', tags: ['restrain'], slotUse: ['RHand','LHand'],usable:defaultCanUse, use:defaultOnUse, canEquip:defaultCanUse, canUnequip:defaultNoUnequip };
  window.gm.ItemsLib['TailNone'] = new TailNone();
  window.gm.ItemsLib['TailCat'] = new TailCat();
  */
  //lookup table 

  /* window.gm.StatsLib = { 
   'strength':stStrength,
   'perception':stPerception,
   'endurance':stEndurance,
   'charisma':stCharisma,
   'intelligence':stIntelligence,
   'agility': stAgility,
   'luck':stLuck,
   //'willpower':stWillpower,
   'pAttack' :stPAttack,
   'pDefense':stPDefense,
   'health': stHealth,
   'healthMax': stHealth,
   'energy': stEnergy,
   'energyMax': stEnergy,
   'arousal': stArousal,
   'arousalMin': stArousal,
   'arousalMax': stArousal,
   'perversion': stPerversion,
   'perversionMax': stPerversion
  }*/
  //register constructors for reviver or your loaded save will not work !
  //...items

  /* window.storage.registerConstructor(LighterDad);
   window.storage.registerConstructor(Money);
   window.storage.registerConstructor(LaptopPS);
   window.storage.registerConstructor(Battery);
   window.storage.registerConstructor(Dildo_small);
   window.storage.registerConstructor(Lube);
   window.storage.registerConstructor(CanOfCoffee);
   window.storage.registerConstructor(SimpleFood);
   // ...wardrobe
   window.storage.registerConstructor(Leggings);
   window.storage.registerConstructor(TankShirt);
   window.storage.registerConstructor(Jeans);
   window.storage.registerConstructor(Pullover);
   window.storage.registerConstructor(Crowbar);
   window.storage.registerConstructor(Shovel);
   //window.storage.registerConstructor(Handcuffs);*/

  /*//...stats
  window.storage.registerConstructor(stHealthMax);
  window.storage.registerConstructor(stHealth);
  window.storage.registerConstructor(stRelation);
  //...effects
  window.storage.registerConstructor(effNotTired);
  window.storage.registerConstructor(effTired);
  window.storage.registerConstructor(effEnergized);
  window.storage.registerConstructor(effStunned);
  window.storage.registerConstructor(skCooking);
  */
  //mapping from passage-locations to background images

  /*window.gm.test=function(dies) {
      var list={};
      var _com = [];
      var die =33;
      var total = Math.pow(die,dies);
      for(var a=1;a<=die;a++) {
          for(var b=1;b<=die;b++) {
              for(var c=1;c<=die;c++) {
                  if(list[a+b+c]) list[a+b+c]+=1;
                  else list[a+b+c] =1;
              }
          }
      }
      
      var list2 = Object.keys(list);
      for(var i=0;i<list2.length;i++) {
          list[list2[i]] *=1/total;
      }
      console.log(list);
  }*/
}

"use strict";
/* combat encounters are defined here */


window.gm = window.gm || {};
window.gm.encounters = window.gm.encounters || {};

window.gm.encounters.mole = function (location) {
  window.gm.Encounter = new CombatSetup();

  window.gm.Encounter.EnemyFunc = function () {
    var x = new window.gm.Mobs.Mole();
    x.scaleLevel(window.gm.player.level);
    return x;
  };

  window.gm.Encounter.Location = location;
  window.gm.Encounter.scenePic = window.gm.getScenePic(location);

  window.gm.Encounter.onSubmit = function () {
    return 'What will now happen to you?</br>' + window.gm.printPassageLink('Next', 'Mole Submit');
  };

  window.gm.Encounter.initCombat();
};

window.gm.encounters.mechanicguy = function (location) {
  window.gm.Encounter = new CombatSetup();
  window.gm.Encounter.EnemyFunc = window.gm.Mobs.Mechanic;
  window.gm.Encounter.Location = location;
  window.gm.Encounter.scenePic = window.gm.getScenePic(location);
  window.gm.Encounter.initCombat();
};

"use strict";
/*
core functionality
*/


window.gm = window.gm || {}; //game related operations

window.gm.util = window.gm.util || {}; //utility functions
// define save-game-file-version 1

window.gm.switchPlayer = function (playername) {
  var s = window.story.state;
  window.gm.player = s[playername];
  s.vars.activePlayer = playername;
}; //you might need to reimplement this to handle version upgrades on load


window.gm.rebuildObjects = function () {
  var s = window.story.state;
  window.gm.switchPlayer(s.vars.activePlayer);
}; //returns timestamp since start of game


window.gm.getTime = function () {
  return window.story.state.vars.time + 2400 * window.story.state.vars.day;
}; //calculates timedifference for hhmm time format


window.gm.getDeltaTime = function (a, b) {
  var m = a % 100;
  var h = (a - m) / 100;
  var m2 = b % 100;
  var h2 = (b - m2) / 100;
  return h * 60 + m - (h2 * 60 + m2);
}; //adds MINUTES to time


window.gm.addTime = function (min) {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  m = m + min;
  var m2 = m % 60;
  var h2 = h + (m - m2) / 60;
  window.story.state.vars.time = h2 * 100 + m2 % 60;

  while (window.story.state.vars.time >= 2400) {
    window.story.state.vars.time -= 2400;
    window.story.state.vars.day += 1;
  }

  window.gm.player.Effects.updateTime();
};

window.gm.getTimeString = function () {
  var c = window.gm.getTimeStruct();
  return (c.hour < 10 ? "0" : "") + c.hour.toString() + ":" + (c.min < 10 ? "0" : "") + c.min.toString() + "(" + c.daytime + ")";
}; // DoW = DayOfWeek  7 = Sunday, 1 = Monday,...6 = Saturday 


window.gm.getTimeStruct = function () {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var daytime = '';

  if (v.time > 500 && v.time < 1000) {
    daytime = 'morning';
  } else if (v.time >= 1000 && v.time < 1400) {
    daytime = 'noon';
  } else if (v.time >= 1400 && v.time < 1800) {
    daytime = 'afternoon';
  } else if (v.time >= 1800 && v.time < 2200) {
    daytime = 'evening';
  } else {
    daytime = 'night';
  }

  var DoW = window.story.state.vars.day % 7;
  return {
    'hour': h,
    'min': m,
    'daytime': daytime,
    'DoW': DoW
  };
};

window.gm.getDateString = function () {
  var v = window.story.state.vars;
  var DoW = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
  return v.day.toString() + ". day " + DoW[v.day % 7 - 1];
}; //forward time to until (1025 = 10:25), regenerate player
//warning dont write 0700 because this would be take as octal number


window.gm.sleep = function (until) {
  var v = window.story.state.vars;
  var msg = '';
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var m2 = until % 100;
  var h2 = (until - m) / 100;
  var min = (h2 - h) * 60 + (m2 - m); //if now is 8:00 and until 10:00 we assume you want to sleep 2h and not 2+24h
  //if now is 10:00 and until is 9:00 we assume sleep for 23h

  if (until < v.time) {
    min = 24 * 60 - (h - h2) * 60 + (m - m2);
  }

  if (min === 0) {
    //if sleep from 700 to 700, its a day
    min = 24 * 60;
  }

  msg += "</br>Slept for " + min / 60 + " hours.</br>";
  window.gm.addTime(min);
  var regen = min > 420 ? 999 : min / 60 * 15; //todo scaling of regeneration

  window.gm.player.Stats.increment('health', regen);
  window.gm.player.Stats.increment('energy', regen);
  window.gm.pushLog(msg);
  return msg;
}; //Todo


window.gm.rollExplore = function () {
  var s = window.story.state;
  var places = [];

  var r = _.random(0, 100); //todo:depending of your actual location you have a chance to find connected locations or end up in a known one


  if (window.gm.player.location == 'Park') places = ['Mall', 'Beach'];
  if (window.gm.player.location == 'Mall') places = ['Park', 'Beach', 'Downtown'];
  if (window.gm.player.location == 'Beach') places = ['Park', 'Mall'];

  if (window.gm.player.location == 'Downtown') {
    places.push('Pawn shop');
  }

  if (places.length == 0) places = [window.gm.player.location]; //fallback if unspeced location

  r = _.random(1, places.length) - 1; //chances are equal

  window.gm.addTime(20);
  window.story.show(places[r]);
};

window.gm.newGamePlus = function () {
  var NGP = {
    //be mindful if adding complex objects to NGP, they might not work as expected ! simple types are ok 
    crowBarLeft: window.story.state.vars.crowBarLeft
  };
  window.gm.initGame(true, NGP);
  window.story.show('Home');
}; // use child._parent = window.gm.util.refToParent(parent);


window.gm.util.refToParent = function (me) {
  return function () {
    return me;
  };
}; //---------------------------------------------------------------------------------
//TODO Deferred Event is incomplete
//maybe you sometimes dont want to trigger an event immediatly, 
//f.e. if you send a email, it might take some time until you get a response-email 
//(you can receive email at anytime on your phone, so we would have to add checks on ALL passages)
//use this function to push a passage to a stack of deffered events; 
//the passage will trigger under the given condition: minimum time, location-tag, at a certain time-window
//the passage will show when a new passage is requested and will be removed from stack
//if this passage is already pushed, only its condition will be updated


window.gm.pushDeferredEvent = function (id) {
  var cond1 = {
    waitTime: 6,
    locationTags: ['Home', 'City'],
    //Never trigger in Combat
    dayTime: [1100, 600]
  },
      cond2 = {
    waitTime: 60,
    locationTags: ['Letterbox']
  };
  var cond = [cond1, cond2]; //passage is executed if any of the conds is met

  window.story.state.vars.defferedStack.push({
    id: id,
    cond: cond
  });
};

window.gm.removeDefferedEvent = function () {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

  if (id !== "") {
    for (var i = window.story.state.vars.defferedStack.length - 1; i > 0; i--) {
      if (window.story.state.vars.defferedStack[i].id === id) window.story.state.vars.defferedStack.splice(i, 1);
    }
  } else {
    window.story.state.vars.defferedStack = [];
  }
};

window.gm.hasDeferredEvent = function () {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

  if (id !== "") {
    for (var i = 0; i < window.story.state.vars.defferedStack.length; i++) {
      if (window.story.state.vars.defferedStack[i].id === id) return true;
    }

    return false;
  } else {
    return window.story.state.vars.defferedStack.length > 0;
  }
};

window.gm.showDeferredEvent = function () {
  var msg = '';
  var namenext = window.passage.name;
  var tagsnext = window.story.passage(namenext).tags;
  var evt = window.story.state.vars.defferedStack.shift();

  if (evt !== null) {
    msg += window.gm.printPassageLink("Next", evt.id);
  }

  return msg;
}; //when show is called the previous passage is stored if the new has [_back]-tag
//if the new has no back-tag, the stack gets cleared


window.gm.pushPassage = function (id) {
  if (!window.story.state.hasOwnProperty("vars")) return; //vars exist only after initGame

  if (window.story.state.vars.passageStack.length > 0 && window.story.state.vars.passageStack[window.story.state.vars.passageStack.length - 1] === id) {//already pushed
  } else {
    window.story.state.vars.passageStack.push(id);
  }
}; //call on [_back]-passages to get the previous passage


window.gm.popPassage = function () {
  var pass = window.story.state.vars.passageStack.pop();
  if (!pass) return 'nothing to pop from stack';
  return pass;
}; //overriding show:
//- to enable back-link
//- to intercept with deffered events


var _origStoryShow = window.story.__proto__.show;

window.story.__proto__.show = function (idOrName) {
  var noHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var next = idOrName;

  if (idOrName === '_back') {
    //going back
    next = window.gm.popPassage();
  } else {
    //going forward
    var tagsnext = window.story.passage(next).tags;
    var namenext = window.story.passage(next).name;

    if (tagsnext.indexOf('_back') >= 0) {
      //push on stack but only if not re-showing itself
      if (namenext != window.passage.name) window.gm.pushPassage(window.passage.name);
    } else if (window.story.state.hasOwnProperty("vars")) {
      window.story.state.vars.passageStack.splice(0, window.story.state.vars.passageStack.length);
    }
  } //Todo
  //before entering a new passage check if there is a defferedEvent that we should do first
  //if so, push the normal-passage onto stack, show deffered passage
  //after the deffered passage(s) finish, make sure to show the original passage
  //this is a problem?how do I know the deffered passage is done? 


  _origStoryShow.call(window.story, next, noHistory);
}; //---------------------------------------------------------------------------------
//updates all panels


window.gm.refreshScreen = function () {
  window.story.show(window.passage.name);
}; //updates only sidepanle,logpanel


window.gm.updateOtherPanels = function () {
  renderToSelector("#sidebar", "sidebar");
  renderToSelector("#LogPanel", "LogPanel");
};

window.gm.pushLog = function (msg) {
  var Cond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!Cond) return;
  var log = window.story.state.vars.log;
  log.unshift(msg);

  if (log.length > 10) {
    log.splice(log.length - 1, 1);
  }
};

window.gm.getLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  return msg;
};

window.gm.clearLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  window.story.state.vars.log = [];
  return msg;
};

window.gm.roll = function (n, sides) {
  //rolls n x dies with sides
  var rnd = 0;

  for (var i = 0; i < n; i++) {
    rnd += _.random(1, sides);
  }

  return rnd;
};

window.gm.printOutput = function (text) {
  document.querySelector("section article div output").innerHTML = text;
}; //connect to onclick to toggle selected-style for element + un-hiding related text
//the elmnt (f.e.<img>) needs to be inside a parentnode f.e. <div id="choice">
//ex_choice is jquery path to fetch all selectable elmnt
//for a table in a div this could be "div#choice table tbody tr td *"
//text-nodes needs to be inside a parent node f.e. <div id="info"> and have matching id of elmnt
//ex_info is jquery path to fetch all info elmnt
//for a <p> in div this could be "div#info  


window.gm.onSelect = function (elmnt, ex_choice, ex_info) {
  var all = $(ex_choice); //[0].children;

  for (var i = 0; i < all.length; i++) {
    if (all[i].id === elmnt.id) {
      all[i].classList.add("selected");
    } else all[i].classList.remove("selected");
  }

  all = $(ex_info)[0].children;

  for (var i = 0; i < all.length; i++) {
    if (all[i].id === elmnt.id) {
      all[i].hidden = false;
    } else all[i].hidden = true;
  }
}; //prints the same kind of link like [[Next]] but can be called from code


window.gm.printPassageLink = function (label, target) {
  return "<a href=\"javascript:void(0)\" data-passage=\"" + target + "\">" + label + "</a></br>";
}; //dynamically build a link representing a buy option including display of cost and restriction
//count specifys how any items you get for cost
//cbCanBuy points to a function fn(itemid) that returns if can buy {OK:false,msg:'too expensive'} 
//cbPostBuy points to a function fn(itemid) that is called after buying ; 


window.gm.printShopBuyEntry = function (itemid, count, cbCanBuy) {
  var cbPostBuy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var desc2 = itemid + 'out of stock</br>';
  var entry = document.createElement('a'); // entry is a link that will expand to item description

  entry.id = itemid;
  entry.href = 'javascript:void(0)';

  var showDesc = function showDesc($event) {
    var elmt = document.querySelector("div#" + $event.srcElement.id);
    elmt.innerHTML = window.gm.ItemsLib[$event.srcElement.id].desc + "</br>";
    elmt.toggleAttribute("hidden");
  };

  entry.addEventListener("click", showDesc, false);
  var div = document.createElement('div');
  div.id = itemid;
  div.hidden = true;
  var entryBuy = document.createElement('a'); //entryBuy is a link that actual buys something or shows why not

  entryBuy.id = itemid;
  entryBuy.href = 'javascript:void(0)';
  entryBuy.textContent = "Buy";

  if (count > 0) {
    var result = cbCanBuy(itemid);
    desc2 = itemid + " (x" + count + ")";

    if (result.OK === false) {
      desc2 = desc2 + " " + result.msg;
    } else {
      desc2 += " " + result.msg;

      var foo = function foo($event) {
        window.gm.buyFromShop(itemid, count, cbPostBuy);
      };

      entryBuy.addEventListener("click", foo, false);
    }
  }

  entry.textContent = desc2;
  $("div#panel")[0].appendChild(entry);
  $("div#panel")[0].appendChild(entryBuy);
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(div);
}; //a callback function to check if you can buy something;
//should return {OK:true,msg:'',postBuy:null} where message will be displayed either as reason why you cannot buy or cost
//unused because makes it unoverridable ->postboy is {fn:foo, cost:x} where fn points to a function that is called after buying (fn(itemid,x));  
//this implementation checks: money


window.gm.defaultCanBuy = function (itemid, cost) {
  var result = {
    OK: true,
    msg: ''
  }; //, postBuy:null};

  var money = window.gm.player.Inv.countItem('Money');

  if (money >= cost) {
    result.msg = 'buy for ' + cost + '$'; //result.postBuy = function(x){ return (function(item,y=x){window.gm.defaultPostBuy(item,y);})}(cost);
    //result.postBuy = {fn:window.gm.defaultPostBuy, cost:cost};
  } else {
    result.OK = false;
    result.msg = 'requires ' + cost + '$';
  }

  ;
  return result;
};

window.gm.defaultCanSell = function (itemid, cost) {
  var result = {
    OK: true,
    msg: ''
  }; //todo check equipped item

  result.msg = 'sell for ' + cost + '$';
  return result;
}; //requires a <div id='choice'> </div> for displaying bought-message


window.gm.defaultPostSell = function (itemid, cost) {
  window.gm.player.Inv.addItem(new Money(), cost);
  $("div#choice")[0].innerHTML = 'You sold ' + itemid;
  $("div#choice")[0].classList.remove("div_alarm");
  $("div#choice")[0].offsetWidth; //this forces the browser to notice the class removal

  $("div#choice")[0].classList.add("div_alarm");
}; //requires a <div id='choice'> </div> for displaying bought-message


window.gm.defaultPostBuy = function (itemid, cost) {
  window.gm.player.Inv.removeItem('Money', cost);
  $("div#choice")[0].innerHTML = 'You bought ' + itemid;
  $("div#choice")[0].classList.remove("div_alarm");
  $("div#choice")[0].offsetWidth; //this forces the browser to notice the class removal

  $("div#choice")[0].classList.add("div_alarm");
};

window.gm.cbCanBuyPerverse = function (itemid, cost, pervcost) {
  var result = window.gm.defaultCanBuy(itemid, cost);

  if (window.gm.player.Stats.get('perversion').value < pervcost) {
    result.msg += ' ; requires Perversion> ' + pervcost;
    result.OK = false;
  }

  return result;
}; //this will add item to player; money-deduct or other cost has to be done in cbPostBuy ! 


window.gm.buyFromShop = function (itemid, count, cbPostBuy) {
  window.gm.player.Inv.addItem(new window.storage.constructors[itemid](), count); //Todo item or wardrobe

  if (cbPostBuy) cbPostBuy(itemid); //window.gm.refreshScreen(); dont refresh fullscreen or might reset modified textoutput

  window.gm.updateOtherPanels(); //just update other panels

  renderToSelector("#panel", "listsell");
}; //this will remove item from player; money-deduct or other cost has to be done in cbPostSell ! 


window.gm.sellToShop = function (itemid, count, cbPostSell) {
  window.gm.player.Inv.removeItem(itemid, count);
  if (cbPostSell) cbPostSell(itemid); //window.gm.refreshScreen(); dont refresh fullscreen or might reset modified textoutput

  window.gm.updateOtherPanels(); //just update other panels

  renderToSelector("#panel", "listsell");
}; //dynamically build a link representing a sell option including display of cost
//count defines how many of this item you have to trade in


window.gm.printShopSellEntry = function (itemid, count, cbCanSell, cbPostSell) {
  var _available = window.gm.player.Inv.countItem(itemid); //only items the player has can be sold


  if (_available <= 0) return;
  var entry = document.createElement('a');
  entry.id = itemid;
  entry.href = 'javascript:void(0)';

  var showDesc = function showDesc($event) {
    var elmt = document.querySelector("div#" + $event.srcElement.id);
    elmt.innerHTML = window.gm.ItemsLib[$event.srcElement.id].desc + "</br>";
    elmt.toggleAttribute("hidden");
  };

  entry.addEventListener("click", showDesc, false);
  var div = document.createElement('div');
  div.id = itemid;
  div.hidden = true;
  var entrySell = document.createElement('a'); //a link where you can sell

  entrySell.id = itemid;
  entrySell.href = 'javascript:void(0)';
  entrySell.textContent = "Sell";
  var desc2 = itemid + " (x" + count + ")";

  if (_available >= count) {
    var result = cbCanSell(itemid);

    if (result.OK === false) {
      desc2 = desc2 + " " + result.msg;
    } else {
      desc2 += " " + result.msg;

      var foo = function foo($event) {
        window.gm.sellToShop(itemid, count, cbPostSell);
      };

      entrySell.addEventListener("click", foo, false);
    }
  } else desc2 = desc2 + " not enough items";

  entry.textContent = desc2;
  $("div#panel")[0].appendChild(entry);
  $("div#panel")[0].appendChild(entrySell);
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(div);
}; //prints a link that when clicked picksup an item and places it in the inventory, if itemleft is <0, no link appears


window.gm.printPickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var elmt = '';
  var s = window.story.state;
  if (!(itemleft > 0)) return elmt;
  var desc2 = desc + " (" + itemleft + " left)";
  var msg = 'took ' + itemid;
  elmt += "<a0 id='" + itemid + "' onclick='(function($event){window.gm.pickupAndClear(\"" + itemid + "\", \"" + desc + "\"," + itemleft + "," + cbAfterPickup + ")})(this);'>" + desc2 + "</a></br>";
  return elmt;
};

window.gm.pickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  window.gm.player.Inv.addItem(new window.storage.constructors[itemid]()); //window.gm.pushLog("added "+itemid+" to inventory.</br>");

  if (cbAfterPickup) cbAfterPickup();
  window.gm.refreshScreen();
}; //prints an item with description; used in inventory


window.gm.printItem = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  var _inv = window.gm.player.Inv;

  var _count = _inv.countItem(id);

  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, " (x").concat(_count, ")</a>");

  var useable = _inv.usable(id);

  if (_count > 0 && useable.OK) {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){var _res=window.gm.player.Inv.use(\"").concat(id, "\"); window.gm.refreshScreen();window.gm.printOutput(_res.msg);}(this))'>").concat(useable.msg, "</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints an equipment with description; used in wardrobe


window.gm.printEquipment = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, "</a>");

  if (window.gm.player.Outfit.countItem(id) <= 0) {
    //elmt +=`<a0 id='${id}' onclick='(function($event){window.gm.player.Outfit.addItem(new window.storage.constructors[\"${id}\"]()); window.gm.refreshScreen();}(this))'>Equip</a>`;
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.addItem(window.gm.player.Wardrobe.getItem(\"").concat(id, "\")); window.gm.refreshScreen();}(this))'>Equip</a>");
  } else {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.removeItem(\"").concat(id, "\"); window.gm.refreshScreen();}(this))'>Unequip</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints a string listing equipped items


window.gm.printEquipmentSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];

  for (var i = 0; i < window.gm.player.Outfit.count(); i++) {
    if (i >= window.gm.OutfitSlotpLib.bTorso) continue; //skip bodyparts

    var id = window.gm.player.Outfit.getItemId(i);

    if (id != '' && ids.indexOf(id) < 0) {
      ids.push(id);
      result += id + ',';
    }
  }

  return result;
}; //prints a string listing equipped items


window.gm.printRelationSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';
  var ids = window.gm.player.Rel.getAllIds();
  ids.sort();

  for (var k = 0; k < ids.length; k++) {
    if (ids[k].split("_").length === 1) {
      //ignore _min/_max
      var data = window.gm.player.Rel.get(ids[k]);
      result += '<tr><td>' + data.id + ':</td><td>' + data.value + ' of ' + window.gm.player.Rel.get(ids[k] + "_Max").value + '</td></tr>';
    }
  } //todo print mom : 10 of 20


  result += '</table>';
  return result;
}; //prints achievements


window.gm.printAchievements = function () {
  var elmt = '';
  var result = '';
  var ids = [];
  result += '<table>';
  var ids = Object.keys(window.gm.achievements);
  ids.sort();

  for (var k = 0; k < ids.length; k++) {
    if (ids[k].split("_").length === 1) {
      //ignore _min/_max
      result += '<tr><td>' + ids[k] + ':</td><td>' + window.gm.achievements[ids[k]] + '</td></tr>';
    }
  } //todo print mom : 10 of 20


  result += '</table>';
  return result;
}; //prints a string listing stats and effects


window.gm.printEffectSummary = function () {
  var who = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'player';
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';
  var ids = window.gm[who].Stats.getAllIds();
  ids.sort(); //Todo better sort

  for (var k = 0; k < ids.length; k++) {
    var data = window.gm[who].Stats.get(ids[k]);

    if (data.hidden !== 4) {
      result += '<tr><td>' + (data.hidden & 0x1 ? '???' : data.id) + ':</td><td>' + (data.hidden & 0x2 ? '???' : data.value) + '</td></tr>';
    }
  }

  result += '</table>';
  result += '</br>Active Effects:<table>';
  ids = window.gm[who].Effects.getAllIds();
  ids.sort(); //Todo better sort

  for (var i = 0; i < ids.length; i++) {
    var data = window.gm[who].Effects.get(ids[i]);
    result += '<tr><td>' + data.id + ':</td><td>' + data.name + '</td></tr>';
  }

  result += '</table>';
  return result;
}; ///show/hides a dialog defined in body


window.gm.toggleDialog = function (id) {
  var _id = id;
  var dialog = document.querySelector(id),
      closebutton = document.getElementById('close-dialog'),
      pagebackground = document.querySelector('body');
  var div;

  if (!dialog.hasAttribute('open')) {
    // show the dialog 
    div = document.createElement('div');
    div.id = 'backdrop';
    document.body.appendChild(div);
    dialog.setAttribute('open', 'open'); // after displaying the dialog, focus the closebutton inside it

    closebutton.focus();
    closebutton.addEventListener('click', function () {
      window.gm.toggleDialog(_id);
    });
  } else {
    dialog.removeAttribute('open');
    div = document.querySelector('#backdrop');
    div.parentNode.removeChild(div); //??lastFocus.focus();
  }
};

"use strict";

var Item = /*#__PURE__*/function () {
  function Item(name) {
    _classCallCheck(this, Item);

    this.name = name;
    this.desc = '';
  }

  _createClass(Item, [{
    key: "usable",
    //context is the owner of item (parent of inventory), on is target (character)
    value: function usable(context) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }]);

  return Item;
}(); //an Inventory-Component to store items


var Inventory = /*#__PURE__*/function () {
  function Inventory(externlist) {
    _classCallCheck(this, Inventory);

    this.list = externlist ? externlist : [];
    window.storage.registerConstructor(Inventory);
  }

  _createClass(Inventory, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Inventory", this);
    }
  }, {
    key: "_relinkItems",
    value: function _relinkItems() {
      for (var i = 0; i < this.list.length; i++) {
        if (this.list[i].item) this.list[i].item._parent = window.gm.util.refToParent(this);
      }
    }
  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Inventory: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }, {
    key: "count",
    value: function count() {
      return this.list.length;
    }
  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return 0;
      return this.list[_i].count;
    }
  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) return i;
      }

      return -1;
    }
  }, {
    key: "getItemId",
    value: function getItemId(slot) {
      return this.list[slot].id;
    }
  }, {
    key: "getItem",
    value: function getItem(id) {
      var _idx = this.findItemSlot(id);

      if (_idx < 0) throw new Error('no such item: ' + id);
      return this.list[_idx].item;
    } //returns all Ids in list

  }, {
    key: "getAllIds",
    value: function getAllIds() {
      var ids = [];

      for (var i = 0; i < this.list.length; i++) {
        ids.push(this.list[i].id);
      }

      return ids;
    }
  }, {
    key: "addItem",
    value: function addItem(item) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(item.name);

      if (_i < 0) {
        item._parent = window.gm.util.refToParent(this);
        this.list.push({
          'id': item.name,
          'count': count,
          item: item
        });
      } else this.list[_i].count += count;

      this.postItemChange(item.name, "added", "");
    }
  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      this.list[_i].count -= count;
      if (this.list[_i].count < 1) this.list.splice(_i, 1);
      this.postItemChange(id, "removed", "");
    } //convience method to check if item is usable

  }, {
    key: "usable",
    value: function usable(id) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _item = this.getItem(id);

      return _item.usable(this, on);
    } //uses an item by calling item.use

  }, {
    key: "use",
    value: function use(id) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _item = this.getItem(id);

      var result = _item.use(this, on);

      if (result.OK) {
        this.postItemChange(id, "used", result.msg);
      }

      return result;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Inventory, value.data);

      return _x;
    }
  }]);

  return Inventory;
}();

"use strict";

var Mob = /*#__PURE__*/function (_Character) {
  _inherits(Mob, _Character);

  var _super = _createSuper(Mob);

  function Mob() {
    _classCallCheck(this, Mob);

    return _super.apply(this, arguments);
  }

  _createClass(Mob, [{
    key: "calcCombatMove",
    //override to return the next move to execute
    //OK = false if move===null, else true
    //msg should contain a message formatted for view (move description and result) 
    //this function should decide what actions the mob takes; 
    //query _canAct to check if stunned or otherwise incapaciated, then run execCombatCmd(moveNOP) 
    value: function calcCombatMove() {
      var rnd = _.random(1, 100);

      var result = this._canAct();

      if (result.OK === false) {
        window.gm.Encounter.execCombatCmd(window.gm.combat.moveNOP);
        return result;
      }

      if (rnd > 30) {
        result = window.gm.Encounter.execCombatCmd(window.gm.combat.movePhysicalAttack);
        result.msg = this.name + " trys to attack you.</br>" + result.msg;
      } else {
        result = window.gm.Encounter.execCombatCmd(window.gm.combat.moveGuard);
        result.msg = this.name + " takes a defensive stance.</br>" + result.msg;
      }

      return result;
    } //override to adjust the mobs attributes to player level

  }, {
    key: "scaleLevel",
    value: function scaleLevel(lvl) {}
  }]);

  return Mob;
}(Character);

"use strict";
/* a player has an outfit describing which Equipment (wardrobe,utilities,..) he has equiped
*/
//this is a lookuptable for the equipmentslots


window.gm.OutfitSlotpLib = {
  Legs: 1,
  Feet: 2,
  Arms: 3,
  Torso: 4,
  LHand: 5,
  RHand: 6,
  UWTop: 7,
  //UW  = under wear
  UWGroin: 8,
  UWFeet: 9,
  UWLegs: 10,
  Hat: 11,
  Neck: 12,
  Eys: 13,
  TailTip: 14,
  bTorso: 35,
  //b.. = bodyparts
  bSkin: 36,
  bTailBase: 37,
  bBreast: 38,
  //insert more slots here
  SLOTMAX: 50
}; //Todo equip on other char:
//move from own inventory to chars, equip, if impossible undo 

var Equipment = /*#__PURE__*/function (_Item) {
  _inherits(Equipment, _Item);

  var _super2 = _createSuper(Equipment);

  function Equipment(name) {
    var _this;

    _classCallCheck(this, Equipment);

    _this = _super2.call(this, name);
    _this.tags = [];
    _this.slotUse = [];
    return _this;
  } // Attention !!
  //_parent will be added dynamical


  _createClass(Equipment, [{
    key: "usable",
    //for compatibility with item
    value: function usable(context) {
      return {
        OK: false,
        msg: 'Useable in wardrobe'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }]);

  return Equipment;
}(Item); //a kind of special inventory for worn equipment


var Outfit = /*#__PURE__*/function (_Inventory) {
  _inherits(Outfit, _Inventory);

  var _super3 = _createSuper(Outfit);

  function Outfit(externlist) {
    var _this2;

    _classCallCheck(this, Outfit);

    _this2 = _super3.call(this, externlist); //create each slot

    for (var i = 0; i < window.gm.OutfitSlotpLib.SLOTMAX; i++) {
      if (_this2.list.length - 1 < i) {
        _this2.list.push({
          id: '',
          item: null
        }); // {id:'Leggings'}

      }
    }

    window.storage.registerConstructor(Outfit);
    return _this2;
  }

  _createClass(Outfit, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Outfit", this);
    }
  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Outfit: ' + operation + ' ' + id + ' ' + msg + '</br>');
    } //count how many slots are used by an item

  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      return _i.length;
    } //detect which slots are used by a item

  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      var _idx = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) _idx.push(i);
      }

      return _idx;
    } //override because findItemSlot returns array

  }, {
    key: "getItem",
    value: function getItem(id) {
      var _idx = this.findItemSlot(id);

      if (_idx.length < 0) throw new Error('no such item: ' + id);
      return this.list[_idx[0]].item;
    }
  }, {
    key: "canEquipSlot",
    value: function canEquipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipSlot",
    value: function canUnequipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipItem",
    value: function canUnequipItem(id, force) {
      var _idx = this.findItemSlot(id);

      var _item = this.getItem(id);

      var result = _item.canUnequip();

      for (var i = 0; i < _idx.length; i++) {
        var _tmp = this.canUnequipSlot(_idx[i]);

        if (!_tmp.OK) result.msg += _tmp.msg + " ";
        result.OK = result.OK && _tmp.OK;
      }

      return result;
    } //this will equip item if possible

  }, {
    key: "addItem",
    value: function addItem(item, force) {
      var _idx = this.findItemSlot(item.name);

      if (_idx.length > 0) return; //already equipped

      var _item = item;
      _idx = _item.slotUse.map(function (cv, ix, arr) {
        return window.gm.OutfitSlotpLib[cv];
      });
      var _oldIDs = [];
      var _oldSlots = [];
      var result = {
        OK: true,
        msg: ''
      }; //check if equipment is equipable

      result = item.canEquip();

      if (result.OK) {
        for (var l = 0; l < _idx.length; l++) {
          //check if the current equip can be unequipped
          var oldId = this.getItemId(_idx[l]);
          if (oldId === '') continue;

          if (_oldIDs.indexOf(oldId) < 0) {
            _oldIDs.push(oldId);

            _oldSlots = _oldSlots.concat(this.getItem(oldId).slotUse.map(function (cv, ix, arr) {
              return window.gm.OutfitSlotpLib[cv];
            }));
          }

          var _tmp = this.canUnequipItem(oldId);

          if (!_tmp.OK) result.msg += _tmp.msg; //todo duplicated msg if item uses multiple slots

          result.OK = result.OK && _tmp.OK; //Todo  check if slot is available fo equip this canEquipSlot(_idx[l])
        }
      }

      if (!result.OK) {
        this.postItemChange(_item.name, "equip_fail:", result.msg);
        return;
      }

      for (var m = 0; m < _oldIDs.length; m++) {
        this.getItem(_oldIDs[m]).onUnequip(this);
      }

      for (var i = 0; i < _oldSlots.length; i++) {
        this.__clearSlot(_oldSlots[i]);
      }

      for (var k = 0; k < _idx.length; k++) {
        this.list[_idx[k]].id = _item.name;
        this.list[_idx[k]].item = _item;
      }

      _item._parent = window.gm.util.refToParent(this); //Todo currently we have 2 copies of equipment - 1 for wardrobe 1 for outfit otherwise this will not work

      result = _item.onEquip();
      this.postItemChange(_item.name, "equipped", result.msg);
    } //assumme that it was checked before that unequip is allowed

  }, {
    key: "__clearSlot",
    value: function __clearSlot(slot, force) {
      this.list[slot].id = '', this.list[slot].item = null;
    }
  }, {
    key: "removeItem",
    value: function removeItem(id, force) {
      var _idx = this.findItemSlot(id);

      if (_idx.length === 0) return; //already unequipped

      var result = this.canUnequipItem(id);

      if (!result.OK) {
        this.postItemChange(id, "unequip_fail", result.msg);
        return;
      }

      var _item = this.getItem(id);

      result = _item.onUnequip(this);

      for (var i = 0; i < _idx.length; i++) {
        this.__clearSlot(_idx[i]);
      }

      this.postItemChange(id, "removed", result.msg); //Todo delete _item;    //un-parent
    }
  }, {
    key: "isNaked",
    value: function isNaked() {
      //TODO
      if (this.getItemId(window.gm.OutfitSlotpLib.Legs) === '' || this.getItemId(window.gm.OutfitSlotpLib.Torso) === '') {
        return true;
      }

      return false;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Outfit, value.data);
    }
  }]);

  return Outfit;
}(Inventory);

"use strict"; //operations for save/reload
// ??window.onload = function() {};


window.storage = {
  // A list of constructors the smart reviver should know about  
  // you need to register the class of each object that you want to serialize to this list
  // and each class also has to have a method toJSON and static method fromJSON (calling Generic_-versions, see below )
  constructors: {},
  registerConstructor: function registerConstructor(ctor) {
    window.storage.constructors[ctor.name] = ctor;
  },
  // A generic "smart reviver" function.
  // Looks for object values with a `ctor` property and
  // a `data` property. If it finds them, and finds a matching
  // constructor that has a `fromJSON` property on it, it hands
  // off to that `fromJSON` fuunction, passing in the value.
  Reviver: function Reviver(key, value) {
    //console.info( 'reviver with key =' + key )
    var ctor;

    if (value !== null && _typeof(value) === "object" && typeof value.ctor === "string" && typeof value.data !== "undefined") {
      ctor = window.storage.constructors[value.ctor] || window[value.ctor];

      if (typeof ctor === "function" && typeof ctor.fromJSON === "function") {
        return ctor.fromJSON(value);
      }
    }

    return value;
  },
  //this function works with Json.stringify to remove circular references
  // unused because Reviver has even more problems with that

  /*_replacerFunc: function(){
    const visited = new WeakSet();
    return (key, value) => {
      if (value !== null && typeof value === "object") {
        if (visited.has(value)) {  return;  }
        visited.add(value);
      }
      return value;
    };
  },*/
  // A generic "toJSON" function that creates the data expected by Reviver.
  // `ctorName`  The name of the constructor to use to revive it
  // `obj`       The object being serialized
  // `keys`      (Optional) Array of the properties to serialize,
  //             if not given then all of the objects "own" properties
  //             that don't have function values will be serialized.
  //             (Note: If you list a property in `keys`, it will be serialized
  //             regardless of whether it's an "own" property.)
  // Returns:    The structure (which will then be turned into a string
  //             as part of the JSON.stringify algorithm)
  // Stringify it with a replacer: var str = JSON.stringify(myObj);
  Generic_toJSON: function Generic_toJSON(ctorName, obj, keys) {
    var data, index, key;

    if (!keys) {
      keys = Object.keys(obj); // Only "own" properties are included
    }

    data = {};

    for (index = 0; index < keys.length; ++index) {
      key = keys[index];
      data[key] = obj[key]; //TODO causes infinite loop on circular ref   Character->Inventory->Character
    }

    return {
      ctor: ctorName,
      data: data
    };
  },
  // A generic "fromJSON" function for use with Reviver: Just calls the
  // constructor function with no arguments, then applies all of the
  // key/value pairs from the raw data to the instance.
  // Only useful for constructors that can be reasonably called without arguments!
  // `ctor`      The constructor to call
  // `data`      The data to apply
  // Returns:    The object
  Generic_fromJSON: function Generic_fromJSON(ctor, data) {
    var obj, name, setter, setter2;
    obj = new ctor();

    for (name in data) {
      setter = "set" + name[0].toUpperCase() + name.substr(1); // we get the name of the setter for that property (e.g. : key=property => setter=setProperty
      // that kind of names cannot be found in obj??? setter2 = "set "+name.substr(1); // e.g. : key=_property => setter=set property   (javascript style setter)

      if (setter in obj) {
        // if the setter exists 
        obj[setter](data[name]); // we call the setter
        // } else if(setter2 in obj){ // ..or...
        //   obj[setter2](data[name]); 
      } else {
        // if not, we set it directly
        if (_typeof(obj[name]) === "object") {
          Object.assign(obj[name], data[name]);
        } else {
          obj[name] = data[name]; //todo ??? obj[name] is constructed properly but will be overwritten with data[namme]; use assign ?!
        }
      }
    }

    return obj;
  },
  ok: function ok() {
    try {
      var storage = window["localStorage"],
          x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && ( // everything except Firefox
      e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' || // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  },
  delete: function _delete(slot) {
    window.localStorage.removeItem(slot);
    window.localStorage.removeItem(slot.concat('info'));
  },
  getSaveInfo: function getSaveInfo(slot) {
    var info = null;

    if (window.storage.ok()) {
      info = window.localStorage.getItem(window.story.name + slot.concat('info'));
    }

    if (!info) {
      return '';
    }

    return info;
  },
  compressLocalSave: false,
  //this is for debugging (save file uncompressed)
  loadFile: function loadFile(input) {
    var file = input.files[0];
    var fileReader = new FileReader();

    fileReader.onload = function () {
      var _blobs = fileReader.result.split("!achievements!");

      window.storage.rebuildFromSave(_blobs[0], window.storage.compressLocalSave);
      window.storage.rebuildAchievements(_blobs[1], window.storage.compressLocalSave);
      var div = document.querySelector('#backdrop'); //see save/load dialog

      div.parentNode.removeChild(div);
    };

    fileReader.onerror = function () {
      alert(fileReader.error);
    };

    fileReader.readAsText(file);
    return true; //todo how to make async
  },
  saveFile: function saveFile() {
    var hash = JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    });
    var ahash = window.storage.getAchievements();

    if (window.storage.compressLocalSave) {
      hash = LZString.compressToBase64(hash);
      ahash = LZString.compressToBase64(ahash);
    }

    var filename = window.story.name + "_Save.dat";
    var blob = new Blob([hash, "!achievements!", ahash], {
      type: "text/plain;charset=utf-8"
    });
    saveAs(blob, filename);
  },
  saveBrowser: function saveBrowser(slot) {
    //var hash= window.story.save();    this call somehow messes up html and I had to copy the following from snowman script
    //always compress or storage could be full soon !
    var hash = LZString.compressToBase64(JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    }));
    var ahash = LZString.compressToBase64(window.storage.getAchievements());
    var options = {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    };
    var info = window.gm.player.location + ' - ' + new Intl.DateTimeFormat("default", options).format(new Date()); //add storyname to avoid conflict with other games on same host (see Document.origin)

    window.localStorage.setItem(window.story.name + slot.concat('info'), info);
    window.localStorage.setItem(window.story.name + slot, hash);
    window.localStorage.setItem(window.story.name + 'achievements', ahash);
    return info;
  },
  loadBrowser: function loadBrowser(slot) {
    var hash, info;

    if (window.storage.ok()) {
      //not possible to save object {info,hash} ??
      hash = window.localStorage.getItem(window.story.name + slot);
      info = window.storage.getSaveInfo(window.story.name + slot);
      window.storage.rebuildFromSave(hash, true);
      var ahash = window.localStorage.getItem(window.story.name + 'achievements');
      window.storage.loadAchivementsFromBrowser();
    }

    return info;
  },
  rebuildFromSave: function rebuildFromSave(hash, compressed) {
    if (!compressed) hash = LZString.compressToBase64(hash); //copied from window.story.restore because reviver  //window.story.restore(hash) ;

    var save = JSON.parse(LZString.decompressFromBase64(hash), window.storage.Reviver);
    window.story.state = save.state;
    window.story.history = save.history;
    window.story.checkpointName = save.checkpointName;
    window.gm.rebuildObjects(); // this is for handling version-upgrades

    window.story.show(window.story.history[window.story.history.length - 1], true);
  },
  getAchievements: function getAchievements() {
    var ahash = JSON.stringify({
      achievements: window.gm.achievements
    });
    return ahash;
  },
  loadAchivementsFromBrowser: function loadAchivementsFromBrowser() {
    if (window.storage.ok()) {
      var ahash = window.localStorage.getItem(window.story.name + 'achievements');
      if (ahash !== null) window.storage.rebuildAchievements(ahash, true);
    }
  },
  rebuildAchievements: function rebuildAchievements(ahash, compressed) {
    if (!compressed) ahash = LZString.compressToBase64(ahash);
    var achievements = JSON.parse(LZString.decompressFromBase64(ahash)).achievements; //it might be necessary to adapt the achievements here if a newer game-version is started !

    var _keys = Object.keys(window.gm.achievements);

    for (var i = 0; i < _keys.length; i++) {
      if (achievements.hasOwnProperty(_keys[i])) {
        var _old = achievements[_keys[i]];
        var _now = window.gm.achievements[_keys[i]];
        if (_old > _now) window.gm.achievements[_keys[i]] = _old; //merge loaded achievements into present
      }
    }
  }
};
/*  //save demo
window.gm.testsaveReviver = function () {
  window.storage.registerConstructor(Bar);
  window.storage.registerConstructor(Foo);
  var before = {
    foo: new Foo(21, 44),foo2: new Foo(100, 111),
  };
  before.foo.print(); // Stringify it with a replacer:
  var str = JSON.stringify(before); // Show that
  console.log(str); // Re-create it with use of a "reviver" function
  var after = JSON.parse(str, window.storage.Reviver);
  after.foo.print();after.foo2.print();
};
class Bar {
  constructor(x) {
    this.__type="Bar";
    this._x = x;
  }
  get parent() {return this._parent();}
  print() {      console.log("parent="+this.parent.a.toString()+ this._x);    };
 toJSON() {return window.storage.Generic_toJSON("Bar", this); };
 static fromJSON(value) { return window.storage.Generic_fromJSON(Bar, value.data);};
}

class Foo {
  constructor(a=0, b=0) {
    this.__type = 'Foo';
    this.a = a, this.b = b;
    this._bar = new Bar('fooboo'+this.a.toString());
    this._bar2 = new Bar('ba2'+this.b.toString());
    this._bar._parent = (function(me){ return function(){return me;}}(this));
    this._bar2._parent = (function(me){ return function(){return me;}}(this));
  }
  toJSON() {return window.storage.Generic_toJSON("Foo", this); };
  static fromJSON(value) { return window.storage.Generic_fromJSON(Foo, value.data);};
  setA(a) {   this.a = -1 * a;  };
  print() {console.log(this.a.toString()); this._bar.print(); this._bar2.print();  };
}
*/

/* this should also work instead of reviver
window.gm.testsaveAssign = function () {
  var before = {
    foo: new Foo(21, 44)
  };
  before.foo.print(); // Stringify it with a replacer:
  var str = JSON.stringify(before); // Show that
  console.log(str); // Re-create it with use of a "reviver" function
  var after = window.storage.assignType(str);
  after.foo.print();
};*/

/*assignType: function(object){
    if(object && typeof(object) === 'object' && window[object.__type]) {
        object = window.storage.assignTypeRecursion(object.__type, object);
    }
    return object;
  },
  assignTypeRecursion: function(type, object){
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var obj = object[key];
            if(Array.isArray(obj)){
                 for(var i = 0; i < obj.length; ++i){
                     var arrItem = obj[i];
                     if(arrItem && typeof(arrItem) === 'object' && window[arrItem.__type]) {
                         obj[i] = window.storage.assignTypeRecursion(arrItem.__type, arrItem);
                     }
                 }
            } else  if(obj && typeof(obj) === 'object' && window[obj.__type]) {
                object[key] = window.storage.assignTypeRecursion(obj.__type, obj);
            }
        }
    }
    return Object.assign(new window[type](), object);
  },*/

"use strict";
/* classes to affect...: 
    - the state of a character like     'tired'
    - stats of a character like healthMax
    - 
 */
///////////////////////////////////////////////////////////////


var StatsDictionary = /*#__PURE__*/function (_Inventory2) {
  _inherits(StatsDictionary, _Inventory2);

  var _super4 = _createSuper(StatsDictionary);

  //Todo a collection of Stats is similiar to Inventory?
  function StatsDictionary(externlist) {
    var _this3;

    _classCallCheck(this, StatsDictionary);

    _this3 = _super4.call(this, externlist);
    window.storage.registerConstructor(StatsDictionary);
    return _this3;
  }

  _createClass(StatsDictionary, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("StatsDictionary", this);
    }
  }, {
    key: "get",
    //
    value: function get(id) {
      return this.getItem(id);
    }
  }, {
    key: "modifyHidden",
    value: function modifyHidden(id, hidden) {
      var _data = this.get(id).data;
      _data.hidden = hidden;
    } // adds a modifier to a Stat or replaces it

  }, {
    key: "addModifier",
    value: function addModifier(toId, modData) {
      var _stat = this.get(toId);

      var _oldMods = _stat.data.modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);

      _oldMods.push(modData);

      window.gm.pushLog(_stat.Calc().msg);
    }
  }, {
    key: "removeModifier",
    value: function removeModifier(toId, modData) {
      var _stat = this.get(toId);

      var _oldMods = _stat.data.modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);
      window.gm.pushLog(_stat.Calc().msg);
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Stats: ' + operation + ' ' + id + ' ' + msg + '</br>');
    } //override; only use to create new stats !

  }, {
    key: "addItem",
    value: function addItem(stat) {
      var _i = this.findItemSlot(stat.name);

      if (_i < 0) {
        stat._parent = window.gm.util.refToParent(this);
        this.list.push({
          'id': stat.name,
          'count': 1,
          item: stat
        });
      }
    } //override

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      var _stat = this.get(id);

      this.list.splice(_i, 1);

      _stat.calc(); //trigger update of dependent stat

    }
  }, {
    key: "increment",
    value: function increment(id, value) {
      var attr = this.get(id);
      attr.data.base += value;
      window.gm.pushLog(attr.Calc(this, id).msg);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(StatsDictionary, value.data);

      return _x;
    }
  }]);

  return StatsDictionary;
}(Inventory); //class for an Attribute


var Stat = /*#__PURE__*/function () {
  _createClass(Stat, [{
    key: "parent",
    // Attention !!
    //_parent will be added dynamical
    get: function get() {
      return this._parent();
    } //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};

  }], [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: '',
        base: 0,
        value: 0,
        limits: [],
        modifier: [],
        modifys: [],
        hidden: 0
      }; //limit = {id: min: max:}   limit to apply to value and base
      //modifier {id: calc:}      Stat that modifys value, calc is function(context,data)=> newvalue
      //modifys {id:}         point to the Stats that have modifiers from this stat or is used as limit
      //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
  }]);

  function Stat() {
    _classCallCheck(this, Stat);

    this.data = Stat.dataPrototype();
  }

  _createClass(Stat, [{
    key: "Calc",
    //this is called to update value of the stat and will trigger calculation of dependend stats 
    value: function Calc() {
      var attr = this.data;
      var min = -99999;
      var max = 99999;
      var msg = ''; //get limits

      for (var k = 0; k < attr.limits.length; k++) {
        if (attr.limits[k].min !== '') min = Math.max(this.parent.get(attr.limits[k].min).value, min); //this might behave odly if any min>max

        if (attr.limits[k].max !== '') max = Math.min(this.parent.get(attr.limits[k].max).value, max);
      } //recalculate modifiers


      var _old = attr.value;
      attr.base = attr.value = Math.max(min, Math.min(max, attr.base));

      for (var i = 0; i < attr.modifier.length; i++) {
        attr.value += attr.modifier[i].bonus;
      }

      var _new = Math.max(min, Math.min(max, attr.value));

      attr.value = _new;
      msg += this.formatMsgStatChange(attr, _new, _old); //todo no log hidden

      this.updateModifier(); //trigger recalculation of dependend Stats

      for (var m = 0; m < attr.modifys.length; m++) {
        msg += this.parent.get(attr.modifys[m].id).Calc().msg;
      }

      return {
        OK: true,
        msg: msg
      };
    }
  }, {
    key: "formatMsgStatChange",
    value: function formatMsgStatChange(attr, _new, _old) {
      if (_new - _old > 0) {
        return '<statup>' + attr.id + " regenerated by " + (_new - _old).toFixed(1).toString() + "</statup></br>";
      } else if (_new - _old < 0) {
        return '<statdown>' + attr.id + " decreased by " + (_new - _old).toFixed(1).toString() + "</statdown></br>";
      }

      return "";
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }, {
    key: "name",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "id",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "base",
    get: function get() {
      return this.data.base;
    }
  }, {
    key: "value",
    get: function get() {
      return this.data.value;
    }
  }, {
    key: "hidden",
    get: function get() {
      return this.data.hidden;
    }
  }]);

  return Stat;
}(); /////////////////////////////////////////////////////////////////////////


var Effects = /*#__PURE__*/function (_Inventory3) {
  _inherits(Effects, _Inventory3);

  var _super5 = _createSuper(Effects);

  //Todo a collection of Stats is similiar to Inventory?
  function Effects(externlist) {
    var _this4;

    _classCallCheck(this, Effects);

    _this4 = _super5.call(this, externlist);
    window.storage.registerConstructor(Effects);
    return _this4;
  }

  _createClass(Effects, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Effects", this);
    }
  }, {
    key: "get",
    value: function get(id) {
      return this.getItem(id);
    } //findItemslot uses id, this one finds all effects(-slot) of one type

  }, {
    key: "findEffect",
    value: function findEffect(name) {
      var _items = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].name === name) _items.push(i);
      }

      return _items;
    } //override

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      var _eff = this.get(id);

      this.list.splice(_i, 1);

      _eff.onRemove(this, this.list[_i]);

      this.postItemChange(id, "removed", "");
    }
  }, {
    key: "addItem",
    value: function addItem(id, effect) {
      var _i = this.findItemSlot(id);

      var res; //if effect with same id is already present, merge them

      if (_i > -1) {
        var _old = this.get(effect.id);

        res = _old.merge(effect); //res =window.gm.EffectLib[this.list[_i].name].merge(this,this.list[_i],effect,effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(id, "merged", "");
          return;
        }
      } //or if there are similiar effects try to merge with them


      var _k = this.findEffect(effect.name);

      for (var i = 0; i < _k.length; i++) {
        var _old = this.list[_k];
        res = _old.merge(effect); //res =window.gm.EffectLib[this.list[_k].name].merge(this,this.list[_i],effect,effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(id, "merged", "");
          break;
        }
      } //else add it to list


      this.list.push({
        'id': id,
        'count': 1,
        item: effect
      });
      effect._parent = window.gm.util.refToParent(this);
      effect.onApply();
      this.postItemChange(id, "added", "");
    }
  }, {
    key: "replace",
    value: function replace(id, neweffect) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //Todo do nothing

      var _old = this.get(id);

      _old.onRemove(); //window.gm.EffectLib[this.list[_i].name].onRemove(this,this.list[_i]);


      neweffect._parent = window.gm.util.refToParent(this);
      this.list[_i].item = neweffect;
      neweffect.onApply(this, neweffect);
    }
  }, {
    key: "updateTime",
    value: function updateTime() {
      var now = window.gm.getTime();

      for (var i = 0; i < this.list.length; i++) {
        var _eff = this.list[i].item;

        var foo = _eff.onTimeChange(now);

        if (foo) foo(this);
      }
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Effects: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Effects, value.data);

      return _x;
    }
  }]);

  return Effects;
}(Inventory); //


var Effect = /*#__PURE__*/function () {
  function Effect() {
    _classCallCheck(this, Effect);

    this.data = Effect.dataPrototype();
    this.data.time = window.gm.getTime();
  }

  _createClass(Effect, [{
    key: "merge",
    //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};
    //is called when a effect is applied to check if the new effect can be combined with an exisitng one
    //return null if no merge occured
    //return true if the neweffect was merged into existing one; no other effects are then checked for mergeability
    //or return function that has to be executed: (function(Effects){ Effects.replace(data.id,NotTired);}));
    value: function merge(neweffect) {
      return null;
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {}
  }, {
    key: "onRemove",
    value: function onRemove() {}
  }, {
    key: "parent",
    // Attention !!
    //_parent will be added dynamical
    get: function get() {
      return this._parent();
    }
  }, {
    key: "id",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "name",
    get: function get() {
      return this.data.name;
    }
  }, {
    key: "time",
    get: function get() {
      return this.data.time;
    }
  }, {
    key: "duration",
    get: function get() {
      return this.data.duration;
    }
  }, {
    key: "hidden",
    get: function get() {
      return this.data.hidden;
    }
  }, {
    key: "shortDesc",
    get: function get() {
      return '';
    }
  }], [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: 'xxx',
        name: Effect.name,
        time: 0,
        duration: 0,
        hidden: 0
      }; //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
  }]);

  return Effect;
}(); //combat effect use turn-count instead of realtime as duration


var CombatEffect = /*#__PURE__*/function (_Effect) {
  _inherits(CombatEffect, _Effect);

  var _super6 = _createSuper(CombatEffect);

  function CombatEffect() {
    _classCallCheck(this, CombatEffect);

    return _super6.call(this);
  }

  _createClass(CombatEffect, [{
    key: "shortDesc",
    get: function get() {
      return 'missing description';
    } //duration in turns !

  }], [{
    key: "onCombatEnd",
    value: function onCombatEnd(context, data) {} //called before targets turn

  }, {
    key: "onTurnStart",
    value: function onTurnStart(context, data) {} //at end of targets turn

  }, {
    key: "onTurnEnd",
    value: function onTurnEnd(context, data) {}
  }]);

  return CombatEffect;
}(Effect);
/*! Toasty.js - v1.5.0 - 2018-05-04
* https://jakim.me/Toasty.js/
* Copyright (c) 2015-2018 Jakim Hernández; Licensed MIT */


;

(function () {
  'use strict';
  /**
   * All available default CSS transitions for plug-in:
   *
   * @var array
   */

  var _transitions = ["fade", "slideLeftFade", "slideLeftRightFade", "slideRightFade", "slideRightLeftFade", "slideUpFade", "slideUpDownFade", "slideDownFade", "slideDownUpFade", "pinItUp", "pinItDown"];
  /**
   * Default configuration for plug-in:
   *
   * @var object
   */

  var _defaults = {
    // STRING: main class name used to styling each toast message with CSS:
    // .... IMPORTANT NOTE:
    // .... if you change this, the configuration consider that you´re
    // .... re-stylized the plug-in and default toast styles, including CSS3 transitions are lost.
    classname: "toast",
    // STRING: name of the CSS transition that will be used to show and hide all toast by default:
    transition: "fade",
    // BOOLEAN: specifies the way in which the toasts will be inserted in the HTML code:
    // .... Set to BOOLEAN TRUE and the toast messages will be inserted before those already generated toasts.
    // .... Set to BOOLEAN FALSE otherwise.
    insertBefore: true,
    // INTEGER: duration that the toast will be displayed in milliseconds:
    // .... Default value is set to 4000 (4 seconds). 
    // .... If it set to 0, the duration for each toast is calculated by text-message length.
    duration: 4000,
    // BOOLEAN: enable or disable toast sounds:
    // .... Set to BOOLEAN TRUE  - to enable toast sounds.
    // .... Set to BOOLEAN FALSE - otherwise.
    // NOTE: this is not supported by mobile devices.
    enableSounds: false,
    // BOOLEAN: enable or disable auto hiding on toast messages:
    // .... Set to BOOLEAN TRUE  - to enable auto hiding.
    // .... Set to BOOLEAN FALSE - disable auto hiding. Instead the user must click on toast message to close it.
    autoClose: true,
    // BOOLEAN: enable or disable the progressbar:
    // .... Set to BOOLEAN TRUE  - enable the progressbar only if the autoClose option value is set to BOOLEAN TRUE.
    // .... Set to BOOLEAN FALSE - disable the progressbar. 
    progressBar: false,
    // IMPORTANT: mobile browsers does not support this feature!
    // Yep, support custom sounds for each toast message when are shown if the
    // enableSounds option value is set to BOOLEAN TRUE:
    // NOTE: the paths must point from the project's root folder.
    sounds: {
      // path to sound for informational message:
      info: "./dist/sounds/info/1.mp3",
      // path to sound for successfull message:
      success: "./dist/sounds/success/1.mp3",
      // path to sound for warn message:
      warning: "./dist/sounds/warning/1.mp3",
      // path to sound for error message:
      error: "./dist/sounds/error/1.mp3"
    },
    // callback:
    // onShow function will be fired when a toast message appears.
    onShow: function onShow(type) {},
    // callback:
    // onHide function will be fired when a toast message disappears.
    onHide: function onHide(type) {},
    // the placement where prepend the toast container:
    prependTo: document.body.childNodes[0]
  };
  /**
   * Map to create each necessary CSS classess:
   *
   * @var object
   */

  var _mappings = {
    container: "{:class-name}-container",
    mainwrapp: "{:class-name}-wrapper",
    toasts: {
      info: "{:class-name}--info",
      success: "{:class-name}--success",
      warning: "{:class-name}--warning",
      error: "{:class-name}--error"
    },
    animate: {
      init: "{:transition}-init",
      show: "{:transition}-show",
      hide: "{:transition}-hide"
    },
    progressbar: "{:class-name}-progressbar",
    playerclass: "{:class-name}-soundplayer"
  };
  /**
   * A time offset to define the plug-in behavior:
   *
   * @var object
   */

  var _timeOffset = 100;
  /**
   * A native JS extend() function
   *
   * Returns a new object instead, preserving all of the original objects
   * and their properties. Supported back to IE6.
   *
   * All credits to author.
   * https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
   *
   * @return object
   */

  function extend() {
    var extended = {};
    var deep = false;
    var i = 0;
    var length = arguments.length; // check if a deep merge

    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
      deep = arguments[0];
      i++;
    } // merge the object into the extended object


    var merge = function merge(obj) {
      for (var prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {
          // if deep merge and property is an object, merge properties
          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') extended[prop] = extend(true, extended[prop], obj[prop]);else extended[prop] = obj[prop];
        }
      }
    }; // loop through each object and conduct a merge


    for (i; i < length; i++) {
      var obj = arguments[i];
      merge(obj);
    }

    return extended;
  }
  /**
   * Simple creation of an Element Node with the specified 'name'.
   *
   * @return HTML Element
   */


  function node(name) {
    return document.createElement(name || 'div');
  }
  /**
   * Returns the parent Element or Node from any other HTML Element.
   *
   * @return HTML Element
   */


  function parentElement(el) {
    return el.parentElement || el.parentNode;
  }
  /**
   * Regexp to find a className on a string.
   *
   * @return RegExp Obj
   */


  function classReg(className) {
    return new RegExp('(^|\\s+)' + className + '(\\s+|$)');
  }
  /**
   * Returns a Boolean value, indicating whether an element has
   * the specified class name.
   * 
   * Usage:
   *
   * var exists = containsClass(element, 'className');
   * 
   * @return bool
   */


  function containsClass(el, className) {
    var fn;

    if (document.documentElement.classList) {
      fn = function fn(el, className) {
        return el.classList.contains(className);
      };
    } else {
      fn = function fn(el, className) {
        if (!el || !el.className) return false;
        return el.className.match(classReg(className));
      };
    }

    return fn(el, className);
  }
  /**
   * Adds one or more class names to an element.
   * If the specified class already exist, the class will not be added.
   *
   * Usage:
   *
   * addClass(el, 'class1', 'class2', 'class3', ...);
   *
   * @return HTML Element|bool false
   */


  function addClass(el) {
    var fn;
    var classNames = arguments;
    if (classNames.length <= 1 || _typeof(el) != 'object') return false;
    if (document.documentElement.classList) fn = function fn(el, classNames) {
      for (var i = 1; i < classNames.length; i++) {
        if (typeof classNames[i] == 'string') {
          el.classList.add(classNames[i]);
        }
      }

      return el;
    };else fn = function fn(el, classNames) {
      for (var i = 1; i < classNames.length; i++) {
        if (!containsClass(el, classNames[i]) && typeof classNames[i] == 'string') {
          el.className += (el.className ? ' ' : '') + classNames[i];
        }
      }

      return el;
    };
    return fn(el, classNames);
  }
  /**
   * Removes one or more class names from an element.
   * Note: Removing a class that does not exist, does NOT throw an error.
   *
   * Usage:
   *
   * removeClass(el, 'class1', 'class2', 'class3', ...);
   *
   * @return HTML Element|bool false
   */


  function removeClass(el) {
    var fn;
    var classNames = arguments;
    if (classNames.length <= 1 || _typeof(el) != 'object') return false;
    if (document.documentElement.classList) fn = function fn(el, classNames) {
      for (var i = 1; i < classNames.length; i++) {
        if (typeof classNames[i] == 'string') {
          el.classList.remove(classNames[i]);
        }
      }

      return el;
    };else fn = function fn(el, classNames) {
      for (var i = 1; i < classNames.length; i++) {
        if (containsClass(el, classNames[i]) && typeof classNames[i] == 'string') {
          el.className = el.className.replace(classReg(classNames[i]), '$2');
        }
      }

      return el;
    };
    return fn(el, classNames);
  }
  /**
   * Toggles between a class name for an element.
   * 
   * Usage:
   *
   * var result = toggleClass(el, 'className');
   *
   * @return bool
   */


  function toggleClass(el, className) {
    var fn;
    if (document.documentElement.classList) fn = function fn(el, className) {
      return el.classList.toggle(className);
    };else fn = function fn(el, className) {
      var exists = containsClass(el, className);
      var caller = exists === true ? removeClass : addClass;
      caller(el, className);
      return !exists;
    };
    return fn(el, className);
  }
  /**
   * Add Event
   *
   * Attaches an event handler to the document.
   *
   * http://www.thecssninja.com/javascript/handleevent
   *
   * @param  {element}  element
   * @param  {event}    event
   * @param  {Function} fn
   * @param  {boolean}  bubbling
   * @return el
   */


  function addEvent(el, evt, fn, bubble) {
    if ('addEventListener' in el) {
      // BBOS6 doesn't support handleEvent, catch and polyfill:
      try {
        el.addEventListener(evt, fn, bubble);
      } catch (e) {
        if (_typeof(fn) === 'object' && fn.handleEvent) {
          el.addEventListener(evt, function (e) {
            // bind fn as this and set first arg as event object:
            fn.handleEvent.call(fn, e);
          }, bubble);
        } else {
          throw e;
        }
      }
    } else if ('attachEvent' in el) {
      // check if the callback is an object and contains handleEvent:
      if (_typeof(fn) === 'object' && fn.handleEvent) {
        el.attachEvent('on' + evt, function () {
          // bind fn as this:
          fn.handleEvent.call(fn);
        });
      } else {
        el.attachEvent('on' + evt, fn);
      }
    }

    return el;
  }
  /**
   * Remove Event
   *
   * Removes an event handler that has been attached with the 'addEvent' method.
   *
   * http://www.thecssninja.com/javascript/handleevent
   *
   * @param  {element}  element
   * @param  {event}    event
   * @param  {Function} fn
   * @param  {boolean}  bubbling
   * @return el
   */


  function removeEvent(el, evt, fn, bubble) {
    if ('removeEventListener' in el) {
      try {
        el.removeEventListener(evt, fn, bubble);
      } catch (e) {
        if (_typeof(fn) === 'object' && fn.handleEvent) {
          el.removeEventListener(evt, function (e) {
            fn.handleEvent.call(fn, e);
          }, bubble);
        } else {
          throw e;
        }
      }
    } else if ('detachEvent' in el) {
      if (_typeof(fn) === 'object' && fn.handleEvent) {
        el.detachEvent('on' + evt, function () {
          fn.handleEvent.call(fn);
        });
      } else {
        el.detachEvent('on' + evt, fn);
      }
    }

    return el;
  }
  /**
   * Detect the property name of supported transition event.
   * 
   * Function from David Walsh:
   * http://davidwalsh.name/css-animation-callback
   *
   * @return string|undefined (if transitions not supported by client)
   */


  function whichTransitionEvent() {
    var t,
        el = node('transitionElement');
    var transitions = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    };

    for (t in transitions) {
      if (el.style[t] !== undefined) {
        return transitions[t];
      }
    }
  }
  /**
   * Calculates the auto close duration to be set in
   * each toast message:
   * 
   * @return number
   */


  function getAutoCloseDuration(message, duration, settings) {
    duration = duration || settings.duration;
    if (duration == 0) duration = message.length * (_timeOffset / 2);
    return Math.floor(duration);
  }
  /**
   * Replace each object values with a map of key => values:
   *
   * @return object
   */


  function walker(obj, map) {
    for (var o in obj) {
      if (obj.hasOwnProperty(o) === true) {
        // ini loop:
        switch (_typeof(obj[o])) {
          case 'object':
            walker(obj[o], map);
            break;

          case 'string':
            for (var m in map) {
              if (map.hasOwnProperty(m) === true) {
                obj[o] = obj[o].replace(m, map[m]);
              }
            }

            break;
        } // end loop.

      }
    }

    return obj;
  }
  /**
   * Generate an HTML audio instance for each type of
   * toast message:
   *
   * @return void
   */


  var playSound = function playSound(type, container, sounds, playerclass) {
    var sound = sounds[type],
        audio = addClass(node('audio'), playerclass);
    addEvent(audio, 'ended', function () {
      var parent = parentElement(this);
      this.remove(); // also, remove the main container if it empty:

      if (parent.childNodes.length < 1) parentElement(parent).remove();
    });
    audio.setAttribute('autoplay', 'autoplay');
    audio.innerHTML = '<source src="' + sound + '" type="audio/mpeg"/>' + '<embed hidden="true" autoplay="false" loop="false" src="' + sound + '" />';
    parentElement(container).appendChild(audio);
  };
  /**
   * Show the toast message with an CSS3 transition
   * if transition event is supported:
   *
   * @return void
   */


  var showToast = function showToast(type, el, container, animate, duration, insertBefore, callback) {
    var timer = 0;

    var delay = function delay(callback, ms) {
      clearTimeout(timer);
      timer = setTimeout(callback, ms);
    };

    var onShowToast = function onShowToast(e) {
      removeEvent(e.target, e.type, onShowToast, false);
      if (typeof callback == 'function') callback(type);
    };

    var show = function show() {
      var transitionEvent = whichTransitionEvent();

      if (transitionEvent !== undefined) {
        // initialize the CSS transition event:
        addEvent(el, transitionEvent, onShowToast, false);
      } else {
        // navigator does not support transition events:
        if (typeof callback == 'function') callback(type);
      }

      addClass(el, animate.show);
    }; // insert in the DOM and show toast:


    var beforeNode = container.childNodes;
    beforeNode = beforeNode[insertBefore === true ? 0 : beforeNode.length];
    container.insertBefore(el, beforeNode);
    delay(show, _timeOffset);
  };
  /**
   * Hide the toast message with an CSS3 transition
   * if transition event is supported:
   *
   * @return void
   */


  var hideToast = function hideToast(type, el, duration, animate, callback) {
    var timer = 0;

    var delay = function delay(callback, ms) {
      clearTimeout(timer);
      timer = setTimeout(callback, ms);
    };

    var onHideToast = function onHideToast(e) {
      removeEvent(e.target, e.type, onHideToast, false);
      remove();
      if (typeof callback == 'function') callback(type);
    };

    var remove = function remove() {
      var container = parentElement(el); // the wrapper.

      el.remove();
      var num = container.childNodes.length;

      if (num < 1) {
        parentElement(container).remove();
      }
    };

    var hide = function hide() {
      var transitionEvent = whichTransitionEvent();

      if (transitionEvent !== undefined) {
        // initialize the CSS transition event:
        addEvent(el, transitionEvent, onHideToast, false);
      } else {
        // navigator does not support transition events:
        remove();
        if (typeof callback == 'function') callback(type);
      }

      addClass(el, animate.hide);
    };

    delay(hide, _timeOffset * 10 + duration);
  };
  /**
   * Hide the toast message with an CSS3 transition when
   * the user clicks on the message:
   *
   * @return void
   */


  var hideToastOnClick = function hideToastOnClick(type, el, animate, callback, class2close) {
    var hideOnClick = function hideOnClick(e) {
      e.stopPropagation();
      removeClass(el, class2close);
      hideToast(type, el, 0, animate, callback);
    };

    addClass(el, class2close);
    addEvent(el, 'click', hideOnClick);
  };
  /**
   * The progressbar:
   *
   * @return void
   */


  var showProgressBar = function showProgressBar(type, el, duration, transition) {
    var timer = 0;

    var delay = function delay(callback, ms) {
      clearTimeout(timer);
      timer = setTimeout(callback, ms);
    };

    var progressbar = function progressbar() {
      var progressBar = addClass(node('div'), transition.progressbar, transition.progressbar + '--' + type);
      el.appendChild(progressBar);
      var iterat = 0,
          offset = 0;
      var interval = setInterval(function () {
        iterat++;
        offset = Math.round(1000 * iterat / duration);

        if (offset > 100) {
          clearInterval(interval);
        } else {
          progressBar.style.width = offset + '%';
        }
      }, 10);
    };

    delay(progressbar, _timeOffset * 10);
  };
  /**
   * Register a new transition only:
   *
   * @return string
   */


  var registerTransition = function registerTransition(self, name) {
    if (typeof name === "string") {
      self.classmap[name] = extend(true, _mappings, {});
      self.classmap[name] = walker(self.classmap[name], {
        '{:class-name}': self.settings.classname,
        '{:transition}': name
      });
    }

    return name;
  };
  /*!
   * The exposed public object:
   */


  var Toasty = function Toasty(options) {
    this.settings = {};
    this.classmap = {};
    this.configure(_typeof(options) === 'object' ? options : {}); // add classmap for default transitions:

    if (_typeof(_transitions) === 'object') for (var key in _transitions) {
      if (_transitions.hasOwnProperty(key) === true) {
        registerTransition(this, _transitions[key]);
      }
    }
  };

  Toasty.prototype.configure = function (options) {
    this.settings = extend(true, _defaults, this.settings, options);
    return this;
  };

  Toasty.prototype.transition = function (name) {
    this.settings.transition = registerTransition(this, name);
    return this;
  };

  Toasty.prototype.toast = function (type, message, duration) {
    var classes = this.classmap;
    var options = this.settings; // check if the transition name provided in options
    // exists in classes, if not register it:

    if (classes.hasOwnProperty(options.transition) === false) registerTransition(this, options.transition); // use the transition name provided in options:

    var transition = classes[options.transition]; // check if the toast container exists:

    var container = null;
    if (typeof options.transition === 'string') container = document.querySelector('.' + transition.container + '--' + options.transition);else container = document.querySelector('.' + transition.container);
    var containerExists = !!container;

    if (containerExists) {
      // create the toast container if not exists:
      container = container.querySelector('.' + transition.mainwrapp); // use the wrapper instead of main container.
    } else {
      container = addClass(node('div'), transition.container, transition.container + '--' + options.transition); // create a alert wrapper instance:

      var wrapp = addClass(node('div'), transition.mainwrapp); // append the alert wrapper and now, this is the main container:

      container.appendChild(container = wrapp);
    } // create a new toast instance


    var newToast = addClass(node('div'), options.classname, transition.toasts[type], transition.animate.init);
    newToast.innerHTML = message; // insert the toast container into the HTML:

    if (!containerExists) document.body.insertBefore(parentElement(container), options.prependTo); // OPTIONAL STEP (must be first):
    // INI: enable or disable toast sounds.
    // --------------------------------------------------------------------

    if (options.enableSounds == true) playSound(type, container, options.sounds, transition.playerclass); // --------------------------------------------------------------------
    // END: enable or disable toast sounds.
    // STEP 1:
    // INI: showing the toas message
    // --------------------------------------------------------------------

    showToast(type, newToast, container, transition.animate, duration, options.insertBefore, options.onShow); // --------------------------------------------------------------------
    // END: showing the toas message
    // STEP 2:
    // INI: prepare the toast to hide it.
    // --------------------------------------------------------------------

    if (options.autoClose == true) // hide the toast message automatically:
      hideToast(type, newToast, duration, transition.animate, options.onHide);else // hide the toast message on click it with an CSS3 transition:
      hideToastOnClick(type, newToast, transition.animate, options.onHide, 'close-on-click'); // --------------------------------------------------------------------
    // END: prepare the toast to hide it.
    // OPTIONAL STEP (must be last):
    // INI: Enable or disable the progressbar.
    // --------------------------------------------------------------------

    if (options.progressBar == true && options.autoClose == true) showProgressBar(type, newToast, duration, transition); // --------------------------------------------------------------------
    // END: Enable or disable the progressbar.

    return this;
  };

  Toasty.prototype.info = function (message, duration) {
    duration = getAutoCloseDuration(message, duration, this.settings);
    this.toast("info", message, duration);
  };

  Toasty.prototype.success = function (message, duration) {
    duration = getAutoCloseDuration(message, duration, this.settings);
    this.toast("success", message, duration);
  };

  Toasty.prototype.warning = function (message, duration) {
    duration = getAutoCloseDuration(message, duration, this.settings);
    this.toast("warning", message, duration);
  };

  Toasty.prototype.error = function (message, duration) {
    duration = getAutoCloseDuration(message, duration, this.settings);
    this.toast("error", message, duration);
  }; // FALLBACK:
  // Create Element.remove() function if not exist:


  if ('remove' in Element.prototype) {// the browser supports .remove() function...
  } else {
    Element.prototype.remove = function () {
      if (this.parentNode) this.parentNode.removeChild(this);
    };
  }

  window.Toasty = Toasty;
})(window, document);

"use strict";
/* bundles some utility operations*/


window.gm.getSaveVersion = function () {
  var version = [0, 1, 0];
  return version;
}; // reimplement to setup the game


window.gm.initGame = function (forceReset) {
  var NGP = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  //var toast = new Toasty();
  //toast.info("Here is some information!");
  //this does not work because hidden is called to late

  /*$(window).on('sm.passage.hidden', function(event, eventObject) {
    
    if(eventObject.passage) {// No passage to hide when story starts
        console.log('hiding'+eventObject.passage.name);        
    }
  });*/
  $(window).on('sm.passage.showing', function (event, eventObject) {
    // Current Passage object
    $("tw-passage").fadeIn(500); //fade in if was previously faded out

    console.log('showing ' + eventObject.passage.name);
  }); // Render the passage named HUD into the element todo replace with <%=%>??

  $(document).on('sm.passage.shown', function (ev, eventObject) {
    window.gm.updateOtherPanels();
  });
  var s = window.story.state; //s in template is window.story.state from snowman!

  if (!s.vars || forceReset) {
    var _s$vars;

    // storage of variables that doesnt fit player
    s.vars = (_s$vars = {
      debug: true,
      //TODO set to 0 for distribution !   see debug passage for meaning
      dbgShowCombatRoll: false,
      version: window.gm.getSaveVersion(),
      log: [],
      passageStack: [],
      //used for passage [back] functionality
      defferedStack: [],
      //used for deffered events
      time: 700,
      //represented as hours*100 +minutes
      day: 1,
      activePlayer: 'Ratchel',
      //id of the character that the player controls currently
      //queststates
      qLaptop: 0,
      // see passage _Laptop_
      qDogSit: 0,
      // see park
      qUnlockCampus: 0,
      //see passage into city
      qUnlockPark: 0,
      qUnlockMall: 0,
      qUnlockBeach: 0,
      qUnlockDowntown: 0,
      qUnlockRedlight: 0
    }, _defineProperty(_s$vars, "qUnlockBeach", 0), _defineProperty(_s$vars, "hairGrow", 0), _defineProperty(_s$vars, "crowBarLeft", 1), _defineProperty(_s$vars, "debugInv", new Inventory()), _s$vars);
    s.vars.debugInv._parent = window.gm.util.refToParent(null);
    s.vars.debugInv.addItem(new Money(), 200);
  }

  if (!s.tmp || forceReset) {
    // storage of temporary variables; dont use them in stacking passages or deffered events      
    s.tmp = {
      rnd: 0,
      // can be used as a random variable for use in CURRENT passage
      args: [] // can be used to set arguments before another passage is called (passage-arguments) 

    };
  }

  if (!window.gm.achievements || forceReset) {
    //outside of window.story !
    window.gm.achievements = {
      moleKillerGoldMedal: false //add your flags here

    };
    window.storage.loadAchivementsFromBrowser();
  }

  if (!s.enemy || forceReset) {
    //actual/last enemy
    s.enemy = new Character();
  }

  if (!s.combat || forceReset) {
    //see encounter & combat.js
    s.combat = {
      newTurn: false,
      enemyFirst: false,
      //if true, enemy moves first
      enemyTurn: false,
      //true if enemys turn
      state: "",
      //internal state
      playerFleeing: false,
      playerSubmitting: false,
      turnCount: 0,
      scenePic: 'assets/bg_park.png'
    };
  }

  if (!s.mom || forceReset) {
    s.mom = {
      location: "Kitchen",
      coffeeStore: 5,
      foodStore: 3,
      foodMaxStore: 4
    };
  }

  if (!s.Cyril || forceReset) {
    //alternative player character
    window.gm.Cyril = new Character();
    window.gm.Cyril.name = "Cyril"; //add some basic inventory

    window.gm.Cyril.Wardrobe.addItem(new Jeans());
    window.gm.Cyril.Wardrobe.addItem(new TankShirt());
    window.gm.Cyril.Outfit.addItem(new Jeans());
    window.gm.Cyril.Outfit.addItem(new TankShirt());
    window.gm.Cyril.Stats.increment('strength', 3);
    s.Cyril = window.gm.Cyril; //delete window.gm.Cyril; 
  }

  if (!s.Ratchel || forceReset) {
    /*s.Ratchel = Character.defaultData(); //get default struct and add some special data
    s.Ratchel.name = 'Ratchel',
    s.Ratchel.skillPoints = 2,    //no. of free skillpoints on game-start  
    s.Ratchel.skSporty = 0,//perklevels ,name should match perkId
    s.Ratchel.skCook = 0,
    s.Ratchel.skSlacker = 0,
    s.Ratchel.skMoneymaker = 0,
    s.Ratchel.skTechy = 0;*/
    //window.gm.Ratchel = new Character(s.Ratchel);
    window.gm.Ratchel = new Character();
    window.gm.Ratchel.name = "Ratchel";
    window.gm.Ratchel.gainRelation('Mom', 10);
    window.gm.Ratchel.Effects.addItem(skCooking.name, new skCooking()); //add some basic inventory

    window.gm.Ratchel.Inv.addItem(new Money(), 20);
    window.gm.Ratchel.Inv.addItem(new LighterDad());
    window.gm.Ratchel.Wardrobe.addItem(new Jeans());
    window.gm.Ratchel.Wardrobe.addItem(new Leggings());
    window.gm.Ratchel.Wardrobe.addItem(new TankShirt());
    window.gm.Ratchel.Wardrobe.addItem(new Pullover());
    window.gm.Ratchel.Wardrobe.addItem(new TailRibbon()); //window.gm.Ratchel.Outfit.addItem(new TailCat());

    window.gm.Ratchel.Outfit.addItem(new Jeans());
    window.gm.Ratchel.Outfit.addItem(new Pullover());
    s.Ratchel = window.gm.Ratchel;
  }

  window.gm.switchPlayer(s.Ratchel.name); //start-player

  if (NGP) {
    window.story.state.vars.crowBarLeft = NGP.crowBarLeft;
  }

  NGP = null; //release memory
}; // lookup function for scene background


window.gm.getScenePic = function (id) {
  if (id === 'Garden' || id === 'Park') return 'assets/bg_park.png';
  return 'assets/bg_park.png'; //todo placehodler
};

window.gm.giveCyrilFood = function () {
  if (window.gm.player.Inv.countItem('SimpleFood') > 0) {
    var res = window.gm.player.Inv.use('SimpleFood', window.story.state.Cyril);
    window.gm.printOutput(res.msg);
  } else {
    window.gm.printOutput("you have no food to spare");
  }
}; //prints a list of todo quest


window.gm.printTodoList = function () {
  var elmt = '<form><ul style=\"list-style-type: none\" >';
  var s = window.story.state;
  var list = ['qDogSit'];
  elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>always: keep the fridge filled</label></li>";

  for (var i = 0; i < list.length; i++) {
    var val = s.vars[list[i]];
    var msg = '';

    if (list[i] === 'qDogSit') {
      //todo we could use <%=> instead
      if (val <= 0) {} else if (val <= 0x100) {
        msg = 'There was this dogsit-ad in the park. Maybe you should call there to earn some money.';
      } else if (val <= 0x200) {
        msg = 'You called dogsit but didnt get a response...';
      } else if (val <= 0x300) {
        msg = 'Get a task from dogsit!';
      }
    }

    if (msg != '') elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>" + msg + "</label></li>";
  }

  elmt += "</ul></form></br>";
  return elmt;
}; //prints a list of perks for unlock


window.gm.printUnlockPerk = function (id, descr) {
  var elmt = '';
  var s = window.story.state;

  if (window.gm.player[id] == 0 && window.gm.player.skillPoints > 0) {
    elmt += ''.concat("<a0 id='" + id + "' onclick='(function ( $event ) { unlockPerk($event.id); })(this);'>" + descr + "</a>");
    elmt += ''.concat("    [[Info|" + id + "]]");
  } else if (window.gm.player[id] > 0) {
    elmt += id + ": " + descr;
  }

  elmt += ''.concat("</br>");
  return elmt;
};

"use strict";

var LighterDad = /*#__PURE__*/function (_Item2) {
  _inherits(LighterDad, _Item2);

  var _super7 = _createSuper(LighterDad);

  function LighterDad() {
    var _this5;

    _classCallCheck(this, LighterDad);

    _this5 = _super7.call(this, 'LighterDad');
    _this5.desc = 'I got this lighter from my real dad.';
    return _this5;
  }

  _createClass(LighterDad, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("LighterDad", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(LighterDad, value.data);
    }
  }]);

  return LighterDad;
}(Item);

;

var Money = /*#__PURE__*/function (_Item3) {
  _inherits(Money, _Item3);

  var _super8 = _createSuper(Money);

  function Money() {
    var _this6;

    _classCallCheck(this, Money);

    _this6 = _super8.call(this, 'Money');
    _this6.desc = 'shiny,clinky coin.';
    return _this6;
  }

  _createClass(Money, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Money", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Money, value.data);
    }
  }]);

  return Money;
}(Item);

;

var LaptopPS = /*#__PURE__*/function (_Item4) {
  _inherits(LaptopPS, _Item4);

  var _super9 = _createSuper(LaptopPS);

  function LaptopPS() {
    var _this7;

    _classCallCheck(this, LaptopPS);

    _this7 = _super9.call(this, 'Laptop-PS');
    _this7.desc = 'Power converter for laptop.';
    return _this7;
  }

  _createClass(LaptopPS, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("LaptopPS", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(LaptopPS, value.data);
    }
  }]);

  return LaptopPS;
}(Item);

;

var Dildo_small = /*#__PURE__*/function (_Item5) {
  _inherits(Dildo_small, _Item5);

  var _super10 = _createSuper(Dildo_small);

  function Dildo_small() {
    var _this8;

    _classCallCheck(this, Dildo_small);

    _this8 = _super10.call(this, 'Dildo_small');
    _this8.desc = 'A dildo, smaller than an average dong, made from rubbery plastic.';
    return _this8;
  }

  _createClass(Dildo_small, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Dildo_small", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Dildo_small, value.data);
    }
  }]);

  return Dildo_small;
}(Item);

;

var Lube = /*#__PURE__*/function (_Item6) {
  _inherits(Lube, _Item6);

  var _super11 = _createSuper(Lube);

  function Lube() {
    var _this9;

    _classCallCheck(this, Lube);

    _this9 = _super11.call(this, 'Lube');
    _this9.desc = 'Slippery lubricant for personal use.';
    return _this9;
  }

  _createClass(Lube, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Lube", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Lube, value.data);
    }
  }]);

  return Lube;
}(Item);

;

var Battery = /*#__PURE__*/function (_Item7) {
  _inherits(Battery, _Item7);

  var _super12 = _createSuper(Battery);

  function Battery() {
    var _this10;

    _classCallCheck(this, Battery);

    _this10 = _super12.call(this, 'Battery');
    _this10.desc = 'Provides electricity for devices.';
    return _this10;
  }

  _createClass(Battery, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Battery", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Battery, value.data);
    }
  }]);

  return Battery;
}(Item);

;

var CanOfCoffee = /*#__PURE__*/function (_Item8) {
  _inherits(CanOfCoffee, _Item8);

  var _super13 = _createSuper(CanOfCoffee);

  function CanOfCoffee() {
    var _this11;

    _classCallCheck(this, CanOfCoffee);

    _this11 = _super13.call(this, 'Can of coffee');
    _this11.desc = 'Cold coffee in a can. Tasty? Not really!';
    return _this11;
  }

  _createClass(CanOfCoffee, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("CanOfCoffee", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return {
        OK: true,
        msg: 'drink'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      if (context instanceof Inventory) {
        context.removeItem('CanOfCoffee');

        if (context.parent instanceof Character) {
          context.parent.addEffect('CanOfCoffee:Energized', new effEnergized()); //apply over-time-effect instead directly changing stat

          return {
            OK: true,
            msg: context.parent.name + ' gulped down a can of iced coffee.'
          };
        }
      } else throw new Error('context is invalid');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(CanOfCoffee, value.data);
    }
  }]);

  return CanOfCoffee;
}(Item);

;

var SimpleFood = /*#__PURE__*/function (_Item9) {
  _inherits(SimpleFood, _Item9);

  var _super14 = _createSuper(SimpleFood);

  function SimpleFood() {
    var _this12;

    _classCallCheck(this, SimpleFood);

    _this12 = _super14.call(this, 'SimpleFood');
    _this12.desc = 'Something to eat.';
    return _this12;
  }

  _createClass(SimpleFood, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("SimpleFood", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        OK: true,
        msg: 'eat'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var _gaveAway = false;

      if (context instanceof Inventory) {
        if (on === null) on = context.parent;else _gaveAway = true;
        context.removeItem('Simple food');

        if (on instanceof Character) {
          on.addEffect('Simple food:Energized', new effEnergized());
          return {
            OK: true,
            msg: on.name + ' ate some plain foods.'
          };
        }
      } else throw new Error('context is invalid');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(SimpleFood, value.data);
    }
  }]);

  return SimpleFood;
}(Item);

window.gm.ItemsLib = function (ItemsLib) {
  // Private Objekte

  /*var privateVariable = "privat";
  function privateFunktion () {
      alert("privateFunktion wurde aufgerufen\n" +
          "Private Variable: " + privateVariable);
  }*/
  window.storage.registerConstructor(LighterDad);
  window.storage.registerConstructor(Money);
  window.storage.registerConstructor(LaptopPS);
  window.storage.registerConstructor(Battery);
  window.storage.registerConstructor(Dildo_small);
  window.storage.registerConstructor(Lube);
  window.storage.registerConstructor(CanOfCoffee);
  window.storage.registerConstructor(SimpleFood);

  ItemsLib['Money'] = function () {
    return new Money();
  };

  ItemsLib['LighterDad'] = function () {
    return new LighterDad();
  };

  ItemsLib['LaptopPS'] = function () {
    return new LaptopPS();
  };

  ItemsLib['Battery'] = function () {
    return new Battery();
  };

  ItemsLib['Dildo_small'] = function () {
    return new Dildo_small();
  }; // consumables


  ItemsLib['Lube'] = function () {
    return new Lube();
  };

  ItemsLib['CanOfCoffee'] = function () {
    return new CanOfCoffee();
  };

  ItemsLib['SimpleFood'] = function () {
    return new SimpleFood();
  };

  return ItemsLib;
}(window.gm.ItemsLib || {});

"use strict";

var Mole = /*#__PURE__*/function (_Mob) {
  _inherits(Mole, _Mob);

  var _super15 = _createSuper(Mole);

  function Mole() {
    var _this13;

    _classCallCheck(this, Mole);

    _this13 = _super15.call(this);
    _this13.name = 'Mole';
    _this13.pic = 'assets/mole.jpg';

    _this13.Stats.increment('healthMax', -1 * (_this13.health().max - 20));

    return _this13;
  }

  return Mole;
}(Mob);

;

var Mechanic = /*#__PURE__*/function (_Mob2) {
  _inherits(Mechanic, _Mob2);

  var _super16 = _createSuper(Mechanic);

  function Mechanic() {
    var _this14;

    _classCallCheck(this, Mechanic);

    _this14 = _super16.call(this);
    _this14.name = 'Mechanic-Guy';
    _this14.pic = 'assets/mechanic.jpg';
    return _this14;
  }

  _createClass(Mechanic, [{
    key: "calcCombatMove",
    value: function calcCombatMove() {
      var result = this._canAct();

      if (window.story.state.combat.turnCount < 3) {
        result = window.gm.Encounter.execCombatCmd(window.gm.combat.moveStun);
        result.msg = this.name + " trys to hit your head whith his wrench.</br>" + result.msg;
        return result;
      }

      return _get(_getPrototypeOf(Mechanic.prototype), "calcCombatMove", this).call(this);
    }
  }]);

  return Mechanic;
}(Mob);

; //this looks weird but works; use this as template how to add more mobs

window.gm.Mobs = function (Mobs) {
  // Private Objekte

  /*var privateVariable = "privat";
  function privateFunktion () {
      alert("privateFunktion wurde aufgerufen\n" +
          "Private Variable: " + privateVariable);
  }*/
  Mobs.Mole = function () {
    return new Mole();
  }; //add Mole-constructor to Mob-ollection


  Mobs.Mechanic = function () {
    return new Mechanic();
  };

  return Mobs;
}(window.gm.Mobs || {});

var Leggings = /*#__PURE__*/function (_Equipment) {
  _inherits(Leggings, _Equipment);

  var _super17 = _createSuper(Leggings);

  function Leggings() {
    var _this15;

    _classCallCheck(this, Leggings);

    _this15 = _super17.call(this, 'Leggings');
    _this15.tags = ['cloth'];
    _this15.slotUse = ['Legs'];
    _this15.desc = 'Spandex-leggings for sport. (agility+)';
    window.storage.registerConstructor(Leggings);
    return _this15;
  }

  _createClass(Leggings, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Leggings", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('agility', {
        id: 'agility:Leggings',
        bonus: 5
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('agility', {
        id: 'agility:Leggings'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Leggings, value.data);
    }
  }]);

  return Leggings;
}(Equipment);

var Jeans = /*#__PURE__*/function (_Equipment2) {
  _inherits(Jeans, _Equipment2);

  var _super18 = _createSuper(Jeans);

  function Jeans() {
    var _this16;

    _classCallCheck(this, Jeans);

    _this16 = _super18.call(this, 'Jeans');
    _this16.tags = ['cloth'];
    _this16.slotUse = ['Legs'];
    _this16.desc = 'plain old blue jeans';
    window.storage.registerConstructor(Jeans);
    return _this16;
  }

  _createClass(Jeans, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Jeans", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Jeans, value.data);
    }
  }]);

  return Jeans;
}(Equipment);

var TankShirt = /*#__PURE__*/function (_Equipment3) {
  _inherits(TankShirt, _Equipment3);

  var _super19 = _createSuper(TankShirt);

  function TankShirt() {
    var _this17;

    _classCallCheck(this, TankShirt);

    _this17 = _super19.call(this, 'TankShirt');
    _this17.tags = ['cloth'];
    _this17.slotUse = ['Torso'];
    _this17.desc = 'light blue tank-top';
    window.storage.registerConstructor(TankShirt);
    return _this17;
  }

  _createClass(TankShirt, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("TankShirt", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(TankShirt, value.data);
    }
  }]);

  return TankShirt;
}(Equipment);

var Pullover = /*#__PURE__*/function (_Equipment4) {
  _inherits(Pullover, _Equipment4);

  var _super20 = _createSuper(Pullover);

  function Pullover() {
    var _this18;

    _classCallCheck(this, Pullover);

    _this18 = _super20.call(this, 'Pullover');
    _this18.tags = ['cloth'];
    _this18.slotUse = ['Torso', 'Arms'];
    _this18.desc = 'warm pullover';
    window.storage.registerConstructor(Pullover);
    return _this18;
  }

  _createClass(Pullover, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Pullover", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Pullover, value.data);
    }
  }]);

  return Pullover;
}(Equipment);

var HandCuffs = /*#__PURE__*/function (_Equipment5) {
  _inherits(HandCuffs, _Equipment5);

  var _super21 = _createSuper(HandCuffs);

  function HandCuffs() {
    var _this19;

    _classCallCheck(this, HandCuffs);

    _this19 = _super21.call(this, 'HandCuffs');
    _this19.tags = ['restrain'];
    _this19.slotUse = ['RHand', 'LHand'];
    _this19.desc = 'handcuffs';
    window.storage.registerConstructor(Pullover);
    return _this19;
  }

  _createClass(HandCuffs, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("HandCuffs", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return this.canEquip();
    }
  }, {
    key: "use",
    value: function use(context) {
      //context here is inventory not outfit
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) {
        this.parent.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: 'unequipped ' + this.name
        }; //todo
      } else {
        this.parent.parent.Outfit.addItem(this);
        return {
          OK: true,
          msg: 'equipped ' + this.name
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      }; //todo check for key
      else return {
          OK: true,
          msg: 'equip'
        };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: false,
        msg: 'You need to find a key first to be able to remove it!'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(HandCuffs, value.data);
    }
  }]);

  return HandCuffs;
}(Equipment); //this is an Inventory-item, not wardrobe


var Crowbar = /*#__PURE__*/function (_Equipment6) {
  _inherits(Crowbar, _Equipment6);

  var _super22 = _createSuper(Crowbar);

  function Crowbar() {
    var _this20;

    _classCallCheck(this, Crowbar);

    _this20 = _super22.call(this, 'Crowbar');
    _this20.desc = 'A durable crowbar.';
    _this20.tags = ['tool', 'weapon'];
    _this20.slotUse = ['RHand'];
    window.storage.registerConstructor(Crowbar);
    return _this20;
  }

  _createClass(Crowbar, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Crowbar", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return this.canEquip();
    }
  }, {
    key: "use",
    value: function use(context) {
      //context here is inventory not outfit
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) {
        this.parent.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: 'unequipped ' + this.name
        }; //todo
      } else {
        this.parent.parent.Outfit.addItem(this);
        return {
          OK: true,
          msg: 'equipped ' + this.name
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      };else return {
        OK: true,
        msg: 'equip'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('pAttack', {
        id: 'pAttack:Crowbar',
        bonus: 2
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('pAttack', {
        id: 'pAttack:Crowbar'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Crowbar, value.data);
    }
  }]);

  return Crowbar;
}(Equipment); //this is an Inventory-item, not wardrobe


var Shovel = /*#__PURE__*/function (_Equipment7) {
  _inherits(Shovel, _Equipment7);

  var _super23 = _createSuper(Shovel);

  function Shovel() {
    var _this21;

    _classCallCheck(this, Shovel);

    _this21 = _super23.call(this, 'Shovel');
    _this21.desc = 'A rusty,old shovel.';
    _this21.tags = ['tool', 'weapon'];
    _this21.slotUse = ['RHand', 'LHand'];
    window.storage.registerConstructor(Shovel);
    return _this21;
  }

  _createClass(Shovel, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Shovel", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return this.canEquip();
    }
  }, {
    key: "use",
    value: function use(context) {
      //context here is inventory not outfit
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) {
        this.parent.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: 'unequipped ' + this.name
        }; //todo
      } else {
        this.parent.parent.Outfit.addItem(this);
        return {
          OK: true,
          msg: 'equipped ' + this.name
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      };else return {
        OK: true,
        msg: 'equip'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('pAttack', {
        id: 'pAttack:Shovel',
        bonus: 2
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('pAttack', {
        id: 'pAttack:Shovel'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Shovel, value.data);
    }
  }]);

  return Shovel;
}(Equipment);

var TailRibbon = /*#__PURE__*/function (_Equipment8) {
  _inherits(TailRibbon, _Equipment8);

  var _super24 = _createSuper(TailRibbon);

  function TailRibbon() {
    var _this22;

    _classCallCheck(this, TailRibbon);

    _this22 = _super24.call(this, 'TailRibbon');
    _this22.tags = ['cloth'];
    _this22.slotUse = ['TailTip'];
    _this22.desc = 'a fancy color band that can be wrapped around someones tailtip';
    window.storage.registerConstructor(TailRibbon);
    return _this22;
  }

  _createClass(TailRibbon, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("TailRibbon", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      }; //todo check for key
      else {
          if (this.parent.parent.Outfit.countItem("TailCat") > 0) {
            return {
              OK: true,
              msg: 'equip'
            };
          } else {
            return {
              OK: false,
              msg: 'This requires a propper tail to attach to!'
            };
          }
        }
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(TailRibbon, value.data);
    }
  }]);

  return TailRibbon;
}(Equipment); //a bodypart


var TailNone = /*#__PURE__*/function (_Equipment9) {
  _inherits(TailNone, _Equipment9);

  var _super25 = _createSuper(TailNone);

  function TailNone() {
    var _this23;

    _classCallCheck(this, TailNone);

    _this23 = _super25.call(this, 'TailNone');
    _this23.tags = ['body'];
    _this23.slotUse = ['bTailBase'];
    _this23.desc = '';
    window.storage.registerConstructor(TailNone);
    return _this23;
  }

  _createClass(TailNone, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("TailNone", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(TailNone, value.data);
    }
  }]);

  return TailNone;
}(Equipment);

var TailCat = /*#__PURE__*/function (_Equipment10) {
  _inherits(TailCat, _Equipment10);

  var _super26 = _createSuper(TailCat);

  function TailCat() {
    var _this24;

    _classCallCheck(this, TailCat);

    _this24 = _super26.call(this, 'TailCat');
    _this24.tags = ['body'];
    _this24.slotUse = ['bTailBase'];
    _this24.desc = 'a flexible,furred pipe-tail';
    _this24.growth = 0.10; //in %/100 maxGrowth

    _this24.maxGrowth = 1.2; //in meter, todo depends on bodysize

    window.storage.registerConstructor(TailCat);
    return _this24;
  }

  _createClass(TailCat, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("TailCat", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(TailCat, value.data);
    }
  }]);

  return TailCat;
}(Equipment);

window.gm.ItemsLib = function (ItemsLib) {
  window.storage.registerConstructor(Leggings);
  window.storage.registerConstructor(TankShirt);
  window.storage.registerConstructor(Jeans);
  window.storage.registerConstructor(Pullover);
  window.storage.registerConstructor(Crowbar);
  window.storage.registerConstructor(Shovel);
  window.storage.registerConstructor(TailRibbon); //.. and Wardrobe

  ItemsLib['Leggings'] = function () {
    return new Leggings();
  };

  ItemsLib['Tank-shirt'] = function () {
    return new TankShirt();
  };

  ItemsLib['Jeans'] = function () {
    return new Jeans();
  };

  ItemsLib['Pullover'] = function () {
    return new Pullover();
  };

  ItemsLib['TailRibbon'] = function () {
    return new TailRibbon();
  }; //special wardrobe-item combination


  ItemsLib['Crowbar'] = function () {
    return new Crowbar();
  };

  ItemsLib['Shovel'] = function () {
    return new Shovel();
  }; //{name: 'Shovel', desc: 'A shovel for the dirty work.', tags: ['tool', 'weapon'], slotUse: ['RHand','LHand'],usable:defaultCanUse, use:defaultOnUse, canEquip:defaultCanUse, canUnequip:defaultCanUnequip };


  ItemsLib['Handcuffs'] = function () {
    return new HandCuffs();
  }; //{name: 'Handcuffs', desc: 'You cannot use your hand.', tags: ['restrain'], slotUse: ['RHand','LHand'],usable:defaultCanUse, use:defaultOnUse, canEquip:defaultCanUse, canUnequip:defaultNoUnequip };


  ItemsLib['TailNone'] = function () {
    return new TailNone();
  };

  ItemsLib['TailCat'] = function () {
    return new TailCat();
  };

  return ItemsLib;
}(window.gm.ItemsLib || {});

"use strict"; //this is special stat used together with Relation-collection
//person is used as id instead of stat-name


var stRelation = /*#__PURE__*/function (_Stat) {
  _inherits(stRelation, _Stat);

  var _super27 = _createSuper(stRelation);

  _createClass(stRelation, null, [{
    key: "setup",
    value: function setup(context, base, max, person) {
      //todo Max-Limit
      var _stat = new stRelation();

      var _n = _stat.data;
      _n.id = person + "_Max", _n.base = max, _n.value = max;
      context.addItem(_stat);
      _stat = new stRelation();
      _n = _stat.data;
      _n.id = person + "_Min", _n.base = 0, _n.value = 0;
      context.addItem(_stat);
      _stat = new stRelation();
      _n = _stat.data;
      _n.id = person, _n.base = base, _n.value = base, _n.limits = [{
        max: person + "_Max",
        min: person + "_Min"
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stRelation() {
    _classCallCheck(this, stRelation);

    return _super27.call(this);
  }

  _createClass(stRelation, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stRelation", this);
    }
  }, {
    key: "formatMsgStatChange",
    value: function formatMsgStatChange(attr, _new, _old) {
      if (_new - _old > 0) {
        return '<statup>Your relation to ' + attr.id + " improved by " + (_new - _old).toFixed(1).toString() + "</statup></br>";
      } else if (_new - _old < 0) {
        return '<statdown>Your relation to ' + attr.id + " worsend by " + (_new - _old).toFixed(1).toString() + "</statdown></br>";
      } else {
        return 'Your relation to ' + attr.id + " wasnt affected at all by your behaviour.</br>";
      }
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stRelation, value.data);
    }
  }]);

  return stRelation;
}(Stat);

var stHealthMax = /*#__PURE__*/function (_Stat2) {
  _inherits(stHealthMax, _Stat2);

  var _super28 = _createSuper(stHealthMax);

  _createClass(stHealthMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stHealthMax();

      var _n = _stat.data;
      _n.id = 'healthMax', _n.base = max, _n.value = max, _n.modifys = [{
        id: 'health'
      }];
      context.addItem(_stat); //_stat.Calc(); cause problem because health not yet present
    }
  }]);

  function stHealthMax() {
    _classCallCheck(this, stHealthMax);

    return _super28.call(this);
  }

  _createClass(stHealthMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stHealthMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stHealthMax, value.data);
    }
  }]);

  return stHealthMax;
}(Stat);

var stHealth = /*#__PURE__*/function (_Stat3) {
  _inherits(stHealth, _Stat3);

  var _super29 = _createSuper(stHealth);

  _createClass(stHealth, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stHealthMax.setup(context, max);

      var _stat = new stHealth();

      var _n = _stat.data;
      _n.id = 'health', _n.base = base, _n.value = base, _n.limits = [{
        max: 'healthMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stHealth() {
    _classCallCheck(this, stHealth);

    return _super29.call(this);
  }

  _createClass(stHealth, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stHealth", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stHealth, value.data);
    }
  }]);

  return stHealth;
}(Stat);

var stEnergyMax = /*#__PURE__*/function (_Stat4) {
  _inherits(stEnergyMax, _Stat4);

  var _super30 = _createSuper(stEnergyMax);

  _createClass(stEnergyMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stEnergyMax();

      var _n = _stat.data;
      _n.id = 'energyMax', _n.base = max, _n.value = max, _n.modifys = [{
        id: 'energy'
      }];
      ;
      context.addItem(_stat); //_stat.Calc();
    }
  }]);

  function stEnergyMax() {
    _classCallCheck(this, stEnergyMax);

    return _super30.call(this);
  }

  _createClass(stEnergyMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEnergyMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEnergyMax, value.data);
    }
  }]);

  return stEnergyMax;
}(Stat);

var stEnergy = /*#__PURE__*/function (_Stat5) {
  _inherits(stEnergy, _Stat5);

  var _super31 = _createSuper(stEnergy);

  _createClass(stEnergy, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stEnergyMax.setup(context, max);

      var _stat = new stEnergy();

      var _n = _stat.data;
      _n.id = 'energy', _n.base = base, _n.value = base, _n.limits = [{
        max: 'energyMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stEnergy() {
    _classCallCheck(this, stEnergy);

    return _super31.call(this);
  }

  _createClass(stEnergy, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEnergy", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEnergy, value.data);
    }
  }]);

  return stEnergy;
}(Stat);

var stArousalMax = /*#__PURE__*/function (_Stat6) {
  _inherits(stArousalMax, _Stat6);

  var _super32 = _createSuper(stArousalMax);

  _createClass(stArousalMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stArousalMax();

      var _n = _stat.data;
      _n.id = 'arousalMax', _n.base = max, _n.value = max, _n.hidden = 3;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousalMax() {
    _classCallCheck(this, stArousalMax);

    return _super32.call(this);
  }

  _createClass(stArousalMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousalMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousalMax, value.data);
    }
  }]);

  return stArousalMax;
}(Stat);

var stArousalMin = /*#__PURE__*/function (_Stat7) {
  _inherits(stArousalMin, _Stat7);

  var _super33 = _createSuper(stArousalMin);

  _createClass(stArousalMin, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stArousalMin();

      var _n = _stat.data;
      _n.id = 'arousalMin', _n.base = 0, _n.value = 0, _n.hidden = 1;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousalMin() {
    _classCallCheck(this, stArousalMin);

    return _super33.call(this);
  }

  _createClass(stArousalMin, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousalMin", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousalMin, value.data);
    }
  }]);

  return stArousalMin;
}(Stat);

var stArousal = /*#__PURE__*/function (_Stat8) {
  _inherits(stArousal, _Stat8);

  var _super34 = _createSuper(stArousal);

  _createClass(stArousal, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stArousalMax.setup(context, max);
      stArousalMin.setup(context, 0);

      var _stat = new stArousal();

      var _n = _stat.data;
      _n.id = 'arousal', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: 'arousalMax',
        min: 'arousalMin'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousal() {
    _classCallCheck(this, stArousal);

    return _super34.call(this);
  }

  _createClass(stArousal, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousal", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousal, value.data);
    }
  }]);

  return stArousal;
}(Stat);

var stPerversionMax = /*#__PURE__*/function (_Stat9) {
  _inherits(stPerversionMax, _Stat9);

  var _super35 = _createSuper(stPerversionMax);

  _createClass(stPerversionMax, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _stat = new stPerversionMax();

      var _n = _stat.data;
      _n.id = 'perversionMax', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: '',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPerversionMax() {
    _classCallCheck(this, stPerversionMax);

    return _super35.call(this);
  }

  _createClass(stPerversionMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPerversionMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPerversionMax, value.data);
    }
  }]);

  return stPerversionMax;
}(Stat);

var stPerversion = /*#__PURE__*/function (_Stat10) {
  _inherits(stPerversion, _Stat10);

  var _super36 = _createSuper(stPerversion);

  _createClass(stPerversion, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stPerversionMax.setup(context, max);

      var _stat = new stPerversion();

      var _n = _stat.data;
      _n.id = 'perversion', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: 'perversionMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPerversion() {
    _classCallCheck(this, stPerversion);

    return _super36.call(this);
  }

  _createClass(stPerversion, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPerversion", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPerversion, value.data);
    }
  }]);

  return stPerversion;
}(Stat);

var stAgility = /*#__PURE__*/function (_Stat11) {
  _inherits(stAgility, _Stat11);

  var _super37 = _createSuper(stAgility);

  _createClass(stAgility, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'agility', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'energyMax'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stAgility() {
    _classCallCheck(this, stAgility);

    return _super37.call(this);
  }

  _createClass(stAgility, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stAgility", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('energyMax', {
        id: 'agility',
        bonus: this.parent.get('agility').value
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stAgility, value.data);
    }
  }]);

  return stAgility;
}(Stat);

var stPerception = /*#__PURE__*/function (_Stat12) {
  _inherits(stPerception, _Stat12);

  var _super38 = _createSuper(stPerception);

  _createClass(stPerception, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stPerception();

      var _n = _stat.data;
      _n.id = 'perception', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPerception() {
    _classCallCheck(this, stPerception);

    return _super38.call(this);
  }

  _createClass(stPerception, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPerception", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPerception, value.data);
    }
  }]);

  return stPerception;
}(Stat);

var stLuck = /*#__PURE__*/function (_Stat13) {
  _inherits(stLuck, _Stat13);

  var _super39 = _createSuper(stLuck);

  _createClass(stLuck, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stLuck();

      var _n = _stat.data;
      _n.id = 'luck', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stLuck() {
    _classCallCheck(this, stLuck);

    return _super39.call(this);
  }

  _createClass(stLuck, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stLuck", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stLuck, value.data);
    }
  }]);

  return stLuck;
}(Stat);

var stCharisma = /*#__PURE__*/function (_Stat14) {
  _inherits(stCharisma, _Stat14);

  var _super40 = _createSuper(stCharisma);

  _createClass(stCharisma, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stCharisma();

      var _n = _stat.data;
      _n.id = 'charisma', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stCharisma() {
    _classCallCheck(this, stCharisma);

    return _super40.call(this);
  }

  _createClass(stCharisma, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stCharisma", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stCharisma, value.data);
    }
  }]);

  return stCharisma;
}(Stat);

var stIntelligence = /*#__PURE__*/function (_Stat15) {
  _inherits(stIntelligence, _Stat15);

  var _super41 = _createSuper(stIntelligence);

  _createClass(stIntelligence, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stIntelligence();

      var _n = _stat.data;
      _n.id = 'intelligence', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stIntelligence() {
    _classCallCheck(this, stIntelligence);

    return _super41.call(this);
  }

  _createClass(stIntelligence, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stIntelligence", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stIntelligence, value.data);
    }
  }]);

  return stIntelligence;
}(Stat);

var stStrength = /*#__PURE__*/function (_Stat16) {
  _inherits(stStrength, _Stat16);

  var _super42 = _createSuper(stStrength);

  _createClass(stStrength, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'strength', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pAttack'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stStrength() {
    _classCallCheck(this, stStrength);

    return _super42.call(this);
  }

  _createClass(stStrength, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stStrength", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('healthMax', {
        id: 'strength',
        bonus: this.parent.get('strength').value * 4
      });
      this.parent.addModifier('pAttack', {
        id: 'strength',
        bonus: this.parent.get('strength').value % 4
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stStrength, value.data);
    }
  }]);

  return stStrength;
}(Stat);

var stEndurance = /*#__PURE__*/function (_Stat17) {
  _inherits(stEndurance, _Stat17);

  var _super43 = _createSuper(stEndurance);

  _createClass(stEndurance, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'endurance', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pDefense'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stEndurance() {
    _classCallCheck(this, stEndurance);

    return _super43.call(this);
  }

  _createClass(stEndurance, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEndurance", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('healthMax', {
        id: 'endurance',
        bonus: this.arent.get('endurance').value * 4
      });
      this.parent.addModifier('pDefense', {
        id: 'strength',
        bonus: this.parent.get('endurance').value % 4
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEndurance, value.data);
    }
  }]);

  return stEndurance;
}(Stat);

var stPAttack = /*#__PURE__*/function (_Stat18) {
  _inherits(stPAttack, _Stat18);

  var _super44 = _createSuper(stPAttack);

  _createClass(stPAttack, null, [{
    key: "setup",
    //physical attack
    value: function setup(context, base, max) {
      var _stat = new stPAttack();

      var _n = _stat.data;
      _n.id = 'pAttack', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPAttack() {
    _classCallCheck(this, stPAttack);

    return _super44.call(this);
  }

  _createClass(stPAttack, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPAttack", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPAttack, value.data);
    }
  }]);

  return stPAttack;
}(Stat);

var stPDefense = /*#__PURE__*/function (_Stat19) {
  _inherits(stPDefense, _Stat19);

  var _super45 = _createSuper(stPDefense);

  _createClass(stPDefense, null, [{
    key: "setup",
    //physical defense
    value: function setup(context, base, max) {
      var _stat = new stPAttack();

      var _n = _stat.data;
      _n.id = 'pDefense', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPDefense() {
    _classCallCheck(this, stPDefense);

    return _super45.call(this);
  }

  _createClass(stPDefense, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPDefense", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPDefense, value.data);
    }
  }]);

  return stPDefense;
}(Stat); //effects


var effEnergized = /*#__PURE__*/function (_Effect2) {
  _inherits(effEnergized, _Effect2);

  var _super46 = _createSuper(effEnergized);

  function effEnergized() {
    var _this25;

    _classCallCheck(this, effEnergized);

    _this25 = _super46.call(this);
    _this25.data.id = _this25.data.name = effEnergized.name, _this25.data.duration = 120;
    return _this25;
  }

  _createClass(effEnergized, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effEnergized", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //+ 10Energy per hour
      var delta = window.gm.getDeltaTime(time, this.data.time);
      this.data.time = time;
      this.data.duration -= delta;
      if (this.data.duration < 0) delta = delta + this.data.duration; // if delta is 20 but remaining duration is only 5, delta should be capped to 5
      //Effects impact Stats:  Effect->Effects->Character->Stats    is there a prettier wy?

      this.parent.parent.Stats.increment('energy', 10 * delta / 60);

      if (this.data.duration <= 0) {
        //remove yourself
        return function (me) {
          return function (Effects) {
            Effects.removeItem(me.data.id);
          };
        }(this);
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {
      //+10 energy
      this.data.duration = 120;
      this.data.time = window.gm.getTime();
      this.parent.parent.Stats.increment('energy', 10);
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        this.onApply(); //refresh 

        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effEnergized.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effEnergized, value.data);
    }
  }]);

  return effEnergized;
}(Effect);

var effNotTired = /*#__PURE__*/function (_Effect3) {
  _inherits(effNotTired, _Effect3);

  var _super47 = _createSuper(effNotTired);

  function effNotTired() {
    var _this26;

    _classCallCheck(this, effNotTired);

    _this26 = _super47.call(this);
    _this26.data.id = _this26.data.name = effNotTired.name, _this26.data.duration = 120, _this26.data.hidden = 4;
    return _this26;
  }

  _createClass(effNotTired, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effNotTired", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //Tired after xxh
      this.data.duration -= window.gm.getDeltaTime(time, this.data.time);
      this.data.time = time;

      if (this.data.duration <= 0) {
        return function (me) {
          return function (Effects) {
            var newdata = new effTired();
            Effects.replace(me.data.id, newdata);
          };
        }(this);
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.duration = 120; // todo 600;

      this.data.time = window.gm.getTime();
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        this.onApply(); //refresh

        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effNotTired.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effNotTired, value.data);
    }
  }]);

  return effNotTired;
}(Effect);

var effTired = /*#__PURE__*/function (_Effect4) {
  _inherits(effTired, _Effect4);

  var _super48 = _createSuper(effTired);

  function effTired() {
    var _this27;

    _classCallCheck(this, effTired);

    _this27 = _super48.call(this);
    _this27.data.id = _this27.data.name = effTired.name, _this27.data.duration = 120, _this27.data.hidden = 0;
    return _this27;
  }

  _createClass(effTired, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effTired", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //duration not used -> will never expire unless replaced
      var delta = window.gm.getTime() - this.data.time; //-10 max energy after 12h, but only up to 3 times

      if (delta > 60) this.parent.parent.Stats.addModifier('energyMax', {
        id: 'energyMax:Tired',
        bonus: -10
      });
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.time = window.gm.getTime();
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.parent.parent.Stats.removeModifier('energyMax', {
        id: 'energyMax:Tired'
      });
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === 'NotTired') {
        return function (me) {
          return function (Effects) {
            var newdata = new effNotTired();
            Effects.replace(me.data.id, newdata);
          };
        }(this);
      }

      if (neweffect.name === this.data.name) {
        //just ignore
        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effTired.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effTired, value.data);
    }
  }]);

  return effTired;
}(Effect);

var effMutateCat = /*#__PURE__*/function (_Effect5) {
  _inherits(effMutateCat, _Effect5);

  var _super49 = _createSuper(effMutateCat);

  function effMutateCat() {
    var _this28;

    _classCallCheck(this, effMutateCat);

    _this28 = _super49.call(this);
    _this28.data.id = _this28.data.name = effMutateCat.name, _this28.data.duration = 60, _this28.data.hidden = 0;
    return _this28;
  }

  _createClass(effMutateCat, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effMutateCat", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //after some time you mutate a bit
      this.data.duration -= window.gm.getDeltaTime(time, this.data.time);
      this.data.time = time;

      if (this.data.duration <= 0) {
        return function (me) {
          return function (Effects) {
            window.gm.pushDeferredEvent("MutateTailCat");
            window.gm.pushDeferredEvent("CatHabit");
            Effects.removeItem(me.data.id);
          };
        }(this);
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.duration = 60;
      this.data.time = window.gm.getTime();
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        //dont refresh
        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effMutateCat.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effMutateCat, value.data);
    }
  }]);

  return effMutateCat;
}(Effect); //combateffect


var effStunned = /*#__PURE__*/function (_CombatEffect) {
  _inherits(effStunned, _CombatEffect);

  var _super50 = _createSuper(effStunned);

  function effStunned() {
    var _this29;

    _classCallCheck(this, effStunned);

    _this29 = _super50.call(this);
    _this29.data.id = _this29.data.name = effStunned.name, _this29.data.duration = 2;
    return _this29;
  }

  _createClass(effStunned, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effStunned", this);
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.duration = 2;
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        //extends stun
        this.onApply();
        return true;
      }
    }
  }, {
    key: "onCombatEnd",
    value: function onCombatEnd() {
      this.parent.removeItem(this.data.id);
    }
  }, {
    key: "onTurnStart",
    value: function onTurnStart() {
      this.data.duration -= 1;
      if (this.data.duration <= 0) this.parent.removeItem(this.data.id);
    }
  }, {
    key: "desc",
    get: function get() {
      return effStunned.name;
    }
  }, {
    key: "shortDesc",
    get: function get() {
      return this.desc + " for " + this.data.duration + " turns";
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effStunned, value.data);
    }
  }]);

  return effStunned;
}(CombatEffect); //skills


var skCooking = /*#__PURE__*/function (_Effect6) {
  _inherits(skCooking, _Effect6);

  var _super51 = _createSuper(skCooking);

  function skCooking() {
    var _this30;

    _classCallCheck(this, skCooking);

    _this30 = _super51.call(this);
    _this30.data.id = _this30.data.name = skCooking.name;
    return _this30;
  }

  _createClass(skCooking, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("skCooking", this);
    }
  }, {
    key: "desc",
    get: function get() {
      return skCooking.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(skCooking, value.data);
    }
  }]);

  return skCooking;
}(Effect);

window.gm.StatsLib = function (StatsLib) {
  //...stats
  window.storage.registerConstructor(stHealthMax);
  window.storage.registerConstructor(stHealth);
  window.storage.registerConstructor(stRelation);
  window.storage.registerConstructor(stEndurance);
  window.storage.registerConstructor(stStrength);
  window.storage.registerConstructor(stAgility);
  window.storage.registerConstructor(stLuck);
  window.storage.registerConstructor(stCharisma);
  window.storage.registerConstructor(stPerception);
  window.storage.registerConstructor(stEnergyMax);
  window.storage.registerConstructor(stEnergy);
  window.storage.registerConstructor(stArousalMax);
  window.storage.registerConstructor(stArousalMin);
  window.storage.registerConstructor(stArousal);
  window.storage.registerConstructor(stPerversionMax);
  window.storage.registerConstructor(stPerversion);
  window.storage.registerConstructor(stPAttack);
  window.storage.registerConstructor(stPDefense); //...effects

  window.storage.registerConstructor(effNotTired);
  window.storage.registerConstructor(effTired);
  window.storage.registerConstructor(effEnergized);
  window.storage.registerConstructor(effStunned);
  window.storage.registerConstructor(effMutateCat);

  StatsLib.effMutateCat = function () {
    return new effMutateCat();
  };

  window.storage.registerConstructor(skCooking);
  return StatsLib;
}(window.gm.StatsLib || {});