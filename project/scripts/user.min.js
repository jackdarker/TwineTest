"use strict";
/* a class to provide methods to work with PC & NPC
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effects = exports.StatsDictionary = exports.Effect = exports.Stat = exports.Outfit = exports.Shovel = exports.Crowbar = exports.Pullover = exports.TankShirt = exports.Jeans = exports.Leggings = exports.Equipment = exports.Character = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Character = /*#__PURE__*/function () {
  _createClass(Character, null, [{
    key: "defaultData",
    value: function defaultData() {
      return {
        name: '',
        location: "Home",
        inv: [],
        //inventory data, needs to be mapped to Inventory-Instance
        wardrobe: [],
        //separate wardobe data, needs to be mapped to outfit-Instance
        outfit: [],
        // needs to be mapped to outfit-Instance
        stats: [],
        effects: [],
        rel: []
      };
    }
  }]);

  function Character(externlist) {
    _classCallCheck(this, Character);

    this._data = externlist ? externlist : Character.defaultData();
    this.Outfit = new Outfit(this._data.outfit);
    this.Outfit._parent = window.gm.util.refToParent(this);
    this.Inv = new Inventory(this._data.inv);
    this.Inv._parent = window.gm.util.refToParent(this);
    this.Wardrobe = new Inventory(this._data.wardrobe);
    this.Wardrobe._parent = window.gm.util.refToParent(this);
    this.Stats = new StatsDictionary(this._data.stats);
    this.Stats._parent = window.gm.util.refToParent(this);
    this.Effects = new Effects(this._data.effects);
    this.Effects._parent = window.gm.util.refToParent(this);
    this.Rel = new StatsDictionary(this._data.rel); //Todo Relation similiar to stats?

    this.Rel._parent = window.gm.util.refToParent(this); //create basic stats

    stHealth.setup(this.Stats, 50, 60), stEnergy.setup(this.Stats, 30, 100), stPAttack.setup(this.Stats, 4, 100), stPDefense.setup(this.Stats, 4, 100), stAgility.setup(this.Stats, 3, 100), stStrength.setup(this.Stats, 3, 100), stEndurance.setup(this.Stats, 3, 100);
    stPerversion.setup(this.Stats, 1, 15), stArousal.setup(this.Stats, 1, 100);
    this.Effects.addItem(effNotTired.name, new effNotTired()); //depending on sleep Tired will be set to NotTired or Tired

    window.storage.registerConstructor(Character);
  }

  _createClass(Character, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Character", this);
    }
  }, {
    key: "health",
    value: function health() {
      return {
        value: this.Stats.get('health').value,
        max: this.Stats.get('healthMax').value,
        min: 0
      };
    }
  }, {
    key: "energy",
    value: function energy() {
      return {
        value: this.Stats.get('energy').value,
        max: this.Stats.get('energyMax').value,
        min: 0
      };
    }
  }, {
    key: "addEffect",
    value: function addEffect(id, effect) {
      this.Effects.addItem(id, effect);
    } //helper function to change Relation 

  }, {
    key: "gainRelation",
    value: function gainRelation(char, val) {
      var _idx = this.Rel.findItemSlot(char);

      if (_idx < 0) {
        var _rel = stRelation.setup(this.Rel, val, 100, char);
      } else {
        this.Rel.increment(char, val);
      }
    } //combat related

  }, {
    key: "_canAct",
    value: function _canAct() {
      var result = {
        OK: true,
        msg: ''
      };

      if (this.Effects.findItemSlot("effStunned") >= 0) {
        result.OK = false;
        result.msg = this.name + " is stunned and cannot react.";
        return result;
      }

      return result;
    }
  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    },
    set: function set(name) {
      this._data.name = name;
    }
  }, {
    key: "location",
    get: function get() {
      return this._data.location;
    },
    set: function set(name) {
      this._data.location = name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Character, value.data);

      _x.Effects._relinkItems();

      _x.Stats._relinkItems();

      _x.Inv._relinkItems();

      _x.Outfit._relinkItems();

      _x.Wardrobe._relinkItems();

      _x.Rel._relinkItems();

      return _x;
    }
  }]);

  return Character;
}();

exports.Character = Character;
"use strict";
/* bundles some operations related to combat */


window.gm = window.gm || {};
window.gm.combat = window.gm.combat || {};

window.gm.combat.initCombat = function (combatSetup) {
  //setup enemy for encounter
  var s = window.story.state;
  s.enemy = combatSetup(); //s.enemy.name = window.gm.enemy.name;  
  //s.enemy.pic = window.gm.enemy.pic;

  s.combat.enemyTurn = false;
  s.combat.turnCount = 0;
  s.combat.combatState = 'battling';
};

window.gm.combat.hideCombatOption = function () {
  document.querySelector("#combatmenu").remove();
};

window.gm.combat.printCombatOption = function () {
  //creates a list of possible moves
  var elmt = "<form id='combatmenu'>"; //Todo create list based on abilitys

  var canAct = window.gm.player._canAct();

  if (canAct.OK === true) {
    elmt += "<a0 id='moveFlee'           onclick='(function($event){window.gm.combat.triggerCombat($event.id);})(this);'>Try to flee</a></br>";
    elmt += "<a0 id='movePhysicalAttack' onclick='(function($event){window.gm.combat.triggerCombat($event.id);})(this);'>Attack</a></br>";
    elmt += "<a0 id='moveGuard'          onclick='(function($event){window.gm.combat.triggerCombat($event.id);})(this);'>Guard</a></br>";
    elmt += "<a0 id='moveStun'           onclick='(function($event){window.gm.combat.triggerCombat($event.id);})(this);'>Stun</a></br>"; //Todo Item-use on self or enemy
    //elmt +="<a0 id='showItems' onclick='(function($event){window.gm.execCombatCmd($event.id);"+next+"})(this);'>Item</a></br>";
  } else {
    elmt += canAct.msg + "</br>";
  }

  elmt += "<a0 id='moveNOP'          onclick='(function($event){window.gm.combat.triggerCombat($event.id);})(this);'>Do nothing</a></br>";
  elmt += "</form></br>";
  return elmt;
}; //creates a list of active effects for combat display


window.gm.combat.printCombatEffects = function (char) {
  var list = [];
  var effects = char.Effects.getAllIds();

  for (var i = 0; i < effects.length; i++) {
    var effect = char.Effects.get(effects[i]);

    if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
      list.push(effect.shortDesc);
    }
  }

  return list.reduce(function (sum, current) {
    return sum + current + ', ';
  }, '');
}; //UNUSED


window.gm.combat.printCombatScreen = function () {
  //prints scene-bg and enemy to canvas      
  var canvas = document.getElementById("exampleCanvas");
  var ctx = canvas.getContext("2d");
  var img = new Image();
  img.src = "assets/bg_park.png"; //todo the loading o image takes a while and it will not refreh automatically

  ctx.drawImage(img, 0, 0);
  img = new Image();
  img.src = "assets/bird.gif"; //todo the loading o image takes a while and it will not refreh automatically

  ctx.drawImage(img, 0, 0);
};

window.gm.combat.triggerCombat = function (id) {
  //called by combatmenu-buttons expects a functioname
  window.gm.combat.hideCombatOption();
  var result = window.gm.combat.execCombatCmd(window.gm.combat[id]);
  window.gm.printOutput(result.msg + window.gm.printPassageLink("Next", "EncounterStartTurn"));
  window.gm.combat.printCombatHud();
}; //calculates and executes combat-cmd of enemy


window.gm.combat.calcEnemyCombat = function () {
  var enemy = window.story.state.enemy;
  var move = enemy.calcCombatMove();
  return move.msg + "</br>";
}; //executes a combat-cmd for player/enemy


window.gm.combat.execCombatCmd = function (move) {
  var s = window.story.state;
  var result = move();
  s.combat.enemyTurn = !s.combat.enemyTurn; //toggle whos turn

  return result;
};

window.gm.combat.startRound = function () {
  var s = window.story.state;
  s.combat.turnCount += 1; //update combateffects

  var list = [window.story.state.enemy, window.gm.player];

  for (var k = 0; k < list.length; k++) {
    var effects = list[k].Effects.getAllIds();

    for (var i = 0; i < effects.length; i++) {
      var effect = list[k].Effects.get(effects[i]);

      if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
        //typeof effect === CombatEffect doesnt work? so we check presencse of attribut
        effect.onTurnStart();
      }
    }
  }
};

window.gm.combat.endRound = function () {};

window.gm.combat.endCombat = function () {
  //remove combateffects
  var list = [window.story.state.enemy, window.gm.player];

  for (var k = 0; k < list.length; k++) {
    var effects = list[k].Effects.getAllIds();

    for (var i = 0; i < effects.length; i++) {
      var effect = list[k].Effects.get(effects[i]);

      if (effect.onCombatEnd !== null && effect.onCombatEnd !== undefined) {
        effect.onCombatEnd();
      }
    }
  }
}; //OBSOLETE executes a combat-cmd for player/enemy


window.gm.combat.execCombatCmd2 = function (id) {
  var s = window.story.state;

  var rnd = _.random(1, 100);

  var msg = '';
  var result = {};

  if (s.combat.enemyTurn) {
    if (id === 'Attack') {
      result = window.gm.calcAttack(s.combat.enemyTurn);
      msg += result.msg;
    }
  } else {
    if (id === 'Attack') {
      result = window.gm.calcAttack(s.combat.enemyTurn);
      msg += result.msg;
    } else if (id === 'RunAway') {
      if (rnd > 40) {
        msg += "You escaped the fight.";
        s.vars.combatState = 'fleeing'; //just setting the flag, you have to take care of handling!
      } else {
        msg += "Your attempts to escape failed.";
      }
    }
  }
}; //does nothing


window.gm.combat.moveNOP = function () {
  var result = {
    OK: false,
    msg: ''
  };
  return result;
}; //increase defense


window.gm.combat.moveGuard = function () {
  //Todo
  var s = window.story.state;
  var result = {
    OK: true,
    msg: ''
  };

  if (s.combat.enemyTurn) {} else {}

  return result;
};

window.gm.combat.moveStun = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var result = {
    OK: true,
    msg: ''
  };

  var rnd = _.random(1, 100);

  if (rnd > 4) {
    result.msg += defender.name + " got stunned by " + attacker.name;
    defender.addEffect(effStunned.name, new effStunned());
  } else {
    result.msg += "Attempt to stun " + defender.name + " failed.";
    result.OK = false;
  }

  return result;
};

window.gm.combat.moveFlee = function () {
  //Todo
  var s = window.story.state;
  var result = {
    OK: true,
    msg: ''
  };

  var rnd = _.random(1, 100);

  if (s.combat.enemyTurn) {//todo fleeing enemy?
  } else {
    if (rnd > 40) {
      result.msg += "You escaped the fight.";
      s.vars.combatState = 'fleeing'; //just setting the flag, you have to take care of handling!
    } else {
      result.msg += "Your attempts to escape failed.";
      result.OK = false;
    }
  }

  return result;
}; //calculates damage of attack


window.gm.combat.movePhysicalAttack = function () {
  var s = window.story.state;
  var attacker = s.combat.enemyTurn ? window.story.state.enemy : window.gm.player;
  var defender = s.combat.enemyTurn ? window.gm.player : window.story.state.enemy;
  var msg = '';
  var crit = false,
      hit = false,
      block = false;
  var def = defender.Stats.get('pDefense').value;
  var att = attacker.Stats.get('pAttack').value; //??  Erfolgswahrscheinlichkeit skalieren mit Differenz der Attribute Player-Enemy
  // gleiche Attribute = Wahrscheinlichkeit*100%; Attribut-Diff +2 = *100%*2; Attribut-Diff +4 = *200%

  /*
  =100^((100+2*C4)/100) =100^((25+C4)/25)
  0	100	100
  1	109,6478196143	120,2264434617
  2	120,2264434617	144,5439770746
  4	144,5439770746	208,9296130854
  -1	91,2010839356	83,1763771103
  -2	83,1763771103	69,1830970919
  -4	69,1830970919	47,8630092323
  */
  //GURPS-Lite ? this would means all skills are limited to 20!
  //atacker rolls 3d6; if < Attackskill you hit; if 3or4 you have critical hit; else you missed completely

  var rnd = window.gm.roll(3, 6);

  if (rnd == 3 || rnd == 4) {
    crit = hit = true;
    msg += attacker.name + ' landed a critical hit.</br>';
  } else if (rnd <= att) {
    hit = true;
  } else {
    msg += attacker.name + ' missed his target.</br>';
  } //defender rolls 3d6 (no roll on critical hit); if < Defense, the hit was avoided


  rnd = window.gm.roll(3, 6);

  if (crit == false) {
    if (rnd == 3 || rnd == 4) {
      hit = false;
      msg += defender.name + ' avoided beeing hit.</br>';
    } else if (rnd <= def) {
      block = true;
      msg += defender.name + ' was hit but shrugged of the damage.</br>';
    }
  } //attacker rolls dies according to weapon; damage is the result reduced by DR


  if (hit == true && block == false) {
    rnd = Math.max(0, rnd = window.gm.roll(1, 6) + 1 - 0); //todo

    defender.Stats.increment('health', -1 * rnd);
    msg += attacker.name + ' dealt ' + rnd + ' damage to ' + defender.name + '.</br>';
  }

  return {
    OK: hit && !block,
    msg: msg
  };
};

window.gm.combat.printCombatHud = function () {
  //prints the Stats and Effects of the Player&Enemy
  renderToSelector("#playerstats", "playerstats");
  renderToSelector("#enemystats", "enemystats");
};

"use strict"; //import {LighterDad} from './Items.js'; //why is this not working
//constant declarations
//this is a lookuptable for items


function getVersion() {
  return "0,0,0,";
}

function createItemLookups() {
  window.gm.ItemsLib = {}; //window.gm.ItemsLib = { 

  window.gm.ItemsLib['Money'] = new Money();
  window.gm.ItemsLib['LighterDad'] = new LighterDad(); // { name: 'Lighter from Dad', desc: 'I got this lighter from my real dad.', usable:defaultCanUse, use:defaultOnUse },

  window.gm.ItemsLib['LaptopPS'] = new LaptopPS(); //{name: 'Laptop-PS', desc:'Power converter for laptop.', usable: function(){return ({OK: false, msg:'not usable on its own'})},use: defaultNoUse};

  window.gm.ItemsLib['Battery'] = new Battery();
  window.gm.ItemsLib['Dildo_small'] = new Dildo_small(); // consumables

  window.gm.ItemsLib['Lube'] = new Lube();
  window.gm.ItemsLib['CanOfCoffee'] = new CanOfCoffee(); // {name: 'Can of coffee', desc: 'Cold coffee in a can. Tasty? Not really!', usable:canConsumeCoffee, use:onUseCoffee };

  window.gm.ItemsLib['SimpleFood'] = new SimpleFood(); //{name: 'food ration', desc: 'You can eat this.', usable:defaultCanUse, use:defaultOnUse };
  //.. and Wardrobe

  window.gm.ItemsLib['Leggings'] = new Leggings(); //{ name: 'Sport-Leggings', desc: 'Spandex-leggings for sport.', tags: ['cloth'], slotUse: ['Legs'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Tank-shirt'] = new TankShirt(); //{name: 'White Tank-shirt', desc:'White Tank-shirt.',tags: ['cloth'],slotUse: ['Torso','Arms'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Jeans'] = new Jeans(); // {name: 'Bluejeans', desc: 'Thight fitting blue jeans.',tags: ['cloth'], slotUse: ['Legs'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip  };

  window.gm.ItemsLib['Pullover'] = new Pullover(); //{name: 'Pullover', desc: 'A warm pulloer.', tags: ['cloth'],slotUse: ['Torso','Arms'],canEquip:defaultCanUse, canUnequip:defaultCanUnequip };
  //special wardrobe-item combination

  window.gm.ItemsLib['Crowbar'] = new Crowbar(); //{name: 'Crowbar', desc: 'A durable crowbar.', tags: ['tool', 'weapon'], slotUse: ['RHand'],usable:defaultCanUse, use:defaultOnUse,canEquip:defaultCanUse, canUnequip:defaultCanUnequip };

  window.gm.ItemsLib['Shovel'] = {
    name: 'Shovel',
    desc: 'A shovel for the dirty work.',
    tags: ['tool', 'weapon'],
    slotUse: ['RHand', 'LHand'],
    usable: defaultCanUse,
    use: defaultOnUse,
    canEquip: defaultCanUse,
    canUnequip: defaultCanUnequip
  };
  window.gm.ItemsLib['Handcuffs'] = {
    name: 'Handcuffs',
    desc: 'You cannot use your hand.',
    tags: ['restrain'],
    slotUse: ['RHand', 'LHand'],
    usable: defaultCanUse,
    use: defaultOnUse,
    canEquip: defaultCanUse,
    canUnequip: defaultNoUnequip
  }; //};
  //lookup table 

  window.gm.StatsLib = {
    'strength': stStrength,
    //'perception':stPerception,
    'endurance': stEndurance,
    //'charisma':stCharisma,
    //'intelligence':stIntelligence,
    'agility': stAgility,
    //'luck':stLuck,
    //'willpower':stWillpower,
    'pAttack': stPAttack,
    'pDefense': stPDefense,
    'health': stHealth,
    'healthMax': stHealth,
    'energy': stEnergy,
    'energyMax': stEnergy,
    'arousal': stArousal,
    'arousalMin': stArousal,
    'arousalMax': stArousal,
    'perversion': stPerversion,
    'perversionMax': stPerversion
  }; //register constructors for reviver or your loaded save will not work !
  //...items

  window.storage.registerConstructor(LighterDad);
  window.storage.registerConstructor(Money);
  window.storage.registerConstructor(LaptopPS);
  window.storage.registerConstructor(Battery);
  window.storage.registerConstructor(Dildo_small);
  window.storage.registerConstructor(Lube);
  window.storage.registerConstructor(CanOfCoffee);
  window.storage.registerConstructor(SimpleFood); // ...wardrobe

  window.storage.registerConstructor(Leggings);
  window.storage.registerConstructor(TankShirt);
  window.storage.registerConstructor(Jeans);
  window.storage.registerConstructor(Pullover);
  window.storage.registerConstructor(Crowbar);
  window.storage.registerConstructor(Shovel); //window.storage.registerConstructor(Handcuffs);
  //...stats

  window.storage.registerConstructor(stHealthMax);
  window.storage.registerConstructor(stHealth);
  window.storage.registerConstructor(stRelation); //...effects

  window.storage.registerConstructor(effNotTired);
  window.storage.registerConstructor(effTired);
  window.storage.registerConstructor(effEnergized);
  window.storage.registerConstructor(effStunned);
  window.storage.registerConstructor(skCooking);
  window.gm.EnemyLib = {
    'Mole': {
      name: 'Mole',
      pic: 'assets/mole.jpg'
    },
    //new Mole(),
    'Mechanic': {
      name: 'Mechanic-Guy',
      pic: 'assets/mechanic.jpg'
    }
  }; //mapping from passage-locations to background images

  window.gm.ScenePic = {
    'Garden': {
      pic: 'assets/bg_park.png'
    },
    'Park': {
      pic: 'assets/bg_park.png'
    }
  };
}

"use strict"; //var window = window || {};  //to supress lint-errors
//import * as con from "const.js";
//import {Inventory} from './inventory.js'; //already included??


window.gm = window.gm || {}; //game related operations

window.gm.getSaveVersion = function () {
  var version = [0, 1, 0];
  return version;
};

window.gm.initGame = function (forceReset) {
  createItemLookups(); //this does not work because hidden is called to late

  /*$(window).on('sm.passage.hidden', function(event, eventObject) {
    
    if(eventObject.passage) {// No passage to hide when story starts
        console.log('hiding'+eventObject.passage.name);        
    }
  });*/

  $(window).on('sm.passage.showing', function (event, eventObject) {
    // Current Passage object
    $("tw-passage").fadeIn(500); //fade in if was previously faded out

    console.log('showing ' + eventObject.passage.name);
  }); // Render the passage named HUD into the element todo replace with <%=%>??

  $(document).on('sm.passage.shown', function (ev, eventObject) {
    window.gm.updateOtherPanels();
  });
  var s = window.story.state; //s in template is window.story.state from snowman!

  if (!s.vars || forceReset) {
    var _s$vars;

    // storage of variables that doesnt fit player
    s.vars = (_s$vars = {
      debug: true,
      //TODO set to false for distribution !   
      version: window.gm.getSaveVersion(),
      log: [],
      passageStack: [],
      time: 700,
      //represented as hours*100 +minutes
      day: 1,
      activePlayer: 'Ratchel',
      //id of the character that the player controls currently
      //queststates
      qLaptop: 0,
      // see passage _Laptop_
      qDogSit: 0,
      // see park
      qUnlockCampus: 0,
      //see passage into city
      qUnlockPark: 0,
      qUnlockMall: 0,
      qUnlockBeach: 0,
      qUnlockDowntown: 0,
      qUnlockRedlight: 0
    }, _defineProperty(_s$vars, "qUnlockBeach", 0), _defineProperty(_s$vars, "hairGrow", 0), _defineProperty(_s$vars, "crowBarLeft", 1), _defineProperty(_s$vars, "debugInv", new Inventory()), _s$vars);
    s.vars.debugInv._parent = window.gm.util.refToParent(null);
    s.vars.debugInv.addItem(new Money(), 200);
  }

  if (!s.enemy || forceReset) {
    //actual/last enemy
    s.enemy = Character.defaultData();
    s.enemy = new Character();
  }

  if (!s.combat || forceReset) {
    //see encounter & combat.js
    s.combat = {
      enemyTurn: false,
      //true if enemys turn
      combatState: "",
      turnCount: 0,
      scenePic: 'assets/bg_park.png'
    };
  }

  if (!s.mom || forceReset) {
    s.mom = {
      location: "Kitchen",
      coffeeStore: 5,
      foodStore: 3,
      foodMaxStore: 4
    };
  }

  if (!s.Cyril || forceReset) {
    //alternative player character
    window.gm.Cyril = new Character(); //add some basic inventory

    window.gm.Cyril.Wardrobe.addItem(new Jeans());
    window.gm.Cyril.Wardrobe.addItem(new TankShirt());
    window.gm.Cyril.Outfit.addItem(new Jeans());
    window.gm.Cyril.Outfit.addItem(new TankShirt());
    window.gm.Cyril.Stats.increment('strength', 3);
    s.Cyril = window.gm.Cyril; //delete window.gm.Cyril; 
  }

  if (!s.Ratchel || forceReset) {
    /*s.Ratchel = Character.defaultData(); //get default struct and add some special data
    s.Ratchel.name = 'Ratchel',
    s.Ratchel.skillPoints = 2,    //no. of free skillpoints on game-start  
    s.Ratchel.skSporty = 0,//perklevels ,name should match perkId
    s.Ratchel.skCook = 0,
    s.Ratchel.skSlacker = 0,
    s.Ratchel.skMoneymaker = 0,
    s.Ratchel.skTechy = 0;*/
    //window.gm.Ratchel = new Character(s.Ratchel);
    window.gm.Ratchel = new Character();
    window.gm.Ratchel.name = "Ratchel";
    window.gm.Ratchel.gainRelation('Mom', 10);
    window.gm.Ratchel.Effects.addItem(skCooking.name, new skCooking()); //add some basic inventory

    window.gm.Ratchel.Inv.addItem(new Money(), 20);
    window.gm.Ratchel.Inv.addItem(new LighterDad());
    window.gm.Ratchel.Wardrobe.addItem(new Jeans());
    window.gm.Ratchel.Wardrobe.addItem(new Leggings());
    window.gm.Ratchel.Wardrobe.addItem(new TankShirt());
    window.gm.Ratchel.Wardrobe.addItem(new Pullover());
    window.gm.Ratchel.Outfit.addItem(new Jeans());
    window.gm.Ratchel.Outfit.addItem(new Pullover());
    s.Ratchel = window.gm.Ratchel;
  }

  window.gm.switchPlayer(s.Ratchel.name); //start-player
};

window.gm.switchPlayer = function (playername) {
  var s = window.story.state;
  window.gm.player = s[playername];
  s.vars.activePlayer = playername;
};

window.gm.rebuildObjects = function () {
  //Reconnect the objects after load!  
  var s = window.story.state; //window.gm.Ratchel = new Character(s.Ratchel);
  //window.gm.Cyril = new Character(s.Cyril);

  window.gm.switchPlayer(s.vars.activePlayer);
}; //returns timestamp sine start of game


window.gm.getTime = function () {
  return window.story.state.vars.time + 2400 * window.story.state.vars.day;
}; //calculates timedifference for hhmm time format


window.gm.getDeltaTime = function (a, b) {
  var m = a % 100;
  var h = (a - m) / 100;
  var m2 = b % 100;
  var h2 = (b - m2) / 100;
  return h * 60 + m - (h2 * 60 + m2);
}; //adds MINUTES to time


window.gm.addTime = function (min) {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  m = m + min;
  var m2 = m % 60;
  var h2 = h + (m - m2) / 60;
  window.story.state.vars.time = h2 * 100 + m2 % 60;

  while (window.story.state.vars.time >= 2400) {
    window.story.state.vars.time -= 2400;
    window.story.state.vars.day += 1;
  }

  window.gm.player.Effects.updateTime();
};

window.gm.getTimeString = function () {
  var c = window.gm.getTimeStruct();
  return (c.hour < 10 ? "0" : "") + c.hour.toString() + ":" + (c.min < 10 ? "0" : "") + c.min.toString() + "(" + c.daytime + ")";
};

window.gm.getTimeStruct = function () {
  var v = window.story.state.vars;
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var daytime = '';

  if (v.time > 500 && v.time < 1000) {
    daytime = 'morning';
  } else if (v.time >= 1000 && v.time < 1400) {
    daytime = 'noon';
  } else if (v.time >= 1400 && v.time < 1800) {
    daytime = 'afternoon';
  } else if (v.time >= 1800 && v.time < 2200) {
    daytime = 'evening';
  } else {
    daytime = 'night';
  }

  return {
    'hour': h,
    'min': m,
    'daytime': daytime
  };
};

window.gm.getDateString = function () {
  var v = window.story.state.vars;
  return v.day.toString().concat(". day");
}; //forward time to until (1025 = 10:25), regenerate player
//warning dont write 0700 because this would be take as octal number


window.gm.sleep = function (until) {
  var v = window.story.state.vars;
  var msg = '';
  var m = v.time % 100;
  var h = (v.time - m) / 100;
  var m2 = until % 100;
  var h2 = (until - m) / 100;
  var min = (h2 - h) * 60 + (m2 - m); //if now is 8:00 and until 10:00 we assume you want to sleep 2h and not 2+24h
  //if now is 10:00 and until is 9:00 we assume sleep for 23h

  if (until < v.time) {
    min = 24 * 60 - (h - h2) * 60 + (m - m2);
  }

  msg += "</br>Slept for " + min / 60 + " hours.</br>";
  window.gm.addTime(min);
  var regen = min > 420 ? 999 : min / 60 * 15; //todo scaling of regeneration

  window.gm.player.Stats.increment('health', regen);
  window.gm.player.Stats.increment('energy', regen);
  window.gm.pushLog(msg);
  return msg;
}; //Todo


window.gm.rollExplore = function () {
  var s = window.story.state;
  var places = [];

  var r = _.random(0, 100); //todo:depending of your actual location you have a chance to find connected locations or end up in a known one


  if (window.gm.player.location == 'Park') places = ['Mall', 'Beach'];
  if (window.gm.player.location == 'Mall') places = ['Park', 'Beach', 'Downtown'];
  if (window.gm.player.location == 'Beach') places = ['Park', 'Mall'];

  if (window.gm.player.location == 'Downtown') {
    places.push('Pawn shop');
  }

  if (places.length == 0) places = [window.gm.player.location]; //fallback if unspeced location

  r = _.random(1, places.length) - 1; //chances are equal

  window.gm.addTime(20);
  window.story.show(places[r]);
}; //---------------------------------------------------------------------------------
//TODO Deferred Event is incomplete
//maybe you sometimes dont want to trigger an event immediatly, 
//f.e. if you send a email, it might take some time until you get a response-email 
//(you can receive email at anytime on your phone, so we would have to add checks on ALL passages)
//use this function to push a passage to a stack of deffered events; 
//the passage will trigger under the given condition: minimum time, location-tag, at a certain time-window
//the passage will show when a new passage is requested and will be removed from stack
//if this passage is already pushed, only its condition will be updated


window.gm.pushDeferredEvent = function (id) {
  var cond = {
    waitTime: 6,
    locationTags: ['Home', 'City'],
    //Never trigger in Combat
    dayTime: [1100, 600]
  },
      cond2 = {
    waitTime: 60,
    locationTags: ['Letterbox']
  };
  var xcond = [cond, cond2]; //passage is executed if any of the conds is met

  window.story.state.vars.hairGrow = 10;
};

window.gm.hasDeferredEvent = function () {
  if (window.story.state.vars.hairGrow === 10) return true;
  return false;
};

window.gm.showDeferredEvent = function () {
  var msg = '';
  var namenext = window.passage.name;
  var tagsnext = window.story.passage(namenext).tags;

  if (window.story.state.vars.hairGrow === 10) {
    window.story.state.vars.hairGrow = 0;
    msg += "You notice that your hair has grown quite a bit.</br>";
    msg += window.gm.printPassageLink("Next", window.gm.player.location);
  }

  return msg;
}; //when show is called the previous passage is stored if the new has [_back]-tag
//if the new has no back-tag, the stack gets cleared


window.gm.pushPassage = function (id) {
  if (!window.story.state.hasOwnProperty("vars")) return; //vars exist only after initGame

  if (window.story.state.vars.passageStack.length > 0 && window.story.state.vars.passageStack[window.story.state.vars.passageStack.length - 1] === id) {//already pushed
  } else {
    window.story.state.vars.passageStack.push(id);
  }
}; //call on [_back]-passages to get the previous passage


window.gm.popPassage = function () {
  var pass = window.story.state.vars.passageStack.pop();
  if (!pass) return 'nothing to pop from stack';
  return pass;
}; //overriding show:
//- to enable back-link
//- to intercept with deffered events


var _origStoryShow = window.story.__proto__.show;

window.story.__proto__.show = function (idOrName) {
  var noHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var next = idOrName;

  if (idOrName === '_back') {
    //going back
    next = window.gm.popPassage();
  } else {
    //going forward
    var tagsnext = window.story.passage(next).tags;
    var namenext = window.story.passage(next).name;

    if (tagsnext.indexOf('_back') >= 0) {
      //push on stack but only if not re-showing itself
      if (namenext != window.passage.name) window.gm.pushPassage(window.passage.name);
    } else if (window.story.state.hasOwnProperty("vars")) {
      window.story.state.vars.passageStack.splice(0, window.story.state.vars.passageStack.length);
    }
  } //Todo
  //before entering a new passage check if there is a defferedEvent that we should do first
  //if so, push the normal-passage onto stack, show deffered passage
  //after the deffered passage(s) finish, make sure to show the original passage
  //this is a problem?how do I know the deffered passage is done? 


  _origStoryShow.call(window.story, next, noHistory);
}; //---------------------------------------------------------------------------------


"use strict";
/* bundles some utility operations*/


window.gm = window.gm || {};
window.gm.util = window.gm.util || {}; //updates all panels

window.gm.refreshScreen = function () {
  window.story.show(window.passage.name);
}; //updates only sidepanle,logpanel


window.gm.updateOtherPanels = function () {
  renderToSelector("#sidebar", "sidebar");
  renderToSelector("#LogPanel", "LogPanel");
};

window.gm.pushLog = function (msg) {
  var log = window.story.state.vars.log;
  log.unshift(msg);

  if (log.length > 10) {
    log.splice(log.length - 1, 1);
  }
};

window.gm.getLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  return msg;
};

window.gm.clearLog = function () {
  var log = window.story.state.vars.log;
  var msg = '';

  for (var i = 0; i < log.length; i++) {
    msg += log[i];
  }

  window.story.state.vars.log = [];
  return msg;
};

window.gm.roll = function (n, sides) {
  //rolls n x dies with sides
  var rnd = 0;

  for (var i = 0; i < n; i++) {
    rnd += _.random(1, sides);
  }

  return rnd;
};

window.gm.printOutput = function (text) {
  document.querySelector("section article div output").innerHTML = text;
}; //prints the same kind of link like [[Next]] but can be called from code


window.gm.printPassageLink = function (label, target) {
  return "<a href=\"javascript:void(0)\" data-passage=\"" + target + "\">" + label + "</a></br>";
}; //dynamically build a link representing a buy option including display of cost and restriction
//count specifys how any items you get for cost
//cbCanBuy points to a function fn(itemid) that returns if can buy {OK:false,msg:'too expensive'} 
//cbPostBuy points to a function fn(itemid) that is called after buying ; 


window.gm.printShopBuyEntry = function (itemid, count, cbCanBuy) {
  var cbPostBuy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var desc2 = itemid + 'out of stock</br>';
  var entry = document.createElement('a'); // entry is a link that will expand to item description

  entry.id = itemid;
  entry.href = 'javascript:void(0)';

  var showDesc = function showDesc($event) {
    var elmt = document.querySelector("div#" + $event.srcElement.id);
    elmt.innerHTML = window.gm.ItemsLib[$event.srcElement.id].desc + "</br>";
    elmt.toggleAttribute("hidden");
  };

  entry.addEventListener("click", showDesc, false);
  var div = document.createElement('div');
  div.id = itemid;
  div.hidden = true;
  var entryBuy = document.createElement('a'); //entryBuy is a link that actual buys something or shows why not

  entryBuy.id = itemid;
  entryBuy.href = 'javascript:void(0)';
  entryBuy.textContent = "Buy";

  if (count > 0) {
    var result = cbCanBuy(itemid);
    desc2 = itemid + " (x" + count + ")";

    if (result.OK === false) {
      desc2 = desc2 + " " + result.msg;
    } else {
      desc2 += " " + result.msg;

      var foo = function foo($event) {
        window.gm.buyFromShop(itemid, count, cbPostBuy);
      };

      entryBuy.addEventListener("click", foo, false);
    }
  }

  entry.textContent = desc2;
  $("div#panel")[0].appendChild(entry);
  $("div#panel")[0].appendChild(entryBuy);
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(div);
}; //a callback function to check if you can buy something;
//should return {OK:true,msg:'',postBuy:null} where message will be displayed either as reason why you cannot buy or cost
//unused because makes it unoverridable ->postboy is {fn:foo, cost:x} where fn points to a function that is called after buying (fn(itemid,x));  
//this implementation checks: money


window.gm.defaultCanBuy = function (itemid, cost) {
  var result = {
    OK: true,
    msg: ''
  }; //, postBuy:null};

  var money = window.gm.player.Inv.countItem('Money');

  if (money >= cost) {
    result.msg = 'buy for ' + cost + '$'; //result.postBuy = function(x){ return (function(item,y=x){window.gm.defaultPostBuy(item,y);})}(cost);
    //result.postBuy = {fn:window.gm.defaultPostBuy, cost:cost};
  } else {
    result.OK = false;
    result.msg = 'requires ' + cost + '$';
  }

  ;
  return result;
};

window.gm.defaultCanSell = function (itemid, cost) {
  var result = {
    OK: true,
    msg: ''
  }; //todo check equipped item

  result.msg = 'sell for ' + cost + '$';
  return result;
}; //requires a <div id='choice'> </div> for displaying bought-message


window.gm.defaultPostSell = function (itemid, cost) {
  window.gm.player.Inv.addItem(new Money(), cost);
  $("div#choice")[0].innerHTML = 'You sold ' + itemid;
  $("div#choice")[0].classList.remove("div_alarm");
  $("div#choice")[0].offsetWidth; //this forces the browser to notice the class removal

  $("div#choice")[0].classList.add("div_alarm");
}; //requires a <div id='choice'> </div> for displaying bought-message


window.gm.defaultPostBuy = function (itemid, cost) {
  window.gm.player.Inv.removeItem('Money', cost);
  $("div#choice")[0].innerHTML = 'You bought ' + itemid;
  $("div#choice")[0].classList.remove("div_alarm");
  $("div#choice")[0].offsetWidth; //this forces the browser to notice the class removal

  $("div#choice")[0].classList.add("div_alarm");
};

window.gm.cbCanBuyPerverse = function (itemid, cost, pervcost) {
  var result = window.gm.defaultCanBuy(itemid, cost);

  if (window.gm.player.Stats.get('perversion').value < pervcost) {
    result.msg += ' ; requires Perversion> ' + pervcost;
    result.OK = false;
  }

  return result;
}; //this will add item to player; money-deduct or other cost has to be done in cbPostBuy ! 


window.gm.buyFromShop = function (itemid, count, cbPostBuy) {
  window.gm.player.Inv.addItem(new window.storage.constructors[itemid](), count); //Todo item or wardrobe

  if (cbPostBuy) cbPostBuy(itemid); //window.gm.refreshScreen(); dont refresh fullscreen or might reset modified textoutput

  window.gm.updateOtherPanels(); //just update other panels

  renderToSelector("#panel", "listsell");
}; //this will remove item from player; money-deduct or other cost has to be done in cbPostSell ! 


window.gm.sellToShop = function (itemid, count, cbPostSell) {
  window.gm.player.Inv.removeItem(itemid, count);
  if (cbPostSell) cbPostSell(itemid); //window.gm.refreshScreen(); dont refresh fullscreen or might reset modified textoutput

  window.gm.updateOtherPanels(); //just update other panels

  renderToSelector("#panel", "listsell");
}; //dynamically build a link representing a sell option including display of cost
//count defines how many of this item you have to trade in


window.gm.printShopSellEntry = function (itemid, count, cbCanSell, cbPostSell) {
  var _available = window.gm.player.Inv.countItem(itemid); //only items the player has can be sold


  if (_available <= 0) return;
  var entry = document.createElement('a');
  entry.id = itemid;
  entry.href = 'javascript:void(0)';

  var showDesc = function showDesc($event) {
    var elmt = document.querySelector("div#" + $event.srcElement.id);
    elmt.innerHTML = window.gm.ItemsLib[$event.srcElement.id].desc + "</br>";
    elmt.toggleAttribute("hidden");
  };

  entry.addEventListener("click", showDesc, false);
  var div = document.createElement('div');
  div.id = itemid;
  div.hidden = true;
  var entrySell = document.createElement('a'); //a link where you can sell

  entrySell.id = itemid;
  entrySell.href = 'javascript:void(0)';
  entrySell.textContent = "Sell";
  var desc2 = itemid + " (x" + count + ")";

  if (_available >= count) {
    var result = cbCanSell(itemid);

    if (result.OK === false) {
      desc2 = desc2 + " " + result.msg;
    } else {
      desc2 += " " + result.msg;

      var foo = function foo($event) {
        window.gm.sellToShop(itemid, count, cbPostSell);
      };

      entrySell.addEventListener("click", foo, false);
    }
  } else desc2 = desc2 + " not enough items";

  entry.textContent = desc2;
  $("div#panel")[0].appendChild(entry);
  $("div#panel")[0].appendChild(entrySell);
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(document.createElement('br'));
  $("div#panel")[0].appendChild(div);
}; //prints a link that when clicked picksup an item and places it in the inventory, if itemleft is <0, no link appears


window.gm.printPickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var elmt = '';
  var s = window.story.state;
  if (!(itemleft > 0)) return elmt;
  var desc2 = desc + " (" + itemleft + " left)";
  var msg = 'took ' + itemid;
  elmt += "<a0 id='" + itemid + "' onclick='(function($event){window.gm.pickupAndClear(\"" + itemid + "\", \"" + desc + "\"," + itemleft + "," + cbAfterPickup + ")})(this);'>" + desc2 + "</a></br>";
  return elmt;
};

window.gm.pickupAndClear = function (itemid, desc, itemleft) {
  var cbAfterPickup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  window.gm.player.Inv.addItem(new window.storage.constructors[itemid]()); //window.gm.pushLog("added "+itemid+" to inventory.</br>");

  if (cbAfterPickup) cbAfterPickup();
  window.gm.refreshScreen();
}; //prints an item with description; used in inventory


window.gm.printItem = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  var _inv = window.gm.player.Inv;

  var _count = _inv.countItem(id);

  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, " (x").concat(_count, ")</a>");

  var useable = _inv.usable(id);

  if (_count > 0 && useable.OK) {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){var _res=window.gm.player.Inv.use(\"").concat(id, "\"); window.gm.refreshScreen();window.gm.printOutput(_res.msg);}(this))'>").concat(useable.msg, "</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints an equipment with description; used in wardrobe


window.gm.printEquipment = function (id, descr) {
  var elmt = '';
  var s = window.story.state;
  elmt += "<a0 id='".concat(id, "' onclick='(function($event){document.querySelector(\"div#").concat(id, "\").toggleAttribute(\"hidden\");})(this);'>").concat(id, "</a>");

  if (window.gm.player.Outfit.countItem(id) <= 0) {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.addItem(new window.storage.constructors[\"").concat(id, "\"]()); window.gm.refreshScreen();}(this))'>Equip</a>");
  } else {
    elmt += "<a0 id='".concat(id, "' onclick='(function($event){window.gm.player.Outfit.removeItem(\"").concat(id, "\"); window.gm.refreshScreen();}(this))'>Unequip</a>");
  }

  elmt += "</br><div hidden id='".concat(id, "'>").concat(descr, "</div>");
  if (window.story.passage(id)) elmt += ''.concat("    [[Info|" + id + "]]"); //Todo add comands: drink,eat, use

  elmt += ''.concat("</br>");
  return elmt;
}; //prints a string listing equipped items


window.gm.printEquipmentSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];

  for (var i = 0; i < window.gm.player.Outfit.count(); i++) {
    var id = window.gm.player.Outfit.getItemId(i);

    if (id != '' && ids.indexOf(id) < 0) {
      ids.push(id);
      result += id + ',';
    }
  }

  return result;
}; //prints a string listing equipped items


window.gm.printRelationSummary = function () {
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';
  var ids = window.gm.player.Rel.getAllIds();
  ids.sort();

  for (var k = 0; k < ids.length; k++) {
    if (ids[k].split("_").length === 1) {
      //ignore _min/_max
      var data = window.gm.player.Rel.get(ids[k]);
      result += '<tr><td>' + data.id + ':</td><td>' + data.value + ' of ' + window.gm.player.Rel.get(ids[k] + "_Max").value + '</td></tr>';
    }
  } //todo print mom : 10 of 20


  result += '</table>';
  return result;
}; //prints a string listing stats and effects


window.gm.printEffectSummary = function () {
  var who = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'player';
  var elmt = '';
  var s = window.story.state;
  var result = '';
  var ids = [];
  result += '<table>';
  var ids = window.gm[who].Stats.getAllIds();
  ids.sort(); //Todo better sort

  for (var k = 0; k < ids.length; k++) {
    var data = window.gm[who].Stats.get(ids[k]);

    if (data.hidden !== 4) {
      result += '<tr><td>' + (data.hidden & 0x1 ? '???' : data.id) + ':</td><td>' + (data.hidden & 0x2 ? '???' : data.value) + '</td></tr>';
    }
  }

  result += '</table>';
  result += '</br>Active Effects:<table>';
  ids = window.gm[who].Effects.getAllIds();
  ids.sort(); //Todo better sort

  for (var i = 0; i < ids.length; i++) {
    var data = window.gm[who].Effects.get(ids[i]);
    result += '<tr><td>' + data.id + ':</td><td>' + data.name + '</td></tr>';
  }

  result += '</table>';
  return result;
}; //prints a list of todo quest


window.gm.printTodoList = function () {
  var elmt = '<form><ul style=\"list-style-type: none\" >';
  var s = window.story.state;
  var list = ['qDogSit'];
  elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>always: keep the fridge filled</label></li>";

  for (var i = 0; i < list.length; i++) {
    var val = s.vars[list[i]];
    var msg = '';

    if (list[i] === 'qDogSit') {
      //todo we could use <%=> instead
      if (val <= 0) {} else if (val <= 0x100) {
        msg = 'There was this dogsit-ad in the park. Maybe you should call there to earn some money.';
      } else if (val <= 0x200) {
        msg = 'You called dogsit but didnt get a response...';
      } else if (val <= 0x300) {
        msg = 'Get a task from dogsit!';
      }
    }

    if (msg != '') elmt += "<li><label><input type=\"checkbox\" name=\"y\" value=\"x\" readonly disabled>" + msg + "</label></li>";
  }

  elmt += "</ul></form></br>";
  return elmt;
}; //prints a list of perks for unlock


window.gm.printUnlockPerk = function (id, descr) {
  var elmt = '';
  var s = window.story.state;

  if (window.gm.player[id] == 0 && window.gm.player.skillPoints > 0) {
    elmt += ''.concat("<a0 id='" + id + "' onclick='(function ( $event ) { unlockPerk($event.id); })(this);'>" + descr + "</a>");
    elmt += ''.concat("    [[Info|" + id + "]]");
  } else if (window.gm.player[id] > 0) {
    elmt += id + ": " + descr;
  }

  elmt += ''.concat("</br>");
  return elmt;
}; ///show/hides a dialog defined in body


window.gm.toggleDialog = function (id) {
  var _id = id;
  var dialog = document.querySelector(id),
      closebutton = document.getElementById('close-dialog'),
      pagebackground = document.querySelector('body');
  var div;

  if (!dialog.hasAttribute('open')) {
    // show the dialog 
    div = document.createElement('div');
    div.id = 'backdrop';
    document.body.appendChild(div);
    dialog.setAttribute('open', 'open'); // after displaying the dialog, focus the closebutton inside it

    closebutton.focus();
    closebutton.addEventListener('click', function () {
      window.gm.toggleDialog(_id);
    });
  } else {
    dialog.removeAttribute('open');
    div = document.querySelector('#backdrop');
    div.parentNode.removeChild(div); //??lastFocus.focus();
  }
}; // use child._parent = window.gm.util.refToParent(parent);


window.gm.util.refToParent = function (me) {
  return function () {
    return me;
  };
};

"use strict"; //an Inventory-Component to store items


var Inventory = /*#__PURE__*/function () {
  function Inventory(externlist) {
    _classCallCheck(this, Inventory);

    this.list = externlist ? externlist : [];
    window.storage.registerConstructor(Inventory);
  }

  _createClass(Inventory, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Inventory", this);
    }
  }, {
    key: "_relinkItems",
    value: function _relinkItems() {
      for (var i = 0; i < this.list.length; i++) {
        if (this.list[i].item) this.list[i].item._parent = window.gm.util.refToParent(this);
      }
    }
  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Inventory: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }, {
    key: "count",
    value: function count() {
      return this.list.length;
    }
  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return 0;
      return this.list[_i].count;
    }
  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) return i;
      }

      return -1;
    }
  }, {
    key: "getItemId",
    value: function getItemId(slot) {
      return this.list[slot].id;
    }
  }, {
    key: "getItem",
    value: function getItem(id) {
      var _idx = this.findItemSlot(id);

      if (_idx < 0) throw new Error('no such item: ' + id);
      return this.list[_idx].item;
    } //returns all Ids in list

  }, {
    key: "getAllIds",
    value: function getAllIds() {
      var ids = [];

      for (var i = 0; i < this.list.length; i++) {
        ids.push(this.list[i].id);
      }

      return ids;
    }
  }, {
    key: "addItem",
    value: function addItem(item) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(item.name);

      if (_i < 0) {
        item._parent = window.gm.util.refToParent(this);
        this.list.push({
          'id': item.name,
          'count': count,
          item: item
        });
      } else this.list[_i].count += count;

      this.postItemChange(item.name, "added", "");
    }
  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      this.list[_i].count -= count;
      if (this.list[_i].count < 1) this.list.splice(_i, 1);
      this.postItemChange(this, id, "removed", "");
    } //convience method to check if item is usable

  }, {
    key: "usable",
    value: function usable(id) {
      var _item = this.getItem(id);

      return _item.usable(this);
    } //uses an item by calling item.use

  }, {
    key: "use",
    value: function use(id) {
      var _item = this.getItem(id);

      var result = _item.use(this);

      if (result.OK) {
        this.postItemChange(this, id, "used", result.msg);
      }

      return result;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Inventory, value.data);

      return _x;
    }
  }]);

  return Inventory;
}();

"use strict"; //import {Item} from './Inventory.js';

/* class definiton of items & Equipment */


var Item = /*#__PURE__*/function () {
  function Item(name) {
    _classCallCheck(this, Item);

    this.name = name;
    this.desc = '';
  }

  _createClass(Item, [{
    key: "usable",
    value: function usable(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }]);

  return Item;
}();

function defaultCanUse(context) {
  return {
    OK: true,
    msg: 'usable'
  };
}

function defaultNoUse(context) {
  return {
    OK: false,
    msg: ''
  };
}

function defaultOnUse(context) {
  return {
    OK: true,
    msg: 'You used the item.'
  };
}

function defaultCanUnequip(context) {
  return {
    OK: true,
    msg: ''
  };
}

function defaultNoUnequip(context) {
  return {
    OK: false,
    msg: 'You need to find a key first to be able to remove it!'
  };
}

var LighterDad = /*#__PURE__*/function (_Item) {
  _inherits(LighterDad, _Item);

  var _super = _createSuper(LighterDad);

  function LighterDad() {
    var _this;

    _classCallCheck(this, LighterDad);

    _this = _super.call(this, 'LighterDad');
    _this.desc = 'I got this lighter from my real dad.';
    return _this;
  }

  _createClass(LighterDad, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("LighterDad", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(LighterDad, value.data);
    }
  }]);

  return LighterDad;
}(Item);

;

var Money = /*#__PURE__*/function (_Item2) {
  _inherits(Money, _Item2);

  var _super2 = _createSuper(Money);

  function Money() {
    var _this2;

    _classCallCheck(this, Money);

    _this2 = _super2.call(this, 'Money');
    _this2.desc = 'shiny,clinky coin.';
    return _this2;
  }

  _createClass(Money, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Money", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Money, value.data);
    }
  }]);

  return Money;
}(Item);

;

var LaptopPS = /*#__PURE__*/function (_Item3) {
  _inherits(LaptopPS, _Item3);

  var _super3 = _createSuper(LaptopPS);

  function LaptopPS() {
    var _this3;

    _classCallCheck(this, LaptopPS);

    _this3 = _super3.call(this, 'Laptop-PS');
    _this3.desc = 'Power converter for laptop.';
    return _this3;
  }

  _createClass(LaptopPS, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("LaptopPS", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(LaptopPS, value.data);
    }
  }]);

  return LaptopPS;
}(Item);

;

var Dildo_small = /*#__PURE__*/function (_Item4) {
  _inherits(Dildo_small, _Item4);

  var _super4 = _createSuper(Dildo_small);

  function Dildo_small() {
    var _this4;

    _classCallCheck(this, Dildo_small);

    _this4 = _super4.call(this, 'Dildo_small');
    _this4.desc = 'A dildo, smaller than an average dong, made from rubbery plastic.';
    return _this4;
  }

  _createClass(Dildo_small, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Dildo_small", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Dildo_small, value.data);
    }
  }]);

  return Dildo_small;
}(Item);

;

var Lube = /*#__PURE__*/function (_Item5) {
  _inherits(Lube, _Item5);

  var _super5 = _createSuper(Lube);

  function Lube() {
    var _this5;

    _classCallCheck(this, Lube);

    _this5 = _super5.call(this, 'Lube');
    _this5.desc = 'Slippery lubricant for personal use.';
    return _this5;
  }

  _createClass(Lube, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Lube", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Lube, value.data);
    }
  }]);

  return Lube;
}(Item);

;

var Battery = /*#__PURE__*/function (_Item6) {
  _inherits(Battery, _Item6);

  var _super6 = _createSuper(Battery);

  function Battery() {
    var _this6;

    _classCallCheck(this, Battery);

    _this6 = _super6.call(this, 'Battery');
    _this6.desc = 'Provides electricity for devices.';
    return _this6;
  }

  _createClass(Battery, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Battery", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Battery, value.data);
    }
  }]);

  return Battery;
}(Item);

;

var CanOfCoffee = /*#__PURE__*/function (_Item7) {
  _inherits(CanOfCoffee, _Item7);

  var _super7 = _createSuper(CanOfCoffee);

  function CanOfCoffee() {
    var _this7;

    _classCallCheck(this, CanOfCoffee);

    _this7 = _super7.call(this, 'Can of coffee');
    _this7.desc = 'Cold coffee in a can. Tasty? Not really!';
    return _this7;
  }

  _createClass(CanOfCoffee, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("CanOfCoffee", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return {
        OK: true,
        msg: 'drink'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      if (context instanceof Inventory) {
        context.removeItem('CanOfCoffee');

        if (context.parent instanceof Character) {
          context.parent.addEffect('CanOfCoffee:Energized', new effEnergized()); //apply over-time-effect instead directly changing stat

          return {
            OK: true,
            msg: context.parent.name + ' gulped down a can of iced coffee.'
          };
        }
      } else throw new Error('context is invalid');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(CanOfCoffee, value.data);
    }
  }]);

  return CanOfCoffee;
}(Item);

;

var SimpleFood = /*#__PURE__*/function (_Item8) {
  _inherits(SimpleFood, _Item8);

  var _super8 = _createSuper(SimpleFood);

  function SimpleFood() {
    var _this8;

    _classCallCheck(this, SimpleFood);

    _this8 = _super8.call(this, 'Simple food');
    _this8.desc = 'Something to eat.';
    return _this8;
  }

  _createClass(SimpleFood, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("SimpleFood", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return {
        OK: true,
        msg: 'eat'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      if (context instanceof Inventory) {
        context.removeItem('Simple food');

        if (context.parent instanceof Character) {
          context.parent.addEffect('Simple food:Energized', new effEnergized());
          return {
            OK: true,
            msg: context.parent.name + ' ate some plan foods.'
          };
        }
      } else throw new Error('context is invalid');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(SimpleFood, value.data);
    }
  }]);

  return SimpleFood;
}(Item);

"use strict";

var Mob = /*#__PURE__*/function (_Character) {
  _inherits(Mob, _Character);

  var _super9 = _createSuper(Mob);

  function Mob() {
    _classCallCheck(this, Mob);

    return _super9.apply(this, arguments);
  }

  _createClass(Mob, [{
    key: "calcCombatMove",
    //override to return the next move to execute
    //OK = false if move===null, else true
    //msg should contain a message formatted for view (move description and result) 
    //this function should decide what actions the mob takes; 
    //query _canAct to check if stunned or otherwise incapaciated, then run execCombatCmd(moveNOP) 
    value: function calcCombatMove() {
      var rnd = _.random(1, 100);

      var result = this._canAct();

      if (result.OK === false) {
        window.gm.combat.execCombatCmd(window.gm.combat.moveNOP);
        return result;
      }

      if (rnd > 30) {
        result = window.gm.combat.execCombatCmd(window.gm.combat.movePhysicalAttack);
        result.msg = this.name + " trys to attack you.</br>" + result.msg;
      } else {
        result = window.gm.combat.execCombatCmd(window.gm.combat.moveGuard);
        result.msg = this.name + " takes a defensive stance.</br>" + result.msg;
      }

      return result;
    }
  }]);

  return Mob;
}(Character);

var Mole = /*#__PURE__*/function (_Mob) {
  _inherits(Mole, _Mob);

  var _super10 = _createSuper(Mole);

  function Mole() {
    var _this9;

    _classCallCheck(this, Mole);

    _this9 = _super10.call(this);
    _this9.name = 'Mole';
    _this9.pic = 'assets/mole.jpg';

    _this9.Stats.increment('healthMax', -1 * (_this9.health().max - 20));

    return _this9;
  }

  return Mole;
}(Mob);

;

var Mechanic = /*#__PURE__*/function (_Mob2) {
  _inherits(Mechanic, _Mob2);

  var _super11 = _createSuper(Mechanic);

  function Mechanic() {
    var _this10;

    _classCallCheck(this, Mechanic);

    _this10 = _super11.call(this);
    _this10.name = 'Mechanic-Guy';
    _this10.pic = 'assets/mechanic.jpg';
    return _this10;
  }

  _createClass(Mechanic, [{
    key: "calcCombatMove",
    value: function calcCombatMove() {
      var result = this._canAct();

      if (window.story.state.combat.turnCount < 3) {
        result = window.gm.combat.execCombatCmd(window.gm.combat.moveStun);
        result.msg = this.name + " trys to hit your head whith his wrench.</br>" + result.msg;
        return result;
      }

      return _get(_getPrototypeOf(Mechanic.prototype), "calcCombatMove", this).call(this);
    }
  }]);

  return Mechanic;
}(Mob);

; //this looks weird but works; use this as template how to add more mobs

window.gm.Mobs = function (Mobs) {
  // Private Objekte

  /*var privateVariable = "privat";
  function privateFunktion () {
      alert("privateFunktion wurde aufgerufen\n" +
          "Private Variable: " + privateVariable);
  }*/
  Mobs.Mole = function () {
    return new Mole();
  }; //add Mole-constructor to Mob-ollection


  Mobs.Mechanic = function () {
    return new Mechanic();
  };

  return Mobs;
}(window.gm.Mobs || {});

"use strict";
/* a player has an outfit describing which Equipment (wardrobe,utilities,..) he has equiped
*/
//this is a lookuptable for the equipmentslots


window.gm.OutfitSlotpLib = {
  Legs: 1,
  Feet: 2,
  Arms: 3,
  Torso: 4,
  LHand: 5,
  RHand: 6,
  UWTop: 7,
  UWGroin: 8,
  UWFeet: 9,
  UWLegs: 10,
  Hat: 11,
  Neck: 12,
  Eys: 13,
  //insert more slots here
  SLOTMAX: 50
};

var Equipment = /*#__PURE__*/function (_Item9) {
  _inherits(Equipment, _Item9);

  var _super12 = _createSuper(Equipment);

  function Equipment(name) {
    var _this11;

    _classCallCheck(this, Equipment);

    _this11 = _super12.call(this, name);
    _this11.tags = [];
    _this11.slotUse = [];
    return _this11;
  } // Attention !!
  //_parent will be added dynamical


  _createClass(Equipment, [{
    key: "usable",
    //for compatibility with item
    value: function usable(context) {
      return {
        OK: false,
        msg: 'Useable in wardrobe'
      };
    }
  }, {
    key: "use",
    value: function use(context) {
      return {
        OK: false,
        msg: 'Cannot use.'
      };
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: false,
        msg: 'unusable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }]);

  return Equipment;
}(Item);

exports.Equipment = Equipment;

var Leggings = /*#__PURE__*/function (_Equipment) {
  _inherits(Leggings, _Equipment);

  var _super13 = _createSuper(Leggings);

  function Leggings() {
    var _this12;

    _classCallCheck(this, Leggings);

    _this12 = _super13.call(this, 'Leggings');
    _this12.tags = ['cloth'];
    _this12.slotUse = ['Legs'];
    _this12.desc = 'Spandex-leggings for sport. (agility+)';
    window.storage.registerConstructor(Leggings);
    return _this12;
  }

  _createClass(Leggings, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Leggings", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('agility', {
        id: 'agility:Leggings',
        bonus: 5
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('agility', {
        id: 'agility:Leggings'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Leggings, value.data);
    }
  }]);

  return Leggings;
}(Equipment);

exports.Leggings = Leggings;

var Jeans = /*#__PURE__*/function (_Equipment2) {
  _inherits(Jeans, _Equipment2);

  var _super14 = _createSuper(Jeans);

  function Jeans() {
    var _this13;

    _classCallCheck(this, Jeans);

    _this13 = _super14.call(this, 'Jeans');
    _this13.tags = ['cloth'];
    _this13.slotUse = ['Legs'];
    _this13.desc = 'plain old blue jeans';
    window.storage.registerConstructor(Jeans);
    return _this13;
  }

  _createClass(Jeans, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Jeans", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Jeans, value.data);
    }
  }]);

  return Jeans;
}(Equipment);

exports.Jeans = Jeans;

var TankShirt = /*#__PURE__*/function (_Equipment3) {
  _inherits(TankShirt, _Equipment3);

  var _super15 = _createSuper(TankShirt);

  function TankShirt() {
    var _this14;

    _classCallCheck(this, TankShirt);

    _this14 = _super15.call(this, 'TankShirt');
    _this14.tags = ['cloth'];
    _this14.slotUse = ['Torso'];
    _this14.desc = 'light blue tank-top';
    window.storage.registerConstructor(TankShirt);
    return _this14;
  }

  _createClass(TankShirt, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("TankShirt", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(TankShirt, value.data);
    }
  }]);

  return TankShirt;
}(Equipment);

exports.TankShirt = TankShirt;

var Pullover = /*#__PURE__*/function (_Equipment4) {
  _inherits(Pullover, _Equipment4);

  var _super16 = _createSuper(Pullover);

  function Pullover() {
    var _this15;

    _classCallCheck(this, Pullover);

    _this15 = _super16.call(this, 'Pullover');
    _this15.tags = ['cloth'];
    _this15.slotUse = ['Torso', 'Arms'];
    _this15.desc = 'warm pullover';
    window.storage.registerConstructor(Pullover);
    return _this15;
  }

  _createClass(Pullover, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Pullover", this);
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      return {
        OK: true,
        msg: 'equipable'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Pullover, value.data);
    }
  }]);

  return Pullover;
}(Equipment); //this is an Inventory-item, not wardrobe


exports.Pullover = Pullover;

var Crowbar = /*#__PURE__*/function (_Equipment5) {
  _inherits(Crowbar, _Equipment5);

  var _super17 = _createSuper(Crowbar);

  function Crowbar() {
    var _this16;

    _classCallCheck(this, Crowbar);

    _this16 = _super17.call(this, 'Crowbar');
    _this16.desc = 'A durable crowbar.';
    _this16.tags = ['tool', 'weapon'];
    _this16.slotUse = ['RHand'];
    window.storage.registerConstructor(Crowbar);
    return _this16;
  }

  _createClass(Crowbar, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Crowbar", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return this.canEquip();
    }
  }, {
    key: "use",
    value: function use(context) {
      //context here is inventory not outfit
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) {
        this.parent.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: 'unequipped ' + this.name
        }; //todo
      } else {
        this.parent.parent.Outfit.addItem(this);
        return {
          OK: true,
          msg: 'equipped ' + this.name
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      };else return {
        OK: true,
        msg: 'equip'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('pAttack', {
        id: 'pAttack:Crowbar',
        bonus: 2
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('pAttack', {
        id: 'pAttack:Crowbar'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Crowbar, value.data);
    }
  }]);

  return Crowbar;
}(Equipment); //this is an Inventory-item, not wardrobe


exports.Crowbar = Crowbar;

var Shovel = /*#__PURE__*/function (_Equipment6) {
  _inherits(Shovel, _Equipment6);

  var _super18 = _createSuper(Shovel);

  function Shovel() {
    var _this17;

    _classCallCheck(this, Shovel);

    _this17 = _super18.call(this, 'Shovel');
    _this17.desc = 'A rusty,old shovel.';
    _this17.tags = ['tool', 'weapon'];
    _this17.slotUse = ['RHand', 'LHand'];
    window.storage.registerConstructor(Shovel);
    return _this17;
  }

  _createClass(Shovel, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Shovel", this);
    }
  }, {
    key: "usable",
    value: function usable(context) {
      return this.canEquip();
    }
  }, {
    key: "use",
    value: function use(context) {
      //context here is inventory not outfit
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) {
        this.parent.parent.Outfit.removeItem(this.name);
        return {
          OK: true,
          msg: 'unequipped ' + this.name
        }; //todo
      } else {
        this.parent.parent.Outfit.addItem(this);
        return {
          OK: true,
          msg: 'equipped ' + this.name
        }; //todo
      }
    }
  }, {
    key: "canEquip",
    value: function canEquip() {
      if (this.parent.parent.Outfit.findItemSlot(this.name).length > 0) return {
        OK: true,
        msg: 'unequip'
      };else return {
        OK: true,
        msg: 'equip'
      };
    }
  }, {
    key: "canUnequip",
    value: function canUnequip() {
      return {
        OK: true,
        msg: 'unequipable'
      };
    }
  }, {
    key: "onEquip",
    value: function onEquip() {
      this.parent.parent.Stats.addModifier('pAttack', {
        id: 'pAttack:Shovel',
        bonus: 2
      });
      return {
        OK: true,
        msg: 'equipped'
      };
    }
  }, {
    key: "onUnequip",
    value: function onUnequip() {
      this.parent.parent.Stats.removeModifier('pAttack', {
        id: 'pAttack:Shovel'
      });
      return {
        OK: true,
        msg: 'unequipped'
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Shovel, value.data);
    }
  }]);

  return Shovel;
}(Equipment); //a kind of special inventory for worn equipment


exports.Shovel = Shovel;

var Outfit = /*#__PURE__*/function (_Inventory) {
  _inherits(Outfit, _Inventory);

  var _super19 = _createSuper(Outfit);

  function Outfit(externlist) {
    var _this18;

    _classCallCheck(this, Outfit);

    _this18 = _super19.call(this, externlist); //create each slot

    for (var i = 0; i < window.gm.OutfitSlotpLib.SLOTMAX; i++) {
      if (_this18.list.length - 1 < i) {
        _this18.list.push({
          id: '',
          item: null
        }); // {id:'Leggings'}

      }
    }

    window.storage.registerConstructor(Outfit);
    return _this18;
  }

  _createClass(Outfit, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Outfit", this);
    }
  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Outfit: ' + operation + ' ' + id + ' ' + msg + '</br>');
    } //count how many slots are used by an item

  }, {
    key: "countItem",
    value: function countItem(id) {
      var _i = this.findItemSlot(id);

      return _i.length;
    } //detect which slots are used by a item

  }, {
    key: "findItemSlot",
    value: function findItemSlot(id) {
      var _idx = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].id === id) _idx.push(i);
      }

      return _idx;
    } //override because findItemSlot returns array

  }, {
    key: "getItem",
    value: function getItem(id) {
      var _idx = this.findItemSlot(id);

      if (_idx.length < 0) throw new Error('no such item: ' + id);
      return this.list[_idx[0]].item;
    }
  }, {
    key: "canEquipSlot",
    value: function canEquipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipSlot",
    value: function canUnequipSlot(slot) {
      return {
        OK: true
      };
    }
  }, {
    key: "canUnequipItem",
    value: function canUnequipItem(id, force) {
      var _idx = this.findItemSlot(id);

      var _item = this.getItem(id);

      var result = _item.canUnequip();

      for (var i = 0; i < _idx.length; i++) {
        var _tmp = this.canUnequipSlot(_idx[i]);

        if (!_tmp.OK) result.msg += _tmp.msg + " ";
        result.OK = result.OK && _tmp.OK;
      }

      return result;
    }
  }, {
    key: "addItem",
    value: function addItem(item, force) {
      var _idx = this.findItemSlot(item.name);

      if (_idx.length > 0) return; //already equipped

      var _item = item;
      _idx = _item.slotUse.map(function (cv, ix, arr) {
        return window.gm.OutfitSlotpLib[cv];
      });
      var _oldIDs = [];
      var _oldSlots = [];
      var result = {
        OK: true,
        msg: ''
      };

      for (var l = 0; l < _idx.length; l++) {
        //check if the current equip can be unequipped
        var oldId = this.getItemId(_idx[l]);
        if (oldId === '') continue;

        if (_oldIDs.indexOf(oldId) < 0) {
          _oldIDs.push(oldId);

          _oldSlots = _oldSlots.concat(this.getItem(oldId).slotUse.map(function (cv, ix, arr) {
            return window.gm.OutfitSlotpLib[cv];
          }));
        }

        var _tmp = this.canUnequipItem(oldId);

        if (!_tmp.OK) result.msg += _tmp.msg; //todo duplicated msg if item uses multiple slots

        result.OK = result.OK && _tmp.OK; //Todo  check if slot is available fo equip this canEquipSlot(_idx[l])
      }

      if (!result.OK) {
        this.postItemChange(_item.name, "equip_fail:", result.msg);
        return;
      }

      for (var m = 0; m < _oldIDs.length; m++) {
        this.getItem(_oldIDs[m]).onUnequip(this);
      }

      for (var i = 0; i < _oldSlots.length; i++) {
        this.__clearSlot(_oldSlots[i]);
      }

      for (var k = 0; k < _idx.length; k++) {
        this.list[_idx[k]].id = _item.name;
        this.list[_idx[k]].item = _item;
      }

      _item._parent = window.gm.util.refToParent(this); //Todo currently we have 2 copies of equipment - 1 for wardrobe 1 for outfit otherwise this will not work

      result = _item.onEquip();
      this.postItemChange(_item.name, "equipped", result.msg);
    } //assumme that it was checked before that unequip is allowed

  }, {
    key: "__clearSlot",
    value: function __clearSlot(slot, force) {
      this.list[slot].id = '', this.list[slot].item = null;
    }
  }, {
    key: "removeItem",
    value: function removeItem(id, force) {
      var _idx = this.findItemSlot(id);

      if (_idx.length === 0) return; //already unequipped

      var result = this.canUnequipItem(id);

      if (!result.OK) {
        this.postItemChange(id, "unequip_fail", result.msg);
        return;
      }

      var _item = this.getItem(id);

      result = _item.onUnequip(this);

      for (var i = 0; i < _idx.length; i++) {
        this.__clearSlot(_idx[i]);
      }

      this.postItemChange(id, "removed", result.msg); //Todo delete _item;    //un-parent
    }
  }, {
    key: "isNaked",
    value: function isNaked() {
      //TODO
      if (this.getItemId(window.gm.OutfitSlotpLib.Legs) === '' || this.getItemId(window.gm.OutfitSlotpLib.Torso) === '') {
        return true;
      }

      return false;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(Outfit, value.data);
    }
  }]);

  return Outfit;
}(Inventory);

exports.Outfit = Outfit;
"use strict"; //operations for save/reload
// ??window.onload = function() {};


window.storage = {
  // A list of constructors the smart reviver should know about  
  // you need to register the class of each object that you want to serialize to this list
  // and each class also has to have a method toJSON and static method fromJSON (calling Generic_-versions, see below )
  constructors: {},
  registerConstructor: function registerConstructor(ctor) {
    window.storage.constructors[ctor.name] = ctor;
  },
  // A generic "smart reviver" function.
  // Looks for object values with a `ctor` property and
  // a `data` property. If it finds them, and finds a matching
  // constructor that has a `fromJSON` property on it, it hands
  // off to that `fromJSON` fuunction, passing in the value.
  Reviver: function Reviver(key, value) {
    //console.info( 'reviver with key =' + key )
    var ctor;

    if (value !== null && _typeof(value) === "object" && typeof value.ctor === "string" && typeof value.data !== "undefined") {
      ctor = window.storage.constructors[value.ctor] || window[value.ctor];

      if (typeof ctor === "function" && typeof ctor.fromJSON === "function") {
        return ctor.fromJSON(value);
      }
    }

    return value;
  },
  //this function works with Json.stringify to remove circular references
  // unused because Reviver has even more problems with that

  /*_replacerFunc: function(){
    const visited = new WeakSet();
    return (key, value) => {
      if (value !== null && typeof value === "object") {
        if (visited.has(value)) {  return;  }
        visited.add(value);
      }
      return value;
    };
  },*/
  // A generic "toJSON" function that creates the data expected by Reviver.
  // `ctorName`  The name of the constructor to use to revive it
  // `obj`       The object being serialized
  // `keys`      (Optional) Array of the properties to serialize,
  //             if not given then all of the objects "own" properties
  //             that don't have function values will be serialized.
  //             (Note: If you list a property in `keys`, it will be serialized
  //             regardless of whether it's an "own" property.)
  // Returns:    The structure (which will then be turned into a string
  //             as part of the JSON.stringify algorithm)
  // Stringify it with a replacer: var str = JSON.stringify(myObj);
  Generic_toJSON: function Generic_toJSON(ctorName, obj, keys) {
    var data, index, key;

    if (!keys) {
      keys = Object.keys(obj); // Only "own" properties are included
    }

    data = {};

    for (index = 0; index < keys.length; ++index) {
      key = keys[index];
      data[key] = obj[key]; //TODO causes infinite loop on circular ref   Character->Inventory->Character
    }

    return {
      ctor: ctorName,
      data: data
    };
  },
  // A generic "fromJSON" function for use with Reviver: Just calls the
  // constructor function with no arguments, then applies all of the
  // key/value pairs from the raw data to the instance.
  // Only useful for constructors that can be reasonably called without arguments!
  // `ctor`      The constructor to call
  // `data`      The data to apply
  // Returns:    The object
  Generic_fromJSON: function Generic_fromJSON(ctor, data) {
    var obj, name, setter, setter2;
    obj = new ctor();

    for (name in data) {
      setter = "set" + name[0].toUpperCase() + name.substr(1); // we get the name of the setter for that property (e.g. : key=property => setter=setProperty
      // that kind of names cannot be found in obj??? setter2 = "set "+name.substr(1); // e.g. : key=_property => setter=set property   (javascript style setter)

      if (setter in obj) {
        // if the setter exists 
        obj[setter](data[name]); // we call the setter
        // } else if(setter2 in obj){ // ..or...
        //   obj[setter2](data[name]); 
      } else {
        // if not, we set it directly
        if (_typeof(obj[name]) === "object") {
          Object.assign(obj[name], data[name]);
        } else {
          obj[name] = data[name]; //todo ??? obj[name] is constructed properly but will be overwritten with data[namme]; use assign ?!
        }
      }
    }

    return obj;
  },
  ok: function ok() {
    try {
      var storage = window["localStorage"],
          x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && ( // everything except Firefox
      e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' || // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  },
  delete: function _delete(slot) {
    window.localStorage.removeItem(slot);
    window.localStorage.removeItem(slot.concat('info'));
  },
  getSaveInfo: function getSaveInfo(slot) {
    var info = null;

    if (window.storage.ok()) {
      info = window.localStorage.getItem(slot.concat('info'));
    }

    if (!info) {
      return '';
    }

    return info;
  },
  compressLocalSave: false,
  //this is for debugging (save file uncompressed)
  loadFile: function loadFile(input) {
    var file = input.files[0];
    var fileReader = new FileReader();

    fileReader.onload = function () {
      window.storage.rebuildFromSave(fileReader.result, window.storage.compressLocalSave);
      div = document.querySelector('#backdrop'); //see save/load dialog

      div.parentNode.removeChild(div);
    };

    fileReader.onerror = function () {
      alert(fileReader.error);
    };

    fileReader.readAsText(file);
    return true; //todo how to make async
  },
  saveFile: function saveFile() {
    var hash = JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    });
    if (window.storage.compressLocalSave) hash = LZString.compressToBase64(hash);
    var filename = window.story.name + "_Save.dat";
    var blob = new Blob([hash], {
      type: "text/plain;charset=utf-8"
    });
    saveAs(blob, filename);
  },
  saveBrowser: function saveBrowser(slot) {
    //var hash= window.story.save();    this call somehow messes up html and I had to copy the following from snowman script
    var hash = LZString.compressToBase64(JSON.stringify({
      state: window.story.state,
      history: window.story.history,
      checkpointName: window.story.checkpointName
    }));
    var options = {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    };
    var info = window.gm.player.location + ' - ' + new Intl.DateTimeFormat("default", options).format(new Date());
    window.localStorage.setItem(slot.concat('info'), info);
    window.localStorage.setItem(slot, hash); //document.querySelector("output").textContent = info;  //causes problems because page reset to start-Index.html??

    return info;
  },
  loadBrowser: function loadBrowser(slot) {
    var hash, info;

    if (window.storage.ok()) {
      //not possible to save object {info,hash} ??
      hash = window.localStorage.getItem(slot);
      info = window.storage.getSaveInfo(slot);
      window.storage.rebuildFromSave(hash, true);
    }

    return info;
  },
  rebuildFromSave: function rebuildFromSave(hash, compressed) {
    if (!compressed) hash = LZString.compressToBase64(hash); //copied from window.story.restore because reviver  //window.story.restore(hash) ;

    var save = JSON.parse(LZString.decompressFromBase64(hash), window.storage.Reviver);
    window.story.state = save.state;
    window.story.history = save.history;
    window.story.checkpointName = save.checkpointName;
    window.gm.rebuildObjects(); // this is for handling version-upgrades

    window.story.show(window.story.history[window.story.history.length - 1], true);
  }
};
/*  //save demo
window.gm.testsaveReviver = function () {
  window.storage.registerConstructor(Bar);
  window.storage.registerConstructor(Foo);
  var before = {
    foo: new Foo(21, 44),foo2: new Foo(100, 111),
  };
  before.foo.print(); // Stringify it with a replacer:
  var str = JSON.stringify(before); // Show that
  console.log(str); // Re-create it with use of a "reviver" function
  var after = JSON.parse(str, window.storage.Reviver);
  after.foo.print();after.foo2.print();
};
class Bar {
  constructor(x) {
    this.__type="Bar";
    this._x = x;
  }
  get parent() {return this._parent();}
  print() {      console.log("parent="+this.parent.a.toString()+ this._x);    };
 toJSON() {return window.storage.Generic_toJSON("Bar", this); };
 static fromJSON(value) { return window.storage.Generic_fromJSON(Bar, value.data);};
}

class Foo {
  constructor(a=0, b=0) {
    this.__type = 'Foo';
    this.a = a, this.b = b;
    this._bar = new Bar('fooboo'+this.a.toString());
    this._bar2 = new Bar('ba2'+this.b.toString());
    this._bar._parent = (function(me){ return function(){return me;}}(this));
    this._bar2._parent = (function(me){ return function(){return me;}}(this));
  }
  toJSON() {return window.storage.Generic_toJSON("Foo", this); };
  static fromJSON(value) { return window.storage.Generic_fromJSON(Foo, value.data);};
  setA(a) {   this.a = -1 * a;  };
  print() {console.log(this.a.toString()); this._bar.print(); this._bar2.print();  };
}
*/

/* this should also work instead of reviver
window.gm.testsaveAssign = function () {
  var before = {
    foo: new Foo(21, 44)
  };
  before.foo.print(); // Stringify it with a replacer:
  var str = JSON.stringify(before); // Show that
  console.log(str); // Re-create it with use of a "reviver" function
  var after = window.storage.assignType(str);
  after.foo.print();
};*/

/*assignType: function(object){
    if(object && typeof(object) === 'object' && window[object.__type]) {
        object = window.storage.assignTypeRecursion(object.__type, object);
    }
    return object;
  },
  assignTypeRecursion: function(type, object){
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var obj = object[key];
            if(Array.isArray(obj)){
                 for(var i = 0; i < obj.length; ++i){
                     var arrItem = obj[i];
                     if(arrItem && typeof(arrItem) === 'object' && window[arrItem.__type]) {
                         obj[i] = window.storage.assignTypeRecursion(arrItem.__type, arrItem);
                     }
                 }
            } else  if(obj && typeof(obj) === 'object' && window[obj.__type]) {
                object[key] = window.storage.assignTypeRecursion(obj.__type, obj);
            }
        }
    }
    return Object.assign(new window[type](), object);
  },*/

"use strict";
/* 
 */


"use strict";

/* classes to affect...: 
    - the state of a character like     'tired'
    - stats of a character like healthMax
    - 
 */
///////////////////////////////////////////////////////////////
var StatsDictionary = /*#__PURE__*/function (_Inventory2) {
  _inherits(StatsDictionary, _Inventory2);

  var _super20 = _createSuper(StatsDictionary);

  //Todo a collection of Stats is similiar to Inventory?
  function StatsDictionary(externlist) {
    var _this19;

    _classCallCheck(this, StatsDictionary);

    _this19 = _super20.call(this, externlist);
    window.storage.registerConstructor(StatsDictionary);
    return _this19;
  }

  _createClass(StatsDictionary, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("StatsDictionary", this);
    }
  }, {
    key: "get",
    //
    value: function get(id) {
      return this.getItem(id);
    }
  }, {
    key: "modifyHidden",
    value: function modifyHidden(id, hidden) {
      var _data = this.get(id).data;
      _data.hidden = hidden;
    } // adds a modifier to a Stat or replaces it

  }, {
    key: "addModifier",
    value: function addModifier(toId, modData) {
      var _stat = this.get(toId);

      var _oldMods = _stat.data.modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);

      _oldMods.push(modData);

      window.gm.pushLog(_stat.Calc().msg);
    }
  }, {
    key: "removeModifier",
    value: function removeModifier(toId, modData) {
      var _stat = this.get(toId);

      var _oldMods = _stat.data.modifier;

      var _x = -1;

      for (var i = 0; i < _oldMods.length; i++) {
        if (_oldMods[i].id === modData.id) _x = i;
      }

      if (_x >= 0) _oldMods.splice(_x, 1);
      window.gm.pushLog(_stat.Calc().msg);
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Stats: ' + operation + ' ' + id + ' ' + msg + '</br>');
    } //override; only use to create new stats !

  }, {
    key: "addItem",
    value: function addItem(stat) {
      var _i = this.findItemSlot(stat.name);

      if (_i < 0) {
        stat._parent = window.gm.util.refToParent(this);
        this.list.push({
          'id': stat.name,
          'count': 1,
          item: stat
        });
      }
    } //override

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      var _stat = this.get(id);

      this.list.splice(_i, 1);

      _stat.calc(); //trigger update of dependent stat

    }
  }, {
    key: "increment",
    value: function increment(id, value) {
      var attr = this.get(id);
      attr.data.base += value;
      window.gm.pushLog(attr.Calc(this, id).msg);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(StatsDictionary, value.data);

      return _x;
    }
  }]);

  return StatsDictionary;
}(Inventory); //class for an Attribute


exports.StatsDictionary = StatsDictionary;

var Stat = /*#__PURE__*/function () {
  _createClass(Stat, [{
    key: "parent",
    // Attention !!
    //_parent will be added dynamical
    get: function get() {
      return this._parent();
    } //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};

  }], [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: '',
        base: 0,
        value: 0,
        limits: [],
        modifier: [],
        modifys: [],
        hidden: 0
      }; //limit = {id: min: max:}   limit to apply to value and base
      //modifier {id: calc:}      Stat that modifys value, calc is function(context,data)=> newvalue
      //modifys {id:}         point to the Stats that have modifiers from this stat or is used as limit
      //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
  }]);

  function Stat() {
    _classCallCheck(this, Stat);

    this.data = Stat.dataPrototype();
  }

  _createClass(Stat, [{
    key: "Calc",
    //this is called to update value of the stat and will trigger calculation of dependend stats 
    value: function Calc() {
      var attr = this.data;
      var min = -99999;
      var max = 99999;
      var msg = ''; //get limits

      for (var k = 0; k < attr.limits.length; k++) {
        if (attr.limits[k].min !== '') min = Math.max(this.parent.get(attr.limits[k].min).value, min); //this might behave odly if any min>max

        if (attr.limits[k].max !== '') max = Math.min(this.parent.get(attr.limits[k].max).value, max);
      } //recalculate modifiers


      var _old = attr.value;
      attr.base = attr.value = Math.max(min, Math.min(max, attr.base));

      for (var i = 0; i < attr.modifier.length; i++) {
        attr.value += attr.modifier[i].bonus;
      }

      var _new = Math.max(min, Math.min(max, attr.value));

      attr.value = _new;
      msg += this.formatMsgStatChange(attr, _new, _old); //todo no log hidden

      this.updateModifier(); //trigger recalculation of dependend Stats

      for (var m = 0; m < attr.modifys.length; m++) {
        msg += this.parent.get(attr.modifys[m].id).Calc().msg;
      }

      return {
        OK: true,
        msg: msg
      };
    }
  }, {
    key: "formatMsgStatChange",
    value: function formatMsgStatChange(attr, _new, _old) {
      if (_new - _old > 0) {
        return '<statup>' + attr.id + " regenerated by " + (_new - _old).toFixed(1).toString() + "</statup></br>";
      } else if (_new - _old < 0) {
        return '<statdown>' + attr.id + " decreased by " + (_new - _old).toFixed(1).toString() + "</statdown></br>";
      }

      return "";
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {}
  }, {
    key: "name",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "id",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "base",
    get: function get() {
      return this.data.base;
    }
  }, {
    key: "value",
    get: function get() {
      return this.data.value;
    }
  }, {
    key: "hidden",
    get: function get() {
      return this.data.hidden;
    }
  }]);

  return Stat;
}(); //this is special stat used together with Relation-collection
//person is used as id instead of stat-name


exports.Stat = Stat;

var stRelation = /*#__PURE__*/function (_Stat) {
  _inherits(stRelation, _Stat);

  var _super21 = _createSuper(stRelation);

  _createClass(stRelation, null, [{
    key: "setup",
    value: function setup(context, base, max, person) {
      //todo Max-Limit
      var _stat = new stRelation();

      var _n = _stat.data;
      _n.id = person + "_Max", _n.base = max, _n.value = max;
      context.addItem(_stat);
      _stat = new stRelation();
      _n = _stat.data;
      _n.id = person + "_Min", _n.base = 0, _n.value = 0;
      context.addItem(_stat);
      _stat = new stRelation();
      _n = _stat.data;
      _n.id = person, _n.base = base, _n.value = base, _n.limits = [{
        max: person + "_Max",
        min: person + "_Min"
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stRelation() {
    var _this20;

    _classCallCheck(this, stRelation);

    _this20 = _super21.call(this);
    window.storage.registerConstructor(stRelation);
    return _this20;
  }

  _createClass(stRelation, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stRelation", this);
    }
  }, {
    key: "formatMsgStatChange",
    value: function formatMsgStatChange(attr, _new, _old) {
      if (_new - _old > 0) {
        return '<statup>Your relation to ' + attr.id + " improved by " + (_new - _old).toFixed(1).toString() + "</statup></br>";
      } else if (_new - _old < 0) {
        return '<statdown>Your relation to ' + attr.id + " worsend by " + (_new - _old).toFixed(1).toString() + "</statdown></br>";
      } else {
        return 'Your relation to ' + attr.id + " wasnt affected at all by your behaviour.</br>";
      }
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stRelation, value.data);
    }
  }]);

  return stRelation;
}(Stat);

var stHealthMax = /*#__PURE__*/function (_Stat2) {
  _inherits(stHealthMax, _Stat2);

  var _super22 = _createSuper(stHealthMax);

  _createClass(stHealthMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stHealthMax();

      var _n = _stat.data;
      _n.id = 'healthMax', _n.base = max, _n.value = max, _n.modifys = [{
        id: 'health'
      }];
      context.addItem(_stat); //_stat.Calc(); cause problem because health not yet present
    }
  }]);

  function stHealthMax() {
    var _this21;

    _classCallCheck(this, stHealthMax);

    _this21 = _super22.call(this);
    window.storage.registerConstructor(stHealthMax);
    return _this21;
  }

  _createClass(stHealthMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stHealthMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stHealthMax, value.data);
    }
  }]);

  return stHealthMax;
}(Stat);

var stHealth = /*#__PURE__*/function (_Stat3) {
  _inherits(stHealth, _Stat3);

  var _super23 = _createSuper(stHealth);

  _createClass(stHealth, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stHealthMax.setup(context, max);

      var _stat = new stHealth();

      var _n = _stat.data;
      _n.id = 'health', _n.base = base, _n.value = base, _n.limits = [{
        max: 'healthMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stHealth() {
    var _this22;

    _classCallCheck(this, stHealth);

    _this22 = _super23.call(this);
    window.storage.registerConstructor(stHealth);
    return _this22;
  }

  _createClass(stHealth, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stHealth", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stHealth, value.data);
    }
  }]);

  return stHealth;
}(Stat);

var stEnergyMax = /*#__PURE__*/function (_Stat4) {
  _inherits(stEnergyMax, _Stat4);

  var _super24 = _createSuper(stEnergyMax);

  _createClass(stEnergyMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stEnergyMax();

      var _n = _stat.data;
      _n.id = 'energyMax', _n.base = max, _n.value = max, _n.modifys = [{
        id: 'energy'
      }];
      ;
      context.addItem(_stat); //_stat.Calc();
    }
  }]);

  function stEnergyMax() {
    var _this23;

    _classCallCheck(this, stEnergyMax);

    _this23 = _super24.call(this);
    window.storage.registerConstructor(stEnergyMax);
    return _this23;
  }

  _createClass(stEnergyMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEnergyMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEnergyMax, value.data);
    }
  }]);

  return stEnergyMax;
}(Stat);

var stEnergy = /*#__PURE__*/function (_Stat5) {
  _inherits(stEnergy, _Stat5);

  var _super25 = _createSuper(stEnergy);

  _createClass(stEnergy, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stEnergyMax.setup(context, max);

      var _stat = new stEnergy();

      var _n = _stat.data;
      _n.id = 'energy', _n.base = base, _n.value = base, _n.limits = [{
        max: 'energyMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stEnergy() {
    var _this24;

    _classCallCheck(this, stEnergy);

    _this24 = _super25.call(this);
    window.storage.registerConstructor(stEnergy);
    return _this24;
  }

  _createClass(stEnergy, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEnergy", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEnergy, value.data);
    }
  }]);

  return stEnergy;
}(Stat);

var stArousalMax = /*#__PURE__*/function (_Stat6) {
  _inherits(stArousalMax, _Stat6);

  var _super26 = _createSuper(stArousalMax);

  _createClass(stArousalMax, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stArousalMax();

      var _n = _stat.data;
      _n.id = 'arousalMax', _n.base = max, _n.value = max, _n.hidden = 3;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousalMax() {
    var _this25;

    _classCallCheck(this, stArousalMax);

    _this25 = _super26.call(this);
    window.storage.registerConstructor(stArousalMax);
    return _this25;
  }

  _createClass(stArousalMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousalMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousalMax, value.data);
    }
  }]);

  return stArousalMax;
}(Stat);

var stArousalMin = /*#__PURE__*/function (_Stat7) {
  _inherits(stArousalMin, _Stat7);

  var _super27 = _createSuper(stArousalMin);

  _createClass(stArousalMin, null, [{
    key: "setup",
    value: function setup(context, max) {
      var _stat = new stArousalMin();

      var _n = _stat.data;
      _n.id = 'arousalMin', _n.base = 0, _n.value = 0, _n.hidden = 1;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousalMin() {
    var _this26;

    _classCallCheck(this, stArousalMin);

    _this26 = _super27.call(this);
    window.storage.registerConstructor(stArousalMin);
    return _this26;
  }

  _createClass(stArousalMin, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousalMin", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousalMin, value.data);
    }
  }]);

  return stArousalMin;
}(Stat);

var stArousal = /*#__PURE__*/function (_Stat8) {
  _inherits(stArousal, _Stat8);

  var _super28 = _createSuper(stArousal);

  _createClass(stArousal, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stArousalMax.setup(context, max);
      stArousalMin.setup(context, 0);

      var _stat = new stArousal();

      var _n = _stat.data;
      _n.id = 'arousal', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: 'arousalMax',
        min: 'arousalMin'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stArousal() {
    var _this27;

    _classCallCheck(this, stArousal);

    _this27 = _super28.call(this);
    window.storage.registerConstructor(stArousal);
    return _this27;
  }

  _createClass(stArousal, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stArousal", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stArousal, value.data);
    }
  }]);

  return stArousal;
}(Stat);

var stPerversionMax = /*#__PURE__*/function (_Stat9) {
  _inherits(stPerversionMax, _Stat9);

  var _super29 = _createSuper(stPerversionMax);

  _createClass(stPerversionMax, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      var _stat = new stPerversionMax();

      var _n = _stat.data;
      _n.id = 'perversionMax', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: '',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPerversionMax() {
    var _this28;

    _classCallCheck(this, stPerversionMax);

    _this28 = _super29.call(this);
    window.storage.registerConstructor(stPerversionMax);
    return _this28;
  }

  _createClass(stPerversionMax, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPerversionMax", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPerversionMax, value.data);
    }
  }]);

  return stPerversionMax;
}(Stat);

var stPerversion = /*#__PURE__*/function (_Stat10) {
  _inherits(stPerversion, _Stat10);

  var _super30 = _createSuper(stPerversion);

  _createClass(stPerversion, null, [{
    key: "setup",
    value: function setup(context, base, max) {
      stPerversionMax.setup(context, max);

      var _stat = new stPerversion();

      var _n = _stat.data;
      _n.id = 'perversion', _n.hidden = 3, _n.base = base, _n.value = base, _n.limits = [{
        max: 'perversionMax',
        min: ''
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPerversion() {
    var _this29;

    _classCallCheck(this, stPerversion);

    _this29 = _super30.call(this);
    window.storage.registerConstructor(stPerversion);
    return _this29;
  }

  _createClass(stPerversion, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPerversion", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPerversion, value.data);
    }
  }]);

  return stPerversion;
}(Stat);

var stAgility = /*#__PURE__*/function (_Stat11) {
  _inherits(stAgility, _Stat11);

  var _super31 = _createSuper(stAgility);

  _createClass(stAgility, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'agility', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'energyMax'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stAgility() {
    var _this30;

    _classCallCheck(this, stAgility);

    _this30 = _super31.call(this);
    window.storage.registerConstructor(stAgility);
    return _this30;
  }

  _createClass(stAgility, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stAgility", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('energyMax', {
        id: 'agility',
        bonus: this.parent.get('agility').value
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stAgility, value.data);
    }
  }]);

  return stAgility;
}(Stat);

var stStrength = /*#__PURE__*/function (_Stat12) {
  _inherits(stStrength, _Stat12);

  var _super32 = _createSuper(stStrength);

  _createClass(stStrength, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'strength', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pAttack'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stStrength() {
    var _this31;

    _classCallCheck(this, stStrength);

    _this31 = _super32.call(this);
    window.storage.registerConstructor(stStrength);
    return _this31;
  }

  _createClass(stStrength, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stStrength", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('healthMax', {
        id: 'strength',
        bonus: this.parent.get('strength').value * 4
      });
      this.parent.addModifier('pAttack', {
        id: 'strength',
        bonus: this.parent.get('strength').value % 4
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stStrength, value.data);
    }
  }]);

  return stStrength;
}(Stat);

var stEndurance = /*#__PURE__*/function (_Stat13) {
  _inherits(stEndurance, _Stat13);

  var _super33 = _createSuper(stEndurance);

  _createClass(stEndurance, null, [{
    key: "setup",
    // core attribute
    value: function setup(context, base, max) {
      var _stat = new stAgility();

      var _n = _stat.data;
      _n.id = 'endurance', _n.base = base, _n.value = base, _n.modifys = [{
        id: 'healthMax'
      }, {
        id: 'pDefense'
      }];
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stEndurance() {
    var _this32;

    _classCallCheck(this, stEndurance);

    _this32 = _super33.call(this);
    window.storage.registerConstructor(stEndurance);
    return _this32;
  }

  _createClass(stEndurance, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stEndurance", this);
    }
  }, {
    key: "updateModifier",
    value: function updateModifier() {
      this.parent.addModifier('healthMax', {
        id: 'endurance',
        bonus: this.arent.get('endurance').value * 4
      });
      this.parent.addModifier('pDefense', {
        id: 'strength',
        bonus: this.parent.get('endurance').value % 4
      });
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stEndurance, value.data);
    }
  }]);

  return stEndurance;
}(Stat);

var stPAttack = /*#__PURE__*/function (_Stat14) {
  _inherits(stPAttack, _Stat14);

  var _super34 = _createSuper(stPAttack);

  _createClass(stPAttack, null, [{
    key: "setup",
    //physical attack
    value: function setup(context, base, max) {
      var _stat = new stPAttack();

      var _n = _stat.data;
      _n.id = 'pAttack', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPAttack() {
    var _this33;

    _classCallCheck(this, stPAttack);

    _this33 = _super34.call(this);
    window.storage.registerConstructor(stPAttack);
    return _this33;
  }

  _createClass(stPAttack, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPAttack", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPAttack, value.data);
    }
  }]);

  return stPAttack;
}(Stat);

var stPDefense = /*#__PURE__*/function (_Stat15) {
  _inherits(stPDefense, _Stat15);

  var _super35 = _createSuper(stPDefense);

  _createClass(stPDefense, null, [{
    key: "setup",
    //physical defense
    value: function setup(context, base, max) {
      var _stat = new stPAttack();

      var _n = _stat.data;
      _n.id = 'pDefense', _n.base = base, _n.value = base;
      context.addItem(_stat);

      _stat.Calc();
    }
  }]);

  function stPDefense() {
    var _this34;

    _classCallCheck(this, stPDefense);

    _this34 = _super35.call(this);
    window.storage.registerConstructor(stPDefense);
    return _this34;
  }

  _createClass(stPDefense, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("stPDefense", this);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(stPDefense, value.data);
    }
  }]);

  return stPDefense;
}(Stat); /////////////////////////////////////////////////////////////////////////


var Effects = /*#__PURE__*/function (_Inventory3) {
  _inherits(Effects, _Inventory3);

  var _super36 = _createSuper(Effects);

  //Todo a collection of Stats is similiar to Inventory?
  function Effects(externlist) {
    var _this35;

    _classCallCheck(this, Effects);

    _this35 = _super36.call(this, externlist);
    window.storage.registerConstructor(Effects);
    return _this35;
  }

  _createClass(Effects, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("Effects", this);
    }
  }, {
    key: "get",
    value: function get(id) {
      return this.getItem(id);
    } //findItemslot uses id, this one finds all effects(-slot) of one type

  }, {
    key: "findEffect",
    value: function findEffect(name) {
      var _items = [];

      for (var i = 0; i < this.count(); i++) {
        if (this.list[i].name === name) _items.push(i);
      }

      return _items;
    } //override

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //just skip if not found

      var _eff = this.get(id);

      this.list.splice(_i, 1);

      _eff.onRemove(this, this.list[_i]);

      this.postItemChange(id, "removed", "");
    }
  }, {
    key: "addItem",
    value: function addItem(id, effect) {
      var _i = this.findItemSlot(id);

      var res; //if effect with same id is already present, merge them

      if (_i > -1) {
        var _old = this.get(effect.id);

        res = _old.merge(effect); //res =window.gm.EffectLib[this.list[_i].name].merge(this,this.list[_i],effect,effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(id, "merged", "");
          return;
        }
      } //or if there are similiar effects try to merge with them


      var _k = this.findEffect(effect.name);

      for (var i = 0; i < _k.length; i++) {
        var _old = this.list[_k];
        res = _old.merge(effect); //res =window.gm.EffectLib[this.list[_k].name].merge(this,this.list[_i],effect,effect.dataPrototype());

        if (res != null) {
          if (res === true) {} else res(this); //should be a function


          this.postItemChange(id, "merged", "");
          break;
        }
      } //else add it to list


      this.list.push({
        'id': id,
        'count': 1,
        item: effect
      });
      effect._parent = window.gm.util.refToParent(this);
      effect.onApply();
      this.postItemChange(id, "added", "");
    }
  }, {
    key: "replace",
    value: function replace(id, neweffect) {
      var _i = this.findItemSlot(id);

      if (_i < 0) return; //Todo do nothing

      var _old = this.get(id);

      _old.onRemove(); //window.gm.EffectLib[this.list[_i].name].onRemove(this,this.list[_i]);


      neweffect._parent = window.gm.util.refToParent(this);
      this.list[_i].item = neweffect;
      neweffect.onApply(this, neweffect);
    }
  }, {
    key: "updateTime",
    value: function updateTime() {
      var now = window.gm.getTime();

      for (var i = 0; i < this.list.length; i++) {
        var _eff = this.list[i].item;

        var foo = _eff.onTimeChange(now);

        if (foo) foo(this);
      }
    } //override

  }, {
    key: "postItemChange",
    value: function postItemChange(id, operation, msg) {
      window.gm.pushLog('Effects: ' + operation + ' ' + id + ' ' + msg + '</br>');
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var _x = window.storage.Generic_fromJSON(Effects, value.data);

      return _x;
    }
  }]);

  return Effects;
}(Inventory); //! because of the save-problem we dont use objects, just static methods


exports.Effects = Effects;

var Effect = /*#__PURE__*/function () {
  function Effect() {
    _classCallCheck(this, Effect);

    this.data = Effect.dataPrototype();
    this.data.time = window.gm.getTime();
  }

  _createClass(Effect, [{
    key: "merge",
    //add Reviver support:
    //window.storage.registerConstructor(???);
    //toJSON() {return window.storage.Generic_toJSON("???", this); };
    //static fromJSON(value) { return window.storage.Generic_fromJSON(???, value.data);};
    //is called when a effect is applied to check if the new effect can be combined with an exisitng one
    //return null if no merge occured
    //return true if the neweffect was merged into existing one; no other effects are then checked for mergeability
    //or return function that has to be executed: (function(Effects){ Effects.replace(data.id,NotTired);}));
    value: function merge(neweffect) {
      return null;
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {}
  }, {
    key: "onRemove",
    value: function onRemove() {}
  }, {
    key: "parent",
    // Attention !!
    //_parent will be added dynamical
    get: function get() {
      return this._parent();
    }
  }, {
    key: "id",
    get: function get() {
      return this.data.id;
    }
  }, {
    key: "name",
    get: function get() {
      return this.data.name;
    }
  }, {
    key: "time",
    get: function get() {
      return this.data.time;
    }
  }, {
    key: "duration",
    get: function get() {
      return this.data.duration;
    }
  }, {
    key: "hidden",
    get: function get() {
      return this.data.hidden;
    }
  }, {
    key: "shortDesc",
    get: function get() {
      return '';
    }
  }], [{
    key: "dataPrototype",
    value: function dataPrototype() {
      return {
        id: 'xxx',
        name: Effect.name,
        time: 0,
        duration: 0,
        hidden: 0
      }; //hidden 0 = visible, 1= name unreadable, 2= value unreadable, 4= hidden
    }
  }]);

  return Effect;
}(); //combat effect use turn-count instead of realtime as duration


exports.Effect = Effect;

var CombatEffect = /*#__PURE__*/function (_Effect) {
  _inherits(CombatEffect, _Effect);

  var _super37 = _createSuper(CombatEffect);

  function CombatEffect() {
    _classCallCheck(this, CombatEffect);

    return _super37.call(this);
  }

  _createClass(CombatEffect, [{
    key: "shortDesc",
    get: function get() {
      return 'missing description';
    } //duration in turns !

  }], [{
    key: "onCombatEnd",
    value: function onCombatEnd(context, data) {} //called before targets turn

  }, {
    key: "onTurnStart",
    value: function onTurnStart(context, data) {} //at end of targets turn

  }, {
    key: "onTurnEnd",
    value: function onTurnEnd(context, data) {}
  }]);

  return CombatEffect;
}(Effect);

var effEnergized = /*#__PURE__*/function (_Effect2) {
  _inherits(effEnergized, _Effect2);

  var _super38 = _createSuper(effEnergized);

  function effEnergized() {
    var _this36;

    _classCallCheck(this, effEnergized);

    _this36 = _super38.call(this);
    _this36.data.id = _this36.data.name = effEnergized.name, _this36.data.duration = 120;
    window.storage.registerConstructor(effEnergized);
    return _this36;
  }

  _createClass(effEnergized, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effEnergized", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //+ 10Energy per hour
      var delta = window.gm.getDeltaTime(time, this.data.time);
      this.data.time = time;
      this.data.duration -= delta;
      if (this.data.duration < 0) delta = delta + this.data.duration; // if delta is 20 but remaining duration is only 5, delta should be capped to 5
      //Effects impact Stats:  Effect->Effects->Character->Stats    is there a prettier wy?

      this.parent.parent.Stats.increment('energy', 10 * delta / 60);

      if (this.data.duration <= 0) {
        //remove yourself
        return function (me) {
          return function (Effects) {
            Effects.removeItem(me.data.id);
          };
        }(this);
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {
      //+10 energy
      this.data.duration = 120;
      this.data.time = window.gm.getTime();
      this.parent.parent.Stats.increment('energy', 10);
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        this.onApply(); //refresh 

        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effEnergized.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effEnergized, value.data);
    }
  }]);

  return effEnergized;
}(Effect);

var effNotTired = /*#__PURE__*/function (_Effect3) {
  _inherits(effNotTired, _Effect3);

  var _super39 = _createSuper(effNotTired);

  function effNotTired() {
    var _this37;

    _classCallCheck(this, effNotTired);

    _this37 = _super39.call(this);
    _this37.data.id = _this37.data.name = effNotTired.name, _this37.data.duration = 120, _this37.data.hidden = 4;
    window.storage.registerConstructor(effNotTired);
    return _this37;
  }

  _createClass(effNotTired, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effNotTired", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //Tired after xxh
      this.data.duration -= window.gm.getDeltaTime(time, this.data.time);
      this.data.time = time;

      if (this.data.duration <= 0) {
        return function (me) {
          return function (Effects) {
            var newdata = new effTired();
            Effects.replace(me.data.id, newdata);
          };
        }(this);
      }

      return null;
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.duration = 120; // todo 600;

      this.data.time = window.gm.getTime();
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        this.onApply(); //refresh

        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effNotTired.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effNotTired, value.data);
    }
  }]);

  return effNotTired;
}(Effect);

var effTired = /*#__PURE__*/function (_Effect4) {
  _inherits(effTired, _Effect4);

  var _super40 = _createSuper(effTired);

  function effTired() {
    var _this38;

    _classCallCheck(this, effTired);

    _this38 = _super40.call(this);
    _this38.data.id = _this38.data.name = effTired.name, _this38.data.duration = 120, _this38.data.hidden = 0;
    window.storage.registerConstructor(effTired);
    return _this38;
  }

  _createClass(effTired, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effTired", this);
    }
  }, {
    key: "onTimeChange",
    value: function onTimeChange(time) {
      //duration not used -> will never expire unless replaced
      var delta = window.gm.getTime() - this.data.time; //-10 max energy after 12h, but only up to 3 times

      if (delta > 60) this.parent.parent.Stats.addModifier('energyMax', {
        id: 'energyMax:Tired',
        bonus: -10
      });
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.time = window.gm.getTime();
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.parent.parent.Stats.removeModifier('energyMax', {
        id: 'energyMax:Tired'
      });
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === 'NotTired') {
        return function (me) {
          return function (Effects) {
            var newdata = new effNotTired();
            Effects.replace(me.data.id, newdata);
          };
        }(this);
      }

      if (neweffect.name === this.data.name) {
        //just ignore
        return true;
      }
    }
  }, {
    key: "desc",
    get: function get() {
      return effTired.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effTired, value.data);
    }
  }]);

  return effTired;
}(Effect);

var effStunned = /*#__PURE__*/function (_CombatEffect) {
  _inherits(effStunned, _CombatEffect);

  var _super41 = _createSuper(effStunned);

  function effStunned() {
    var _this39;

    _classCallCheck(this, effStunned);

    _this39 = _super41.call(this);
    _this39.data.id = _this39.data.name = effStunned.name, _this39.data.duration = 2;
    window.storage.registerConstructor(effStunned);
    return _this39;
  }

  _createClass(effStunned, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("effStunned", this);
    }
  }, {
    key: "onApply",
    value: function onApply() {
      this.data.duration = 2;
    }
  }, {
    key: "merge",
    value: function merge(neweffect) {
      if (neweffect.name === this.data.name) {
        //extends stun
        this.onApply();
        return true;
      }
    }
  }, {
    key: "onCombatEnd",
    value: function onCombatEnd() {
      this.parent.removeItem(data.id);
    }
  }, {
    key: "onTurnStart",
    value: function onTurnStart() {
      this.data.duration -= 1;
      if (this.data.duration <= 0) this.parent.removeItem(this.data.id);
    }
  }, {
    key: "desc",
    get: function get() {
      return effStunned.name;
    }
  }, {
    key: "shortDesc",
    get: function get() {
      return this.desc + " for " + this.data.duration + " turns";
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(effStunned, value.data);
    }
  }]);

  return effStunned;
}(CombatEffect);

var skCooking = /*#__PURE__*/function (_Effect5) {
  _inherits(skCooking, _Effect5);

  var _super42 = _createSuper(skCooking);

  function skCooking() {
    var _this40;

    _classCallCheck(this, skCooking);

    _this40 = _super42.call(this);
    _this40.data.id = _this40.data.name = skCooking.name;
    window.storage.registerConstructor(skCooking);
    return _this40;
  }

  _createClass(skCooking, [{
    key: "toJSON",
    value: function toJSON() {
      return window.storage.Generic_toJSON("skCooking", this);
    }
  }, {
    key: "desc",
    get: function get() {
      return skCooking.name;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      return window.storage.Generic_fromJSON(skCooking, value.data);
    }
  }]);

  return skCooking;
}(Effect);